#!/usr/bin/python3
'''
Fit-o-mat - a versatile program for nonlinear least-squares fitting
Copyright (C) 2017-2020  Andreas Moeglich, University of Bayreuth, Germany
contact me at andreas.moeglich@uni-bayreuth.de

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
'''
VERSION = '0.781'

from PyQt5 import QtCore, QtGui, QtWidgets
from sys import argv, exit, path, platform
from glob import glob
from functools import partial, cmp_to_key
from copy import deepcopy
from ast import literal_eval
from time import asctime, time
from os.path import expanduser, isfile
import webbrowser
import zipfile, io
try:
  from pycorn import pc_res3
  PYCORN_PRESENT = True
except:
  PYCORN_PRESENT = False

import matplotlib
matplotlib.use("Qt5Agg")
import matplotlib.pyplot as plt
from matplotlib.widgets import RectangleSelector as RectSel
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib import patheffects as PathEffects
from mpl_toolkits.axes_grid1 import make_axes_locatable, Size
import xlrd
import xlsxwriter
import numpy as np
import scipy.optimize as optim
import scipy.odr as odr

# reimplement FigureCanvas to optimize graphics refresh  
class MyFigureCanvas(FigureCanvas):
  def __init__(self, parent=None, matplotlibCanvas=None, name='superunknown'):
    super(MyFigureCanvas, self).__init__(parent)
    self.parent = parent
    self.matplotlibCanvas = matplotlibCanvas
    self.refreshCount = 0
    self.destructCounter = 0
    self.name = name

  def myRefresh(self):
    # wrapper function to globally set how draw updates are done
    self.refreshCount += 1
    
    # ready to destruct?
    if(self.destructCounter):
      self.destructCounter -= 1
      if(not self.destructCounter):
        self.matplotlibCanvas.destructAboutLogo()
    
    # do we have arrows to take care of?
    for entry in ['x', 'y']:
      if(self.matplotlibCanvas.handleArrow[entry] != None):
        self.matplotlibCanvas.drawAxisArrow(axis=entry, redraw=False, target='plot')
      if(self.matplotlibCanvas.handleArrowResid[entry] != None):
        self.matplotlibCanvas.drawAxisArrow(axis=entry, redraw=False, target='resid')

    # the actual draw command
    self.draw()
    
  def setDestructionCounter(self, counter=0):
    # sets up destruction of self.handlesAbout
    self.destructCounter = counter

  def getDestructionCounter(self):
    # returns destruction counter
    return self.destructCounter

# custom window for picture preview
class PreviewWindow(QtWidgets.QMainWindow):
  def __init__(self, *args, **kwargs):
    super(PreviewWindow, self).__init__(*args, **kwargs)
    self.NUMBER_TILES = 15
    self.displayPreview = None

  def paintEvent(self, event):
    # draw rounded corners
    s = self.size()
    winWidth, winHeight = s.width(), s.height()
    offsetX, offsetY = 0, 0
    targetWidth, targetHeight = winWidth, winHeight
    # adjust this to fit the draw area
    if((self.displayPreview != None) and (hasattr(self.displayPreview, 'size'))):
      targetSize = self.displayPreview.size()
      targetWidth, targetHeight = targetSize.width(), targetSize.height()
      offsetX, offsetY = winWidth - targetWidth, winHeight - targetHeight
    # do the actual painting
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)
    qp.setPen(QtCore.Qt.NoPen)
    # draw background rectangle
    qp.setBrush(QtGui.QColor(180, 180, 180, 255))
    qp.drawRect(offsetX, offsetY, targetWidth, targetHeight)
    # draw checkered boxes
    qp.setBrush(QtGui.QColor('white'))
    deltaX, deltaY = int(targetWidth / self.NUMBER_TILES), int(targetHeight / self.NUMBER_TILES)
    for dx in range(self.NUMBER_TILES):
      for dy in range(self.NUMBER_TILES):
        if((dx + dy) % 2):
          qp.drawRect(offsetX + dx * deltaX, offsetY + dy * deltaY, deltaX, deltaY)
    # fini
    qp.end()

  def setDisplayPreview(self, displayPreview):
    # tells the preview window where to paint the checker marks
    self.displayPreview = displayPreview
    
  def keyPressEvent(self, event):
    # catches escape key
    if(event.key() == QtCore.Qt.Key_Escape):
      self.close()
    else:
      # activate normal event handling
      QtWidgets.QMainWindow.keyPressEvent(self, event)

# custom QComboBox to fix Qt layout bug on Mac :(
# exploit Mac stupidity to also implement pass-through of Ctrl key presses
class QComboBoxMac(QtWidgets.QComboBox):
  def __init__(self, *args, **kwargs):
    super(QComboBoxMac, self).__init__(*args, **kwargs)
    self.setAttribute(QtCore.Qt.WA_LayoutUsesWidgetRect)

  def keyPressEvent(self, event):
    # pass through events with Ctrl modifier
    if(event.modifiers() & QtCore.Qt.ControlModifier):
      event.ignore()
      return
    else:
      # normal event processing
      QtWidgets.QComboBox.keyPressEvent(self, event)

# custom QPushButton to fix Qt layout bug on Mac :(
class QPushButtonMac(QtWidgets.QPushButton):
  def __init__(self, *args, **kwargs):
    super(QPushButtonMac, self).__init__(*args, **kwargs)
    self.setAttribute(QtCore.Qt.WA_LayoutUsesWidgetRect)

# a funky new push button
class QPushButtonCheckable(QPushButtonMac):
  def __init__(self, *args, **kwargs):
    super(QPushButtonCheckable, self).__init__(*args, **kwargs)
    self.setCheckable(True)
    self.checkMe = False
  
  def setCheckMe(self, state):
    # controls whether to draw check mark when checked
    self.checkMe = state

  def paintEvent(self, event):
    # original draw event
    QPushButtonMac.paintEvent(self, event)
    
    s = self.size()
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)

    pen = QtGui.QPen()
    pen.setStyle(QtCore.Qt.SolidLine)
    pen.setJoinStyle(QtCore.Qt.RoundJoin)

    # draw check mark?
    if(self.checkMe and self.isChecked()):
      pen.setColor(QtGui.QColor(0, 0, 0, 255))
      pen.setWidth(scaledDPI(2))
      pen.setCapStyle(QtCore.Qt.RoundCap)
      qp.setPen(pen)
      qp.setBrush(QtCore.Qt.NoBrush)
      
      path = QtGui.QPainterPath()
      path.moveTo(scaledDPI(5), scaledDPI(5))
      path.lineTo(s.width() - scaledDPI(5), s.height() - scaledDPI(5))
      path.moveTo(scaledDPI(5), s.height() - scaledDPI(5))
      path.lineTo(s.width() - scaledDPI(5), scaledDPI(5))
      qp.drawPath(path)
    
    # overlay gradient
    pen.setColor(QtGui.QColor(171, 171, 171, 255))
    pen.setWidth(scaledDPI(1))
    pen.setCapStyle(QtCore.Qt.SquareCap)
    qp.setPen(pen)

    if(self.isChecked()):
      grad = QtGui.QLinearGradient(0, s.height(), 0, 0)
    else:
      grad = QtGui.QLinearGradient(0, 0, 0, s.height())
    grad.setColorAt(0, QtGui.QColor(255, 255, 255, 150))
    grad.setColorAt(0.2, QtGui.QColor(255, 255, 255, 0))
    grad.setColorAt(0.88, QtGui.QColor(180, 180, 180, 0))
    grad.setColorAt(1, QtGui.QColor(180, 180, 180, 120))
    qp.setBrush(QtGui.QBrush(grad))

    qp.drawRoundedRect(0, 0, s.width(), s.height(), scaledDPI(2), scaledDPI(2))
    qp.end()

# custom QWidget to fix Qt layout bug on Mac :(
class QWidgetMac(QtWidgets.QWidget):
  def __init__(self, *args, **kwargs):
    super(QWidgetMac, self).__init__(*args, **kwargs)
    self.setAttribute(QtCore.Qt.WA_LayoutUsesWidgetRect)

# custom QMenu for pass-through of Ctrl-key
class MuhMenu(QtWidgets.QMenu):
  def __init__(self, *args, **kwargs):
    super(MuhMenu, self).__init__(*args, **kwargs)

  def keyPressEvent(self, event):
    # pass through events with Ctrl modifier
    if(event.modifiers() & QtCore.Qt.ControlModifier):
      # somehow event pass-through not working
      # explicitly call keypressevent of main gui as pass through from QMenu fails for some reason
      myapp.keyPressEvent(event)
      event.ignore()
    else:
      # normal event processing
      QtWidgets.QMenu.keyPressEvent(self, event)

  # enable normal tab stops
  def focusNextPrevChild(self, next):
    return QtWidgets.QWidget.focusNextPrevChild(self, next)

# custom-styled QMenu
class KuhMenu(MuhMenu):
  def __init__(self, *args, **kwargs):
    super(KuhMenu, self).__init__(*args, **kwargs)
    self.borderRadius = scaledDPI(5)
    
  def paintEvent(self, event):
    # draw rounded corners
    s = self.size()
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)
    qp.drawRoundedRect(0, 0, s.width(), s.height(), self.borderRadius, self.borderRadius)
    qp.end()

# custom QStatusbar for colored error messages
class KuhStatusBar(QtWidgets.QStatusBar):
  def __init__(self, *args, **kwargs):
    super(KuhStatusBar, self).__init__(*args, **kwargs)
    self.timer = None
    
  def showMessage(self, message='', timer=10000, color='red'):
    # set color
    self.setStyleSheet('QStatusBar{color:' + color + ';font-weight:bold;}')
    QtWidgets.QStatusBar.showMessage(self, message, timer)
    # set up timer to revert style sheet change (probably not needed b/c all messages should appear in same color)
    if(self.timer == None):
      self.timer = QtCore.QTimer()
      self.timer.timeout.connect(self.myTimeOut)
      self.timer.setSingleShot(True)
      self.timer.start(timer)
    else:
      # if timer already exists, reset timer
      self.timer.start(timer)
    
  def myTimeOut(self):
    # resets time sheet
    self.setStyleSheet('QStatusBar{color:black;font-weight:normal;}')
    self.timer = None
        
# a delegate for custom display of float numbers
class FloatFormatDelegate(QtWidgets.QStyledItemDelegate):
  def __init__(self):
    super(FloatFormatDelegate, self).__init__()

  def displayText(self, value, locale):
    if(type(value) == float):
      return QtWidgets.QStyledItemDelegate.displayText(self, value, locale).replace(',', '.')
    else:
      return QtWidgets.QStyledItemDelegate.displayText(self, value, locale)

# subclass delegate to highlight certain cells
class FloatFormatDelegateColor(FloatFormatDelegate):
  def paint(self, painter, option, index):
    QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)
    retv = index.data(QtCore.Qt.UserRole)
    if (retv):
      painter.save()
      if(retv == 1):
        # good rows
        brushColor = QtCore.Qt.green
      else:
        # bad rows
        brushColor = QtCore.Qt.red
      painter.setBrush(QtGui.QBrush(brushColor))
      painter.setOpacity(0.4)
      painter.setPen(QtCore.Qt.NoPen)
      r = QtCore.QRect(option.rect)
      painter.drawRect(r)
      painter.restore()

# custom table model for speeding up data loading (QTableView vs. QTableWidget)
class TableModel(QtCore.QAbstractTableModel):
  def __init__(self, data, parent=None):
    super(TableModel, self).__init__(parent)
    self.parent = parent
    if(hasattr(data, 'tolist')):
      # deal with numpy data
      self._data = data.tolist()
    else:
      self._data = data
    self.headers = [str(i+1) for i in range(self.columnCount())]
    self.parent.setAlternatingRowColors(True)

  def rowCount(self, parent=None):
    return len(self._data)

  def columnCount(self, parent=None):
    return len(self._data[0]) if self.rowCount() else 0

  def data(self, index, role=QtCore.Qt.DisplayRole):
    if role == QtCore.Qt.DisplayRole:
      row = index.row()
      if 0 <= row < self.rowCount():
        column = index.column()
        if 0 <= column < self.columnCount():
          return self._data[row][column]
    elif(role == QtCore.Qt.TextAlignmentRole):
      row, column = index.row(), index.column()
      if(type(self._data[row][column]) in [float, int]):
        return QtCore.Qt.AlignRight
      else:
        return QtCore.Qt.AlignLeft
        
  def dataByIndices(self, row=0, column=0):
    if 0 <= row < self.rowCount():
      if 0 <= column < self.columnCount():
        return self._data[row][column]
        
  def headerData(self, section, orientation, role=QtCore.Qt.DisplayRole):
    if role == QtCore.Qt.DisplayRole and orientation == QtCore.Qt.Horizontal:
      if(section<len(self.headers)):
        return self.headers[section]
      else:
        # needed for UI calls while table empty
        return ''
    return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)        

  def setAllHeaders(self, headerData):
    maxIndex = min(self.columnCount(), len(headerData))
    self.headers[:maxIndex] = headerData[:maxIndex]

  def setSingleHeader(self, index, label):
    if(index < self.columnCount()):
      self.headers[index] = label
      
  def getDataRows(self, indices):
    retv = [self._data[index] for index in indices]
    return retv

  def getHeaders(self):
    return self.headers

  def getAllData(self):
    return self._data
  
  def setData(self, value, row, column):
    if((0 <= row < self.rowCount()) and (0 <= column < self.columnCount())):
      self._data[row][column] = value

  def pasteDataBlock(self, data, offsetRow=0, offsetColumn=0):
    for row in data:
      if(offsetRow < self.rowCount()):
        rowItems = len(row)
        self._data[offsetRow][offsetColumn:offsetColumn + rowItems] = row
      offsetRow += 1

# subclass custom table model for highlighting cells
class DataTableModel(TableModel):
  def __init__(self, data, parent=None):
    super(DataTableModel, self).__init__(data, parent)
    # cellhighlighting
    self.goodRows, self.badRows = [], []
    self.selCols = []
    self.timer = None
    self.defaultTimeOut = 5000
    self.parent.setObjectName('data')
    if(not (platform in ['linux', 'darwin'])):
      btn = self.parent.findChild(QtWidgets.QAbstractButton)
      btn.setToolTip('Click to select entire table')
    
  def data(self, index, role=QtCore.Qt.DisplayRole):
    if role == QtCore.Qt.DisplayRole:
      row = index.row()
      if 0 <= row < self.rowCount():
        column = index.column()
        if 0 <= column < self.columnCount():
          return self._data[row][column]
    elif(role == QtCore.Qt.UserRole):
      if(index.column() in self.selCols):
        if(index.row() in self.goodRows):
          return 1
        elif(index.row() in self.badRows):
          return 2
      return 0
    elif(role == QtCore.Qt.TextAlignmentRole):
      row, column = index.row(), index.column()
      if(type(self._data[row][column]) in [float, int]):
        return QtCore.Qt.AlignRight
      else:
        return QtCore.Qt.AlignLeft
    
  def setGoodBad(self, goodRows=[], badRows=[], selCols=[]):
    # updates good and bad rows
    self.goodRows, self.badRows, self.selCols = goodRows, badRows, selCols

    # set up timer to revert style sheet change (probably not needed b/c all messages should appear in same color)
    if(self.timer == None):
      self.timer = QtCore.QTimer()
      self.timer.timeout.connect(self.myTimeOut)
      self.timer.setSingleShot(True)
      self.timer.start(self.defaultTimeOut)
    else:
      # if timer already exists, reset timer
      self.timer.start(self.defaultTimeOut)
      
    # trigger update
    self.layoutChanged.emit()
    self.parent.setFocus()
    
  def myTimeOut(self):
    # resets coloring of cells
    self.goodRows, self.badRows, self.selCols = [], [], []
    self.timer = None
    # trigger update
    self.layoutChanged.emit()
   
# a custom cursor
class MyCursor(matplotlib.widgets.Cursor):
  def __init__(self, *args, **kwargs):
    super(MyCursor, self).__init__(*args, **kwargs)
    self.label = self.ax.text(1, 1, '', animated=True)
    self.label.set_fontsize(scaledDPI(11))
    # does not heed clip_on, mayhpas due to blitting
    self.label.set_clip_on(False)
    # need to store background for initial creation of cursor
    self.background = self.canvas.copy_from_bbox(self.ax.bbox)
    # initialize parent and ax2
    self.parent = None
    self.ax2 = None
    # initialize twin and slave
    self.twin = None
    
  def setParent(self, parent=None):
    self.parent = parent
    
  def setAx2(self, ax2=None):
    self.ax2 = ax2

  def setTwin(self, twin=None):
    self.twin = twin

  def onmove(self, event):
    """on mouse motion draw the cursor if visible"""
    if self.ignore(event):
      return
    if not self.canvas.widgetlock.available(self):
      return
    if event.inaxes != self.ax:
      self.linev.set_visible(False)
      self.lineh.set_visible(False)
      self.label.set_visible(False)

      if self.needclear:
        self.canvas.draw()
        self.needclear = False
      return
    self.needclear = True
    if not self.visible:
      return
    
    self.refreshCrossHair(event)
    # check whether we are on canvas
    if ((event.xdata != None) and (event.ydata != None)):
      self._update()
      if(self.twin != None):
        self.twin._update()

  def refreshCrossHair(self, event):
    # update cross hair
    self.linev.set_xdata((event.xdata, event.xdata))
    self.lineh.set_ydata((event.ydata, event.ydata))
    self.linev.set_visible(self.visible and self.vertOn)
    self.lineh.set_visible(self.visible and self.horizOn)
    # update label size
    if(self.parent != None):
      currZoomLevel = self.parent.matplot.get_dpi()
      self.linev.set_linewidth(1.0 * 100.0 / currZoomLevel)
      self.lineh.set_linewidth(1.0 * 100.0 / currZoomLevel)
    # update label size
    if(self.parent != None):
      currZoomLevel = self.parent.matplot.get_dpi()
      self.label.set_fontsize(scaledDPI(11) * 100.0 / currZoomLevel)
    # check whether we are on canvas
    if ((event.xdata != None) and (event.ydata != None)):
      labelText = ' x: ' + self.formatNumber(event.xdata) + ' \n y: ' + self.formatNumber(event.ydata) + ' '
      if((self.parent != None) and (self.parent.isSecondAxesActive())):
        secondX, secondY = self.parent.ax2.transData.inverted().transform((event.x, event.y))
        labelText += '\n y2: ' + self.formatNumber(secondY) + ' '
      self.label.set_text(labelText)
    # update color
    color = 'black'
    if(self.ax2 != None):
      canvasColor = self.ax2.patch.get_facecolor()
      # we need this check to deal with canvas having 'none' facecolor
      if(np.isclose(sum(canvasColor), 0.0)):
        figureColor = self.parent.matplot.get_facecolor()
        if(np.isclose(sum(figureColor), 0.0)):
          color = 'black'
        elif(sum(figureColor[0:3]) < 1.5):
          color = 'white'
      elif(sum(canvasColor[0:3]) < 1.5):
        color = 'white'
    self.label.set_color(color)
    self.lineh.set_color(color)
    self.linev.set_color(color)
    # check quadrant of plot
    if(event.x > ((self.ax.bbox.xmin + self.ax.bbox.xmax) / 2.0)):
      self.label.set_horizontalalignment('right')
    else:
      self.label.set_horizontalalignment('left')
    if(event.y > ((self.ax.bbox.ymin + self.ax.bbox.ymax) / 2.0)):
      self.label.set_verticalalignment('top')
    else:
      self.label.set_verticalalignment('bottom')
    # update label position
    self.label.set_x(event.xdata)
    self.label.set_y(event.ydata)
    self.label.set_visible(self.visible)
    # check twin
    if(self.twin != None):
      self.twin.lineh.set_visible(self.visible and self.twin.horizOn)
      self.twin.lineh.set_ydata((event.ydata, event.ydata))
      self.twin.lineh.set_color(color)

  def getHandles(self):
    # returns handles to graphics elements
    handles = [self.linev, self.lineh, self.label]
    return handles

  def _update(self):
    if self.useblit:
      if self.background is not None:
        self.canvas.restore_region(self.background)
      # check whether axis object is visible (required for split x axis)
      if(self.ax.get_visible()):
        self.ax.draw_artist(self.linev)
        self.ax.draw_artist(self.lineh)
        self.ax.draw_artist(self.label)
        self.canvas.blit(self.ax.bbox)
    else:
      self.canvas.draw_idle()

    return False

  def toggleVisibility(self, state=False, event=None):
    self.visible = state
    if(event != None):
      if(self.visible):
        self.refreshCrossHair(event)
        # cross hair was toggled on split axis -- should not display the cross hairs
        if(event.inaxes != self.ax):
          self.linev.set_visible(False)
          self.lineh.set_visible(False)
          self.label.set_visible(False)
      else:
        self.linev.set_visible(self.visible and self.vertOn)
        self.lineh.set_visible(self.visible and self.horizOn)
        self.label.set_visible(self.visible)
      # check whether we are on canvas
      if ((event.xdata != None) and (event.ydata != None)):
        self._update()
        if(self.twin != None):
          self.twin._update()

  def formatNumber(self, number):
    # formats number for output
    precision = 2
    NUMBER_SWITCH = 10 ** (precision + 1)
    FORMAT_DECIMAL = '{:.' + str(precision + 1) + 'f}'
    # determine return string
    if((self.isNumber(number)) and (np.isfinite(float(number)))):
      if((np.abs(number) > NUMBER_SWITCH) or (np.abs(number) < 1.0 / NUMBER_SWITCH)):
        # do this in mathtext
        # calculate exponent
        if(number != 0.0):
          try:
            exponent = int(np.floor(np.log10(np.abs(number))))
          except:
            exponent = 0
          # calculate preexponent
          try:
            pre = number / (10 ** exponent)
          except:
            pre, exponent = number, 0
        # assemble string
        if(number == 0.0):
          retstr = '{:.' + str(precision) + 'f}'
          retstr = retstr.format(0.0)
          numberstr = '$\\mathdefault{' + retstr + '}$' 
        elif(np.isclose(pre, 1.0)):
          numberstr = '$\\mathdefault{10^{' + str(exponent) + '}}$'
        elif(np.isclose(pre, -1.0)):
          numberstr = '$\\mathdefault{-10^{' + str(exponent) + '}}$'
        else:
          retstr = '{:.' + str(precision) + 'f}'
          retstr = retstr.format(pre)
          # cannot use \times here b/c of xkcd font which lacks the symbol
          numberstr = '$\\mathdefault{' + retstr + '\ x\ 10^{' + str(exponent) + '}}$'         
      else:
        numberstr = FORMAT_DECIMAL.format(number)
    else:
      numberstr = str(number)
    
    return numberstr

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False

# validators that take care of commata once and for all
class MyValidInt(QtGui.QIntValidator):
  def __init__(self, *args, **kwargs):
    super(MyValidInt, self).__init__(*args, **kwargs)
    
  def validate(self, s, pos):
    if(',' in s):
      # plainly ignores commata
      s = s.replace(',', '')
      # correct pos for the character we deleted
      if(pos):
        pos -= 1
      
    # call the regular validator
    return QtGui.QIntValidator.validate(self, s, pos)

class MyValidFloat(QtGui.QDoubleValidator):
  def __init__(self, *args, **kwargs):
    super(MyValidFloat, self).__init__(*args, **kwargs)

  def validate(self, s, pos):
    if(',' in s):
      # plainly ignores commata
      s = s.replace(',', '.')
      
    # call the regular validator
    return QtGui.QDoubleValidator.validate(self, s, pos)

# a QLineEdit that finally behaves as I want
class QLineEditClick(QtWidgets.QLineEdit):
  def __init__(self, argument=None):
    super(QLineEditClick, self).__init__(argument)
    self._gainedFocus = False
    self._originalMousePressEvent = QtWidgets.QLineEdit.mousePressEvent
    self._originalFocusInEvent = QtWidgets.QLineEdit.focusInEvent
    self.setAlignment(QtCore.Qt.AlignRight)

  def focusInEvent(self, event):
    self._originalFocusInEvent(self, event)
    self.selectAll()
    
    # determine how we got focus (0 is via mouse action)
    if(event.reason() == 0):
      self._gainedFocus = True
      
  def setText(self, text):
    # ensure that long entries are scrolled to beginning
    QtWidgets.QLineEdit.setText(self, text)
    self.setCursorPosition(0)
    
  def focusOutEvent(self, event):
    # ensure that long entries are scrolled to beginning
    QtWidgets.QLineEdit.focusOutEvent(self, event)
    self.setCursorPosition(0)

  def mousePressEvent(self, event):
    self._originalMousePressEvent(self, event)
    if(self._gainedFocus):
      self.selectAll()
      self._gainedFocus = False

# menu for transforming columns in the data table
class TransformerMenu(MuhMenu):
  def __init__(self, parent=None, col=1, formula=''):
    super(TransformerMenu, self).__init__()
    self.parent = parent
    self.col = col
    self.formula = formula
      
    # set up GUI
    self.buildRessource()

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(not self.underMouse()):
      # pass through event (and thereby close the QMenu)
      MuhMenu.mousePressEvent(self, event)

  def buildRessource(self):
    # build gui for setting options
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[2]*4)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # heading
    self.exportSettingLabel = QtWidgets.QLabel('Transform column')
    useFont = self.exportSettingLabel.font()
    useFont.setBold(True)
    self.exportSettingLabel.setFont(useFont)
    self.vLayout.addWidget(self.exportSettingLabel)
    
    # formula entry
    self.transformGroup = QtWidgets.QWidget()
    self.vLayout.addWidget(self.transformGroup)
    
    self.transformLayout = QtWidgets.QHBoxLayout(self.transformGroup)
    self.transformLayout.setContentsMargins(*[2]*4)
    self.transformLayout.setAlignment(QtCore.Qt.AlignLeft)

    self.transformLabel = QtWidgets.QLabel('C' + str(self.col + 1) + ' = ')
    self.transformLabel.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.transformLabel.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.transformLayout.addWidget(self.transformLabel)

    self.transformEntry = QLineEditClick()
    self.transformEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.transformEntry.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
    if(self.formula == ''):
      self.transformEntry.setText('C' + str(self.col + 1) + ' + ROW')
    else:
      self.transformEntry.setText(self.formula)
    self.transformLayout.addWidget(self.transformEntry)
    
    # button
    self.transformButton = QPushButtonMac()
    self.transformButton.setText('Transform!')
    self.transformButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.transformButton.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.transformButton.clicked.connect(self.doTransform)
    self.vLayout.addWidget(self.transformButton)

    self.setFocus()    
    self.focusNextChild()

  def doTransform(self):
    # starts transformation in parent object
    formula = self.transformEntry.text()
    self.parent.doTransformer(self.col, formula)
    self.close()

# the data table widget
class DataTable(QtWidgets.QTableView):
  def __init__(self, parent=None):
    super(DataTable, self).__init__(parent)
    self.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
    self.parent = parent
    self.tableModel = None
    self.currentRow, self.currentCol = 0, 0
    self.pageStep = 20
    self.minColWidth = scaledDPI(35)
    # connect click event on table header
    hheader = self.horizontalHeader()
    hheader.sectionClicked.connect(self.changeRole)
    hheader.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    hheader.customContextMenuRequested.connect(self.sortitsch)
    # set delegate
    self.setItemDelegate(FloatFormatDelegateColor())
    # set up namespace
    # import numpy again
    import numpy as np
    # import common functions from numpy for ease of access
    from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh
    self.mySpace = locals()
    self.storeFormula = ''
    
  def configTable(self, dimx, dimy, retainRoles=False, retainSelection=False, init=False):
    # helper function called by different file importers
    # set row height and prevent from resizing
    self.rowHeight = int(self.fontMetrics().height() + scaledDPI(2))
    if(init):
      self.rowHeight = scaledDPI(18)
    vheader = self.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    for entry in range(dimy):
      vheader.setSectionResizeMode(entry, QtWidgets.QHeaderView.Fixed)
      
    # set col width
    self.colWidth = int(self.size().width() / 4.5)
    self.colWidth = min(scaledDPI(120), self.colWidth)
    hheader = self.horizontalHeader()
    if(not init):
      for entry in range(dimx):
        hheader.setSectionResizeMode(entry, QtWidgets.QHeaderView.Interactive)
        useSize = max(self.sizeHintForColumn(entry) + scaledDPI(2), self.minColWidth)
        # restrict column size to max. 80% of visible area (to allow easy resizing)
        useSize = min(useSize, int(0.8 * self.size().width()))
        hheader.resizeSection(entry, useSize)
    
    # set selection mode
    self.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    
    # select all
    if(not retainSelection):
      self.selectAll()
    
    # connect event for selection update
    self.selectionModel().selectionChanged.connect(partial(self.parent.updateData, True))
    self.selectionModel().currentChanged.connect(self.currentCellChanged)
    
    # assign roles to columns (-1 means role is undefined)
    if(retainRoles):
      for item in ['x', 'y', 'xerr', 'yerr', 'labels']:
        if(item in self.roles):
          # check whether target column is available
          if(self.roles[item] >= dimx):
            self.roles[item] = -1
        else:
          self.roles[item] = -1
    else:
      self.roles = {'x': -1, 'y': -1, 'xerr': -1, 'yerr': -1, 'labels': -1}
      if (dimx):
        self.roles['x'] = 0
        if (dimx == 2):
          self.roles['y'] = 1
        elif(dimx >= 3):
          self.roles['y'] = 1
          # rather disable error column by default (as this may throw off some users)
          ###self.roles['yerr'] = 2
    self.rolestr = {'x':'x', 'y':'y', 'xerr':u'\N{GREEK CAPITAL LETTER DELTA}x', 'yerr':u'\N{GREEK CAPITAL LETTER DELTA}y', 'labels':'labels'}
    # asisgn numbered column headers
    headerData = [str(i + 1) for i in range(dimx)]
    # update headers for roles
    for key in self.roles:
      if(self.roles[key] + 1):
        headerData[self.roles[key]] = str(self.roles[key] + 1) + ' (' + self.rolestr[key] + ')'
    self.tableModel.setAllHeaders(headerData)
    self.setModel(self.tableModel)
    self.setFocus()

  def killTheComma(self):
    # processes sheet data and replaces all commata by period
    if(len(self.sheetData)):
      dimx, dimy = len(self.sheetData[0]), len(self.sheetData)
      nuData = []
      for row in self.sheetData:
        nuData.append([self.killHelper(i) for i in row])
        
      self.sheetData = nuData
      self.tableModel = DataTableModel(self.sheetData, self)
      self.configTable(dimx, dimy, retainRoles=True, retainSelection=False)
      self.selectAll()

      nuIndex = self.model().index(self.currentRow, self.currentCol)
      self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
      self.tableModel.layoutChanged.emit()
      
      # for some strange reason we have to connect the event again, grrrr! (should've been done in self.configTable())
      self.selectionModel().currentChanged.connect(self.currentCellChanged)
      
  def killHelper(self, item):
    if(type(item) in [int, float]):
      return item
    elif((type(item) == str) and (',' in item)):
      convItem = item.replace(',', '.')
      try:
        convItem = float(convItem)
        return convItem
      except:
        return item
    else:
      return item

  def generateEmptyTable(self, columnCount=4, rowCount=20):
    # intializes blank table
    blankData = [[''] * columnCount for i in range(rowCount)]
    self.sheetData = blankData
    self.tableModel = DataTableModel(self.sheetData, self)
    self.setModel(self.tableModel)
    self.configTable(columnCount, rowCount, init=True)

    self.clearSelection()
    if(rowCount):
      self.selectRow(0)
    nuIndex = self.model().index(self.currentRow, self.currentCol)
    self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    self.tableModel.layoutChanged.emit()    

  def resizeTable(self, columnCount=4, rowCount=20):
    # grows/shrinks data table as needed
    if(self.tableModel != None):
      currData = self.tableModel.getAllData()
      
      # prepare new data, initialize empty
      nuData = [[''] * columnCount for i in range(rowCount)]
      cycleRow = min(len(currData), rowCount)
      if(len(currData)):
        cycleColumn = min(len(currData[0]), columnCount)
        
        for row in range(cycleRow):
          nuData[row][:cycleColumn] = currData[row][:cycleColumn]
      
        self.tableModel = DataTableModel(nuData, self)
        self.setModel(self.tableModel)
        
        # configure table
        self.configTable(columnCount, rowCount, retainRoles=True)

  def getDimension(self):
    return self.tableModel.rowCount(), self.tableModel.columnCount()

  def restoreTable(self, tableData=[]):
    # used by loadState fxn
    if(len(tableData)):
      self.currentRow, self.currentCol = 0, 0
      self.sheetData = tableData
      self.tableModel = DataTableModel(self.sheetData, self)
      self.setModel(self.tableModel)
      
      dimx, dimy = len(tableData[0]), len(tableData)
      self.configTable(dimx, dimy)
      
      nuIndex = self.model().index(self.currentRow, self.currentCol)
      self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
      self.tableModel.layoutChanged.emit()    

  def loadXLS(self, filename, transpose=False):
    # open XLS sheet
    QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
    QtCore.QCoreApplication.processEvents()
    try:
      self.wb = xlrd.open_workbook(filename)
    except:
      self.parent.parent.statusbar.showMessage('Cannot load data file ' + filename, self.parent.parent.STATUS_TIME)
    else:
      self.sheetNames = self.wb.sheet_names()
      
      # update number of available sheets and current sheet
      self.parent.resetSheetSpinBox(currVal=1, maxVal=self.wb.nsheets, currName=self.sheetNames[0])
      
      # initally assume data is on first sheet
      self.sheet = self.wb.sheet_by_index(0)
      (dimx, dimy) = (self.sheet.ncols, self.sheet.nrows)
      
      # populate the table
      self.sheetData = []
      for entry in range(dimy):
        row = self.sheet.row_values(entry)
        self.sheetData.append(row)
        
      # transpose data?
      if((transpose) and (len(self.sheetData))):
        transposedData = []
        for entry1 in range(len(self.sheetData[0])):
          row = []
          for entry2 in range(len(self.sheetData)):
            row.append(self.sheetData[entry2][entry1])
          transposedData.append(row)
        self.sheetData = transposedData
        dimx, dimy = dimy, dimx
      
      self.tableModel = DataTableModel(self.sheetData, self)
      self.setModel(self.tableModel)
      
      # configure table
      self.configTable(dimx, dimy)

    QtWidgets.QApplication.restoreOverrideCursor()
  
  def changeSheet(self, currVal=1, transpose=False):
    # update number of available sheets and current sheet
    self.parent.resetSheetSpinBox(currVal=currVal, maxVal=self.wb.nsheets, currName=self.sheetNames[currVal - 1])

    # changes sheet in multi-sheet Excel file
    self.sheet = self.wb.sheet_by_index(currVal - 1)
    (dimx, dimy) = (self.sheet.ncols, self.sheet.nrows)
    
    # populate the table
    self.sheetData = []
    for entry in range(dimy):
      row = self.sheet.row_values(entry)
      self.sheetData.append(row)
    
    # transpose data?
    if((transpose) and (len(self.sheetData))):
      transposedData = []
      for entry1 in range(len(self.sheetData[0])):
        row = []
        for entry2 in range(len(self.sheetData)):
          row.append(self.sheetData[entry2][entry1])
        transposedData.append(row)
      self.sheetData = transposedData
      dimx, dimy = dimy, dimx
      
    self.tableModel = DataTableModel(self.sheetData, self)
    self.setModel(self.tableModel)

    # configure table
    self.configTable(dimx, dimy, retainRoles=True)

  def transposeTable(self):
    # takes current data table and transposes contents
    if(self.tableModel != None):
      currData = self.tableModel.getAllData()
      
      # transpose data
      if(len(currData)):
        transposedData = []
        for entry1 in range(len(currData[0])):
          row = []
          for entry2 in range(len(currData)):
            row.append(currData[entry2][entry1])
          transposedData.append(row)
        self.sheetData = transposedData
        dimx, dimy = len(self.sheetData[0]), len(self.sheetData)
        
      self.tableModel = DataTableModel(self.sheetData, self)
      self.setModel(self.tableModel)
  
      # configure table
      self.configTable(dimx, dimy, retainRoles=True)

  def loadUnicornFile(self, filename, transpose=False):
    # opens a Unicorn file
    QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
    QtCore.QCoreApplication.processEvents()
    try:
      filecontent = pc_res3(filename)
      filecontent.load()
    except:
      self.parent.parent.statusbar.showMessage('Cannot load data file ' + filename, self.parent.parent.STATUS_TIME)
    else:
      tempSheetData = []
      dimx, dimy = 0, 0
      for entry in ['UV', 'Cond', 'pH', 'Pressure', 'Temp', 'Conc']:
        if((entry in filecontent) and ('data' in filecontent[entry])):
          if(len(filecontent[entry]['data'])):
            if(len(tempSheetData)):
              # write header
              tempSheetData[0].extend([''] * (len(filecontent[entry]['data'][0]) + 1))
              tempSheetData[0][-len(filecontent[entry]['data'][0])] = entry
              # write data
              curry = len(filecontent[entry]['data'])# + 1
              # is new entry larger?
              if(curry > dimy):
                for tilt in range(curry - dimy):
                  tempSheetData.append([''] * dimx)
                dimy = curry
              # now append new columns
              for row in range(dimy - 1):
                if(row < curry):# - 1):
                  tempSheetData[row + 1].extend([''] + list(filecontent[entry]['data'][row]))
                else:
                  tempSheetData[row + 1].extend([''] * (len(filecontent[entry]['data'][0]) + 1))
              # adjust dimensions
              dimx += 1 + len(filecontent[entry]['data'][0])
            else:
              # write header
              tempSheetData = [[''] * len(filecontent[entry]['data'][0])]
              tempSheetData[0][0] = entry
              # write data
              tempSheetData.extend([list(i) for i in filecontent[entry]['data']])
              dimx, dimy = len(filecontent[entry]['data'][0]), len(filecontent[entry]['data']) + 1

      # did we find any data to import?
      if(len(tempSheetData)):
        self.sheetData = tempSheetData
  
        # transpose data?
        if((transpose) and (len(self.sheetData))):
          transposedData = []
          for entry1 in range(len(self.sheetData[0])):
            row = []
            for entry2 in range(len(self.sheetData)):
              row.append(self.sheetData[entry2][entry1])
            transposedData.append(row)
          self.sheetData = transposedData
          dimx, dimy = dimy, dimx
  
        self.tableModel = DataTableModel(self.sheetData, self)
        self.setModel(self.tableModel)
  
        # configure table
        self.configTable(dimx, dimy)            

    QtWidgets.QApplication.restoreOverrideCursor()

  def loadTextFile(self, filename, delimiter='\t', transpose=False):
    # open a text file
    QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
    QtCore.QCoreApplication.processEvents()
    try:
      # try opening text file
      readhandle = open(filename, 'r')
      filecontent = readhandle.readlines()
    except:
      self.parent.parent.statusbar.showMessage('Cannot load data file ' + filename, self.parent.parent.STATUS_TIME)
    else:
      readhandle.close()
      
      # determine row and col count
      filecontent = [i.rstrip() for i in filecontent]
      dimy = len(filecontent)
      #dimx = max([i.count(delimiter) for i in filecontent]) + 1
      dimx = max([len(i.split(delimiter)) for i in filecontent])

      # turn off multiple sheet option
      self.parent.resetSheetSpinBox(currVal=1, maxVal=1, currName='')
      
      # populate the table
      maxNumberItems = 0
      self.sheetData = []
      for row in filecontent:
        splitline = row.split(delimiter)
        splitline = [float(i) if self.isNumber(i) else i for i in splitline]
        self.sheetData.append(splitline)
        maxNumberItems = np.max((maxNumberItems, len(splitline)))
      
      # fill sheetData with empty cells to make square (otherwise will have problems in TableModel)
      for entry in self.sheetData:
        while(len(entry) < maxNumberItems):
          entry.append('')

      # transpose data?
      if((transpose) and (len(self.sheetData))):
        transposedData = []
        for entry1 in range(len(self.sheetData[0])):
          row = []
          for entry2 in range(len(self.sheetData)):
            row.append(self.sheetData[entry2][entry1])
          transposedData.append(row)
        self.sheetData = transposedData
        dimx, dimy = dimy, dimx

      self.tableModel = DataTableModel(self.sheetData, self)
      self.setModel(self.tableModel)

      # configure table
      self.configTable(dimx, dimy)

    QtWidgets.QApplication.restoreOverrideCursor()

  def sortitsch(self, position):
    # allows sorting by column
    col = self.horizontalHeader().logicalIndexAt(position)
    
    # open context menu
    self.menu = MuhMenu(self)
    self.menu.setTitle('Sort by column ' + str(col + 1))
    
    for index, entry in enumerate(['sort ascending', 'sort descending']):
      action = QtWidgets.QAction(entry, self)
      action.triggered.connect(partial(self.sortitschHelper, col, index==1))
      self.menu.addAction(action)
      
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)
      
    # display menu at current column
    menuX, menuY = self.horizontalHeader().sectionViewportPosition(col) + self.verticalHeader().width(), self.horizontalHeader().height()
    menuPos = self.mapToGlobal(QtCore.QPoint(menuX, menuY))
    self.menu.popup(menuPos)

  def sortitschHelper(self, col, mode):
    # helper function for sort routine
    def mixedSort(col, alist, blist):
      # first analyze types
      a, b = alist[col], blist[col]
      #a, b = alist, blist
      if(type(a) == type(b)):
        return (a > b) - (a < b)
        #return cmp(a, b)
      else:
        if(type(a) == type(1.0)):
          return -1
        elif(type(b) == type(1.0)):
          return 1
        else:
          return 0

    # code continues -- generate sorted data
    currData = self.tableModel.getAllData()
    self.sheetData = sorted(currData, key=cmp_to_key(partial(mixedSort, col)))
    if(mode):
      self.sheetData = list(reversed(self.sheetData))
      
    # update table
    self.tableModel = DataTableModel(self.sheetData, self)
    self.setModel(self.tableModel)

    # configure table
    dimx, dimy = len(self.sheetData[0]), len(self.sheetData)
    self.configTable(dimx, dimy, retainRoles=True)

  def changeRole(self, col):
    # first check whether control button pressed -- if so, redirect to column transformations
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    if(modifiers & QtCore.Qt.ControlModifier):
      self.transformColumn(col)
    else:
      # open context menu to assign roles
      options = ['x', 'xerr', 'y', 'yerr', 'labels']
      self.menu = MuhMenu(self)
      self.menu.setTitle('Assign role')
      
      for entry in options:
        action = QtWidgets.QAction(self.rolestr[entry], self)
        action.triggered.connect(partial(self.changeRoleHelper, col, entry))
        self.menu.addAction(action)
        
      action = QtWidgets.QAction('none', self)
      action.triggered.connect(partial(self.clear_role, col))
      self.menu.addAction(action)
  
      # apply styles to popup window
      if(QSTYLE != None):
        self.menu.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.menu.setStyleSheet(QSTYLESHEET)
        
      # display menu at current column
      menuX, menuY = self.horizontalHeader().sectionViewportPosition(col) + self.verticalHeader().width(), self.horizontalHeader().height()
      menuPos = self.mapToGlobal(QtCore.QPoint(menuX, menuY))
      self.menu.popup(menuPos)
  
  def changeRoleHelper(self, col, role):
    # actually assigns the new role
    # did this column have any role assigned?
    for key in self.roles:
      if(self.roles[key] == col):
        self.roles[key] = -1
    
    # is the new role already taken?
    if (self.roles[role] + 1):
      # reset old label
      self.tableModel.setSingleHeader(self.roles[role], str(self.roles[role] + 1))
      
    # assign new role
    self.roles[role] = col
    self.tableModel.setSingleHeader(col, str(col + 1) + ' (' + self.rolestr[role] + ')')
    self.tableModel.layoutChanged.emit()
    
    # trigger data update
    self.parent.updateData(docheck = True)

  def clear_role(self, col):
    # unassigns role of column
    # did this column have any role assigned?
    for key in self.roles:
      if(self.roles[key] == col):
        self.roles[key] = -1
        
    # reset label
    self.tableModel.setSingleHeader(col, str(col + 1))
    self.tableModel.layoutChanged.emit()

    # trigger data update
    self.parent.updateData(docheck = True)

  def transformColumn(self, col):
    # opens context menu to allow transformation of column contents
    self.menu = TransformerMenu(self, col, self.storeFormula)
    self.menu.setTitle('Transform column')
    
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)
      
    # display menu at current column
    menuX, menuY = self.horizontalHeader().sectionViewportPosition(col) + self.verticalHeader().width(), self.horizontalHeader().height()
    menuPos = self.mapToGlobal(QtCore.QPoint(menuX, menuY))
    self.menu.popup(menuPos)
    
  def doTransformer(self, col, formula):
    # performs the actual column transformation
    targetCol = col
    if(formula == 'C' + str(col)):
      self.storeFormula = ''
    else:
      self.storeFormula = formula
    
    # analyze formula to determine which columns to use
    useCol = []
    for col in range(self.tableModel.columnCount()):
      probeCol = 'C' + str(col + 1)
      # check for presence of probeCol in formula
      if(probeCol in formula):
        flag = False
        splitty = formula.split(probeCol)
        for entry in splitty[1:]:
          # next character in formula string is not a number
          if((entry == '') or (not entry[0].isdigit())):
            flag = True
        if(flag):
          useCol.append(col)
          
    # analyze whether we should use row
    useRow = False
    if('ROW' in formula):
      useRow = True
    
    # define transformer function
    try:
      # check whether we have at least one input column
      if(len(useCol)):
        funcstr = 'def transformThis(self, inputs'
        if(useRow):
          funcstr += ', ROW):'
        else:
          funcstr += '):'
        for index, entry in enumerate(useCol):
          funcstr += '\n\tC' + str(entry + 1) + ' = inputs[:, ' + str(index) + ']'
        funcstr += '\n\toutput = ' + formula + '\n\treturn output'
      else:
        funcstr = 'def transformThis(self, zeroInput'
        if(useRow):
          funcstr += ', ROW):'
        else:
          funcstr += '):'
        funcstr += '\n\toutput = zeroInput + ' + formula + '\n\treturn output'
        
      # generate ffunc in local namespace (this is needed for Python3 vs. Python2, bummer)
      namespace = self.mySpace
      exec(funcstr, namespace)
      # now define the new function in the object scope
      setattr(DataTable, 'transformThis', namespace['transformThis'])
    except:
      self.parent.parent.statusbar.showMessage('Error when setting transformation for column ' + str(targetCol), self.parent.parent.STATUS_TIME)
    else:
      # do the actual transform
      # do some reporting
      goodRows, badRows = [], []
        
      # determine selected rows
      selind = self.selectionModel().selectedRows()
      selind = sorted([i.row() for i in selind])
      if (len(selind)):
        # get all selected data rows
        selectedData = self.tableModel.getDataRows(selind)
        
        # reduce data to columns we are interested in
        for index, entry in enumerate(selectedData):
          selectedData[index] = [entry[i] for i in useCol]
        
        # process data to weed out problematic rows
        prunedData, prunedIndices = [], []
        for index, row in enumerate(selectedData):
          # only process rows where all required cells are numeric
          checkRow = [0 if(type(i) in [float, int]) else 1 for i in row]
          if(sum(checkRow) == 0):
            prunedData.append(row)
            prunedIndices.append(selind[index])
          else:
            badRows.append(selind[index])
        
        # do the concrete transform
        if(len(prunedData)):
          prunedData = np.array(prunedData)
          try:
            # check whether we have at least one input column
            if(len(useCol)):
              if(useRow):
                ROW = np.array(prunedIndices) + 1
                transCol = self.transformThis(prunedData, ROW=ROW)
              else:
                transCol = self.transformThis(prunedData)
            else:
              zeroInput = np.array([0] * len(prunedIndices))
              if(useRow):
                ROW = np.array(prunedIndices) + 1
                transCol = self.transformThis(zeroInput, ROW=ROW)
              else:
                transCol = self.transformThis(zeroInput)
          except:
            self.parent.parent.statusbar.showMessage('Error when applying transformation for column ' + str(targetCol), self.parent.parent.STATUS_TIME)
          else:
            # everything has worked, so assign transformed values to data table
            for index, value in enumerate(transCol):
              if((not np.isnan(value)) and (not np.isinf(value))):
                self.tableModel.setData(float(value), prunedIndices[index], targetCol)
                goodRows.append(prunedIndices[index])
              else:
                self.tableModel.setData('', prunedIndices[index], targetCol)
                badRows.append(prunedIndices[index])
              # refresh table view
              cellIndex = self.tableModel.index(prunedIndices[index], targetCol)
              self.tableModel.dataChanged.emit(cellIndex, cellIndex, [QtCore.Qt.DisplayRole])

        self.tableModel.setGoodBad(goodRows=goodRows, badRows=badRows, selCols=[targetCol])

  def hasComma(self):
    # cycles through selected cells and checks for presence of comma
    selind = self.selectionModel().selectedIndexes()
    retv = False
    index = 0
    while((not retv) and (index < len(selind))):
      if((type(selind[index].data()) == str) and (',' in selind[index].data())):
        retv = True
      index += 1

    return retv
    
  def getData(self, needXErr=True, needYErr=True):
    # returns selected data as numpy array
    # determine selected rows
    selind = self.selectionModel().selectedRows()
    selind = sorted([i.row() for i in selind])
     
    # retrieve data from table
    retv = []; roles = []
    # check whether at least x and y assigned
    if (((self.roles['x']+1) or (self.roles['labels']+1)) and (self.roles['y']+1)):
      if (len(selind)):
        # get all selected data rows
        selectedData = self.tableModel.getDataRows(selind)

        # deal with labels separately to allow non-numerical entries here
        if(self.roles['labels'] > -1):
          selectedLabels = []
          index = self.roles['labels']
          for entry in selectedData:
            selectedLabels.append(entry[index])
        
        # reduce data to columns we are interested in
        activeKeys = ['x', 'xerr', 'y', 'yerr']
        if(not needXErr):
          activeKeys.pop(activeKeys.index('xerr'))
        if(not needYErr):
          activeKeys.pop(activeKeys.index('yerr'))
        activeKeys = [key for key in activeKeys if (self.roles[key] > -1)]
        indices = [self.roles[key] for key in activeKeys]
        for index, entry in enumerate(selectedData):
          selectedData[index] = [entry[i] for i in indices]
        
        # do some reporting
        goodRows, badRows = [], []
        
        # prepare list for numpy array
        prunedData = []; no_items = len(activeKeys)
        for index, row in enumerate(selectedData):
          types = [1 if type(i) in [int, float] else 0 for i in row]
          if(np.sum(types) == no_items):
            # only numerical entries on row
            if(self.roles['labels'] > -1):
              row.append(selectedLabels[index])
            prunedData.append(row)
            goodRows.append(selind[index])
          elif(np.sum(types) > 0):
            # at least one numerical entry on row
            lengths = [len(i) for index, i in enumerate(row) if(not types[index])]
            if(np.sum(lengths) == 0):
              # all other cells empty => replace by zero
              row = [i if types[index] else 0.0 for index, i in enumerate(row)]
              if(self.roles['labels'] > -1):
                row.append(selectedLabels[index])
              prunedData.append(row)
              goodRows.append(selind[index])
            else:
              badRows.append(selind[index])
          else:
            # check for completely empty row
            lengths = [len(i) for index, i in enumerate(row) if(not types[index])]
            if(np.sum(lengths) != 0):
              # only spaces in line
              badRows.append(selind[index])
              
        # color table temporarily
        useKeys = ['x', 'xerr', 'y', 'yerr', 'labels']
        if(self.parent.errorModel):
          useKeys.remove('yerr')
        if(self.parent.errorXModel):
          useKeys.remove('xerr')
        selCols = [self.roles[key] for key in useKeys if (self.roles[key] > -1)]
        self.tableModel.setGoodBad(goodRows=goodRows, badRows=badRows, selCols=selCols)
        
        # convert nested list to numpy array
        retv = prunedData
        roles = activeKeys
        if(self.roles['labels'] > -1):
          roles.append('labels')
    
        # sort data by ascending x values
        #if(len(retv)):
          # will sort according to first entry w/in nested list which should be 'x'
        #  retv = sorted(retv)
        # turned off this feature as it causes problems for cyclic data (e.g., voltammetry)
    return retv, roles

  def keyPressEvent(self, event):
    if event.matches(QtGui.QKeySequence.Copy):
      # prepare output
      selind = self.selectionModel().selectedRows()
      selind = sorted([i.row() for i in selind])      
      # get data
      selectedData = self.tableModel.getDataRows(selind)
      output = []
      for row in selectedData:
        row = [str(i) for i in row]
        output.append('\t'.join(row))
      output = '\n'.join(output)
      clipboard = QtWidgets.QApplication.clipboard()
      clipboard.setText(output)
    elif event.matches(QtGui.QKeySequence.Paste):
      clipboard = QtWidgets.QApplication.clipboard()
      clipMime = clipboard.mimeData()
      # check wether clip object contains text
      if(clipMime.hasText()):
        clipContent = clipboard.text()
        self.pasteText(pastedText=clipContent)
    elif event.matches(QtGui.QKeySequence.SelectAll):
      self.selectAll()
    elif(event.key() == QtCore.Qt.Key_Down):
      if(self.currentRow < self.tableModel.rowCount() - 1):
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          self.clearSelection()
        self.currentRow += 1
        self.selectTo(self.currentRow, self.currentRow)
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() == QtCore.Qt.Key_Up):
      if(self.currentRow > 0):
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          self.clearSelection()
        self.currentRow -= 1
        self.selectTo(self.currentRow, self.currentRow)
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() == QtCore.Qt.Key_PageDown):
      if(self.currentRow < self.tableModel.rowCount() - 1):
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          self.clearSelection()
        origRow = self.currentRow
        self.currentRow += self.pageStep
        self.currentRow = min(self.currentRow, self.tableModel.rowCount() - 1)
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          origRow = self.currentRow
        self.selectTo(origRow, self.currentRow)
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() == QtCore.Qt.Key_PageUp):
      if(self.currentRow > 0):
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          self.clearSelection()
        origRow = self.currentRow
        self.currentRow -= self.pageStep
        self.currentRow = max(self.currentRow, 0)
        if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
          origRow = self.currentRow
        self.selectTo(origRow, self.currentRow)
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Right]):
      # ignore event such that we can capture the left/right keys
      event.ignore()
      flag = False
      if(event.key() == QtCore.Qt.Key_Left):
        if(self.currentCol > 0):
          self.currentCol -= 1
          flag = True
      elif(self.currentCol < self.tableModel.columnCount() - 1):
        self.currentCol += 1
        flag = True
      if(flag):
        nuIndex = self.model().index(self.currentRow, self.currentCol)
        self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() in [QtCore.Qt.Key_Home, QtCore.Qt.Key_End]):
      if(event.modifiers() & QtCore.Qt.ControlModifier):
        flag = False
        if(event.key() == QtCore.Qt.Key_Home):
          if(self.currentRow > 0):
            origRow = self.currentRow
            self.currentRow = 0
            flag = True
        elif(self.currentRow < self.tableModel.rowCount() - 1):
          origRow = self.currentRow
          self.currentRow = self.tableModel.rowCount() - 1
          flag = True
        if(flag):
          if(not (event.modifiers() & QtCore.Qt.ShiftModifier)):
            self.clearSelection()
            origRow = self.currentRow
          self.selectTo(origRow, self.currentRow)
          nuIndex = self.model().index(self.currentRow, self.currentCol)
          self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
      else:
        flag = False
        if(event.key() == QtCore.Qt.Key_Home):
          if(self.currentCol > 0):
            self.currentCol = 0
            flag = True
        elif(self.currentCol < self.tableModel.columnCount() - 1):
          self.currentCol = self.tableModel.columnCount() - 1
          flag = True
        if(flag):
          nuIndex = self.model().index(self.currentRow, self.currentCol)
          self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() in [QtCore.Qt.Key_Tab, QtCore.Qt.Key_Backtab]):
      # advance cell on tab
      if(event.key() == QtCore.Qt.Key_Backtab):
        self.currentCol -= 1
        if(self.currentCol < 0):
          if(self.currentRow > 0):
            self.currentRow -= 1
            self.currentCol = self.tableModel.columnCount() - 1
          else:
            self.currentCol = 0
      else:
        self.currentCol += 1
        if(self.currentCol >= self.tableModel.columnCount()):
          if(self.currentRow < self.tableModel.rowCount() - 1):
            self.currentRow += 1
            self.currentCol = 0
          else:
            self.currentCol = self.tableModel.columnCount() - 1
      self.clearSelection()
      self.selectTo(self.currentRow, self.currentRow)
      nuIndex = self.model().index(self.currentRow, self.currentCol)
      self.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)
    elif(event.key() in [QtCore.Qt.Key_Backspace, QtCore.Qt.Key_Delete]):
      # clear current cell
      self.tableModel.setData('', self.currentRow, self.currentCol)
      # refresh table view
      cellIndex = self.tableModel.index(self.currentRow, self.currentCol)
      self.tableModel.dataChanged.emit(cellIndex, cellIndex, [QtCore.Qt.DisplayRole])
    elif (event.matches(QtGui.QKeySequence.Save) or event.matches(QtGui.QKeySequence.Open) or event.matches(QtGui.QKeySequence.HelpContents)\
          or event.matches(QtGui.QKeySequence.Print) or event.matches(QtGui.QKeySequence.Quit) or event.matches(QtGui.QKeySequence.Italic)\
          or event.matches(QtGui.QKeySequence.ZoomIn) or event.matches(QtGui.QKeySequence.ZoomOut) or event.matches(QtGui.QKeySequence.Find)\
          or event.matches(QtGui.QKeySequence.New) or event.matches(QtGui.QKeySequence.Refresh) or event.matches(QtGui.QKeySequence.FindNext)):
      # pass event to main ui
      event.ignore()
    elif(not (event.key() in [QtCore.Qt.Key_Escape])):
      openDialog = False
      if(event.key() in [QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return]):
        openDialog = True
        initialEdit = ''
      elif(len(event.text())):
        openDialog = True
        initialEdit = event.text()
      if(openDialog):
        # ensure that cell is visible
        indexAt = self.model().index(self.currentRow, self.currentCol)
        self.scrollTo(indexAt)
        # open edit QMenu at cell position
        rowViewport, colViewport = self.rowViewportPosition(self.currentRow), self.columnViewportPosition(self.currentCol) + self.verticalHeader().width()
        menuPos = self.mapToGlobal(QtCore.QPoint(colViewport, rowViewport))
        self.menu = EditDataMenu(parent=self, tableModel=self.tableModel, indexAt=indexAt, initialEdit=initialEdit)
        # apply styles to popup window
        if(QSTYLE != None):
          self.menu.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          self.menu.setStyleSheet(QSTYLESHEET)
        self.menu.popup(menuPos)    

  def selectTo(self, startRow=0, endRow=0):
    # selects target rows
    lowRow, hiRow = min(startRow, endRow), max(startRow, endRow)
    columnCount = self.tableModel.columnCount()
    
    topLeft = self.model().index(lowRow, 0)
    bottomRight = self.model().index(hiRow, columnCount - 1)
    itemSelection = QtCore.QItemSelection(topLeft, bottomRight)
    self.selectionModel().select(itemSelection, QtCore.QItemSelectionModel.Select)

  def pasteText(self, pastedText=''):
    # store target cell
    offsetRow, offsetColumn = self.currentRow, self.currentCol
    # determine size of text to be pasted
    clipRows = pastedText.split('\n')
    clipCols = [i.split('\t') for i in clipRows]
    clipColCount = [len(i) for i in clipCols]
    # determine new data sheet dimensions
    nuRowCount, nuColCount = len(clipRows), max(clipColCount)
    # check for trailing all-empty columns which we won't copy
    index = nuColCount - 1
    trailCol = nuColCount
    while(index >= 0):
      for entry in clipCols:
        if(0 < index < len(entry)):
          if(len(entry[index])):
            trailCol = index + 1
            index = -1
      index -= 1
    # make clipped text square and truncate after trailCol
    clipCols = [i + ([''] * nuColCount) for i in clipCols]
    clipCols = [i[:trailCol] for i in clipCols]
    # convert to number where possible
    clipCols = [[float(j) if self.isNumber(j) else j for j in i] for i in clipCols]
    # prepare pasting of text -- resize if needed
    dimy, dimx = self.tableModel.rowCount(), self.tableModel.columnCount()
    if(((offsetColumn + trailCol) > dimx) or ((offsetRow + nuRowCount) > dimy)):
      # store current data
      currData = self.tableModel.getAllData()
      # blank data
      dimx, dimy = max(dimx, offsetColumn + trailCol), max(dimy, offsetRow + nuRowCount)
      blankData = [[''] * dimx for i in range(dimy)]
      self.tableModel = DataTableModel(blankData, self)
      self.setModel(self.tableModel)
      # restore original data
      self.tableModel.pasteDataBlock(data=currData, offsetRow=0, offsetColumn=0)
    
    # paste new data
    self.tableModel.pasteDataBlock(data=clipCols, offsetRow=offsetRow, offsetColumn=offsetColumn)
    self.configTable(offsetColumn + trailCol, offsetRow + nuRowCount, retainRoles=True, retainSelection=True)
    self.tableModel.layoutChanged.emit()
    
    # update self.sheetData as well
    self.sheetData = self.tableModel.getAllData()
    
  def mouseDoubleClickEvent(self, event):
    # allow editing of cell on double click
    # perform original event
    QtWidgets.QTableView.mouseDoubleClickEvent(self, event)
    
    # determine indices of clicked cell and scroll to ensure visibility
    indexAt = self.indexAt(event.pos())
    self.scrollTo(indexAt)
    row, col = indexAt.row(), indexAt.column()
    rowViewport, colViewport = self.rowViewportPosition(row), self.columnViewportPosition(col)
    
    # open edit QMenu at cell position
    menuPos = self.mapToGlobal(QtCore.QPoint(colViewport + self.verticalHeader().width(), rowViewport))

    self.menu = EditDataMenu(parent=self, tableModel=self.tableModel, indexAt=indexAt)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)
    self.menu.popup(menuPos)    

  def currentCellChanged(self, current):
    # keeps tabs on current cell
    self.currentRow, self.currentCol = current.row(), current.column()

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False

# subclass edit to better capture key presses
class EditDataEdit(QtWidgets.QLineEdit):
  def __init__(self, parent=None):
    super(EditDataEdit, self).__init__(parent)
    self.parent = parent
  
  def keyPressEvent(self, event):
    # ignore alt keys as they would close the QMenu
    if(event.key() in [QtCore.Qt.Key_Alt, QtCore.Qt.Key_AltGr]):
      return

    # capture enter and arrow keys
    if(event.key() in [QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter]):
      if(event.modifiers() & QtCore.Qt.ShiftModifier):
        self.parent.advanceCell(-1, 0)
      else:
        self.parent.advanceCell(1, 0)
    elif(event.key() == QtCore.Qt.Key_Up):
      self.parent.advanceCell(-1, 0)
    elif(event.key() == QtCore.Qt.Key_Down):
      self.parent.advanceCell(1, 0)
    elif(event.key() == QtCore.Qt.Key_Left):
      if((event.modifiers() & QtCore.Qt.ControlModifier) or (self.cursorPosition() == 0)):
        self.parent.advanceCell(0, -1)
        return
    elif(event.key() == QtCore.Qt.Key_Right):
      if((event.modifiers() & QtCore.Qt.ControlModifier) or (self.cursorPosition() == len(self.text()))):
        self.parent.advanceCell(0, 1)
        return
      
    # normal event processing
    QtWidgets.QLineEdit.keyPressEvent(self, event)

class EditDataMenu(KuhMenu):
  def __init__(self, parent=None, tableModel=None, indexAt=None, initialEdit=''):
    super(EditDataMenu, self).__init__()
    if(None in [parent, tableModel, indexAt]):
      self.close()
    
    self.parent = parent
    self.tableModel = tableModel
    self.maxRow, self.maxCol = self.tableModel.rowCount(), self.tableModel.columnCount()
    self.indexAt = indexAt
    self.row, self.col = self.indexAt.row(), self.indexAt.column()
    self.minWidth = scaledDPI(100)
    self.finalUpdate = True
      
    # set up GUI
    self.buildRessource()
    
    # set QMenu position
    self.adjustWindowPosition(initialEdit=initialEdit)

  def adjustWindowPosition(self, initialEdit=''):
    # update label
    labelText = 'Edit cell ' + str(self.col + 1) + '/' + str(self.row + 1)
    useFont = self.editDataLabel.font()
    useFont.setBold(True)
    self.editDataLabel.setFont(useFont)
    self.editDataLabel.setText(labelText)

    # update QlineEdit
    if(len(initialEdit)):
      self.initValue = ''
      self.editData.setText(initialEdit)
    else:
      self.initValue = self.tableModel.dataByIndices(self.row, self.col)
      self.editData.setText(str(self.initValue))

    self.editData.selectAll()
    self.editData.setFocus()

    # ensure that cell is visible
    cellIndex = self.tableModel.index(self.row, self.col)
    self.parent.scrollTo(cellIndex)
    
    # adjust width of edit window -- use min/max size as resize not properly heeded
    cellWidth = max(self.minWidth, self.parent.columnWidth(self.col))
    self.editData.setMaximumSize(QtCore.QSize(cellWidth, scaledDPI(BASE_SIZE)))
    self.editData.setMinimumSize(QtCore.QSize(cellWidth, scaledDPI(BASE_SIZE)))
    self.setMaximumWidth(cellWidth)
    self.setMinimumWidth(cellWidth)

    # adjusts window position to currently edited cell
    rowViewport = self.parent.rowViewportPosition(self.row)
    colViewport = self.parent.columnViewportPosition(self.col) + self.parent.verticalHeader().width()
    menuPos = self.parent.mapToGlobal(QtCore.QPoint(colViewport, rowViewport))
    self.move(menuPos)
    
    if(len(initialEdit)):
      self.editData.deselect()
      self.editData.setCursorPosition(1)

  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    # QlineEdit for data modification
    self.editDataLabel = QtWidgets.QLabel()
    self.vLayout.addWidget(self.editDataLabel)
    
    self.editData = EditDataEdit(self)
    self.vLayout.addWidget(self.editData)
    self.editData.setFocus()
    
  def updateData(self):
    # updates data table if required
    currValue = self.editData.text()
    if(currValue != self.initValue):
      try:
        currValue = float(currValue)
      except:
        pass
      self.parent.tableModel.setData(currValue, self.row, self.col)

      # refresh table view
      cellIndex = self.tableModel.index(self.row, self.col)
      self.tableModel.dataChanged.emit(cellIndex, cellIndex, [QtCore.Qt.DisplayRole])
      
  def keyPressEvent(self, event):
    # process tab keys and escape
    if(event.key() == QtCore.Qt.Key_Backtab):
      self.advanceCell(0, -1)
    elif(event.key() == QtCore.Qt.Key_Tab):
      self.advanceCell(0, 1)
    elif(event.key() == QtCore.Qt.Key_Escape):
      self.finalUpdate = False
      self.close()
      
  def advanceCell(self, deltaRow=0, deltaCol=0):
    # update previous data
    self.updateData()
    
    # move edit window to new position
    # adjust cell indices
    self.deltaRow, self.deltaCol = deltaRow, deltaCol
    
    # apply column shift
    self.col += self.deltaCol
    if(self.col >= self.maxCol):
      if(self.row < self.maxRow - 1):
        self.col = 0; self.row += 1
      else:
        self.col = self.maxCol - 1
    elif(self.col < 0):
      if(self.row > 0):
        self.col = self.maxCol - 1; self.row -= 1
      else:
        self.col = 0

    # apply row shift
    self.row += deltaRow
    self.row = max(self.row, 0)
    self.row = min(self.row, self.maxRow - 1)

    # set cursor in data table to currently edited cell
    self.parent.currentCol, self.parent.currentRow = self.col, self.row
    self.parent.clearSelection()
    self.parent.selectTo(self.row, self.row)
    nuIndex = self.parent.model().index(self.row, self.col)
    self.parent.selectionModel().setCurrentIndex(nuIndex, QtCore.QItemSelectionModel.Select)

    # move window
    self.adjustWindowPosition()
    
  def closeEvent(self, event):
    # perform final update
    if(self.finalUpdate):
      self.updateData()
    # perform original close event
    QtWidgets.QMenu.closeEvent(self, event)

class ResultsArea(QWidgetMac):
  def __init__(self, parent = None):
    super(ResultsArea, self).__init__()
    self.parent = parent
    self.rolestr = {'x':'x', 'y':'y', 'xerr':u'\N{GREEK CAPITAL LETTER DELTA}x', \
      'yerr':u'\N{GREEK CAPITAL LETTER DELTA}y', 'fit':'fit', 'resid':'resid'}
    self.descriptors = []
    self.buildRessource()
    
    # initialize filename
    self.currExportFile = None
    
  def buildRessource(self):
    # set up results table
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)

    # allow change of data set on display    
    self.dataSetBox = QWidgetMac()
    self.vLayout.addWidget(self.dataSetBox)
    self.dataSetLayout = QtWidgets.QHBoxLayout(self.dataSetBox)
    self.dataSetLayout.setContentsMargins(0, 0, 0, 0)
    self.dataSetLayout.setAlignment(QtCore.Qt.AlignLeft)

    self.dataSetLabel = QtWidgets.QLabel()
    useFont = self.dataSetLabel.font()
    useFont.setBold(True)
    self.dataSetLabel.setFont(useFont)
    self.dataSetLabel.setText('Data Set')
    self.dataSetLabel.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.dataSetLabel.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.dataSetLayout.addWidget(self.dataSetLabel)
    
    self.dataSetSpinBox = QtWidgets.QSpinBox()
    self.dataSetSpinBox.setAlignment(QtCore.Qt.AlignRight)
    self.dataSetSpinBox.setMinimum(1)
    self.dataSetSpinBox.setMaximum(1)
    self.dataSetSpinBox.setValue(1)
    self.dataSetSpinBox.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.dataSetSpinBox.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.dataSetSpinBox.valueChanged.connect(self.changeDataSet)
    self.dataSetSpinBox.setEnabled(False)
    self.dataSetLayout.addWidget(self.dataSetSpinBox)
    
    self.dataSetName = QtWidgets.QLabel()
    self.dataSetName.setText(self.parent.data[self.parent.activeData].name)
    self.dataSetLayout.addWidget(self.dataSetName)

    self.resultstable = QtWidgets.QTableView()
    self.resultstable.setObjectName('data')
    if(not (platform in ['linux', 'darwin'])):
      btn = self.resultstable.findChild(QtWidgets.QAbstractButton)
      btn.setToolTip('Click to select entire table')
    self.resultstable.setItemDelegate(FloatFormatDelegate())
    self.resultstable.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
    self.resultstable.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    self.vLayout.addWidget(self.resultstable)
    self.tableModel = None

    self.rowHeight = int(self.resultstable.fontMetrics().height() + scaledDPI(2))
    vheader = self.resultstable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)

    self.exportButton = QPushButtonMac()
    self.exportButton.setText('Export Results')
    self.exportButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.exportButton.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.exportButton.clicked.connect(self.exportWrapper)
    self.vLayout.addWidget(self.exportButton)

  def exportWrapper(self, modeHTMLOnly=False):
    # writes results to output file
    global REMEMBERDIR
    if(modeHTMLOnly):
      filter_options = ['HTML Files (*.html)']
    else:
      filter_options = ['HTML Files (*.html)','Excel Files (*.xlsx)']
    filterstring = ';;'.join(filter_options)
    usedir = REMEMBERDIR
    if(self.currExportFile != None):
      usedir = self.currExportFile
    if(modeHTMLOnly):
      caption = 'Compile Report'
    else:
      caption = 'Export Results'
    filename, filter_ = QtWidgets.QFileDialog.getSaveFileName(self, filter=filterstring, directory=usedir, caption=caption)
    filename = str(filename)
    if(PATH_SEPARATOR in filename):
      REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    elif('/' in filename):
      REMEMBERDIR = filename.split('/')[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    if(len(filename) > 0):
      mode = filter_options.index(filter_)
      if(modeHTMLOnly or (mode == 0)):
        self.writeHTML(filename=filename)
      elif(mode == 1):
        self.writeXLS(filename=filename)

  def writeHTML(self, filename=None):
    # writes Results table to HTML file
    if(filename != None):
      # set SVG export to path to ensure correct display in browser
      prevSVGSetting = None
      if('svg.fonttype' in matplotlib.rcParams):
        prevSVGSetting = matplotlib.rcParams['svg.fonttype']
      matplotlib.rcParams.update({'svg.fonttype': 'path'})
      # save current figure temporarily under new filename
      if(self.parent.plotArea.figureFill):
        useFaceColor = self.parent.plotArea.figureColor
      else:
        useFaceColor = 'none'
      if(self.parent.plotArea.frameDraw):
        useFrameColor = self.parent.plotArea.frameColor
      else:
        useFrameColor = 'none'
      try:
        self.parent.plotArea.matplot.savefig(filename, format='svg', dpi=600, facecolor=useFaceColor, edgecolor=useFrameColor)
        flag = True
      except:
        flag = False
      # store contents of SVG file in memory
      if(flag):
        readhandle = open(filename, 'r')
        svg_plot = readhandle.readlines()
        readhandle.close()
      else:
        svg_plot = []
      
      # save current residuals temporarily under new filename
      try:
        self.parent.plotArea.residplot.savefig(filename, format='svg', dpi=600, facecolor=useFaceColor, edgecolor=useFrameColor)
        flag2 = True
      except:
        flag2 = False

      # store contents of SVG file in memory
      if(flag2):
        readhandle = open(filename, 'r')
        svg_resid = readhandle.readlines()
        readhandle.close()
      else:
        svg_resid = []

      # restore SVG export setting to previous value
      if(prevSVGSetting != None):
        matplotlib.rcParams.update({'svg.fonttype': prevSVGSetting})
        
      # generate actual HTML file
      writehandle = open(filename, 'w', encoding='utf-8')
      
      if(writehandle):
        # write header
        writehandle.write('<html xmlns="http://www.w3.org/1999/xhtml">\n<head>\n')
        writehandle.write('<title>Fit-o-mat Results</title>\n')
        writehandle.write('<meta charset="UTF-8">\n')
        writehandle.write('<meta author="Moeglich laboratory, University of Bayreuth">\n')
        writehandle.write('<meta description="Fit-o-mat Fit Results">\n')
        writehandle.write('</head>\n<body>\n')
        
        writehandle.write('<h2>Fit-o-mat Results</h2>\n')
        writehandle.write(asctime() + '\n')
        # check whether current fit results are available
        if(self.parent.lastFitType != 'none'):
          # write heading and div
          writehandle.write('<div style="padding: 5px;">\n')
          writehandle.write('<a href="javascript:;" onclick="togglitsch(\'results\')" class="toggle">\n')
          writehandle.write('<h3 id="results_ctrl">&#9744; Fit Results</h3>\n')
          writehandle.write('</a>\n')
          writehandle.write('<div id="results" style="display:none;">\n')
          writehandle.write('<button id="results_button" class="little">Copy Results</button>\n')
          writehandle.write('<div id="results_content">\n')
          # further check whether these are local or global results
          if(self.parent.lastFitType == 'local'):
            fitresults = self.parent.fitarea.outstring.splitlines()
          else:
            fitresults = self.parent.globalarea.globalOutstring.splitlines()
            writehandle.write('Global Fit:<br/>\n')
          for index, entry in enumerate(fitresults[2:]):
            writehandle.write(entry + '<br/>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')
        else:
          pass
            
        writehandle.write('<div class="container">\n')

        # write graphics
        if(flag or flag2):
          writehandle.write('<div class="flexmatic2">\n')
          writehandle.write('<a href="javascript:;" onclick="togglitsch(\'plot\')" class="toggle">\n')
          writehandle.write('<h3 id="plot_ctrl">&#9746; Plot and Residuals</h3>\n')
          writehandle.write('</a>\n')
          writehandle.write('<div id="plot" style="display:block;">\n')
          writehandle.write('<button id="plot_button" class="little">Copy Plots</button>\n')
          writehandle.write('<div id="plot_content">\n')
          max_width = 0
  
          # write plot figure if available
          if(flag):
            output = False
            for entry in svg_plot:
              if('<svg' in entry):
                output = True
                # extract width of SVG item
                if('width' in entry):
                  red = entry.split('width')[1]
                  max_width = red.split('"')[1]
              if(output):
                writehandle.write(entry)
              if('</svg' in entry):
                output = False
              
          # write residuals figure if available
          if(flag2):
            output = False
            for entry in svg_resid:
              if('<svg' in entry):
                output = True
              if(output):
                writehandle.write(entry)
              if('</svg' in entry):
                output = False
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')

        # write parameters
        writehandle.write('<div class="flexmatic">\n')
        writehandle.write('<a href="javascript:;" onclick="togglitsch(\'param\')" class="toggle">\n')
        writehandle.write('<h3 id="param_ctrl">&#9746; Parameter Values</h3>\n')
        writehandle.write('</a>\n')
        writehandle.write('<div id="param" style="display:block;">\n')
        writehandle.write('<button id="param_button" class="little">Copy Parameters</button>\n')
        writehandle.write('<div id="param_content">\n')

        # function to write parameter values and statistics for one curve
        def writeParamTable(paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq):
          writehandle.write('<table class="param">\n<thead>\n<tr>\n')
          writehandle.write('<th>Name</th>\n<th>Value</th>\n<th>Confidence</th>\n<th>Conf. <i>a priori</i></th>\n')
          writehandle.write('</tr>\n</thead>\n')
  
          writehandle.write('<tbody>\n')
          for i, j, k, l, m in zip(paramList, param, confidence, confidence_apriori, param_active):
            if(i == paramList[-1]):
              writehandle.write('<tr class="last">\n')
            else:
              writehandle.write('<tr>\n')
            writehandle.write('<td>' + str(i) + '</td>\n')
            if(m):
              tdString = '<td class="rite">'
            else:
              tdString = '<td class="rite fixed">'
            writehandle.write(tdString + self.parent.formatNumber(j) + '</td>\n')
            writehandle.write(tdString + self.parent.formatNumber(k) + '</td>\n')
            writehandle.write(tdString + self.parent.formatNumber(l) + '</td>\n')
            writehandle.write('</tr>\n')
          writehandle.write('</tbody>\n</table>\n')
          if(1):
          ###if(self.parent.lastFitType != 'none'):
            try:
              useChi = self.parent.formatNumber(chisq)
            except:
              useChi = str(chisq)
            writehandle.write('<i>&#x1D6D8;</i><sup>2</sup> = ' + useChi + '\n')
            try:
              useRedChi = self.parent.formatNumber(redchisq)
            except:
              useRedChi = str(redchisq)
            writehandle.write('<br/>reduced <i>&#x1D6D8;</i><sup>2</sup> = ' + useRedChi + '\n')

        # check whether last fit local or global
        if(self.parent.lastFitType != 'global'):
          for index, entry in enumerate(self.parent.fit):
            if(entry.visibility):
              tempLineString = '<span style=\'color:rgb(' + ', '.join([str(i * 255) for i in entry.style['color'][0:3]]) + ');\nfont-size:150%;\'>--</span>'
              writehandle.write('<h4>' + tempLineString + ' ' + str(index) + ' -- '  + entry.name + '</h4>\n')
              paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq = entry.retrieveInfoReport()
              writeParamTable(paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq)
              writehandle.write('<br/>\n')
        else:
          writehandle.write('<h4>Global fit</h4>\n')
          paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq = self.parent.globalarea.reportGlobalParam()
          writeParamTable(paramList, param_active, param, confidence, confidence_apriori, chisq, redchisq)

        writehandle.write('</div>\n')
        writehandle.write('</div>\n')
        writehandle.write('</div>\n')

        # write data
        dataFlag = False
        if((self.tableModel != None) and (self.tableModel.columnCount() > 0)):
          dataFlag = True
          writehandle.write('<div class="flexmatic">\n')
          writehandle.write('<a href="javascript:;" onclick="togglitsch(\'data\')" class="toggle">\n')
          writehandle.write('<h3 id="data_ctrl">&#9744; Data and Fitted Values</h3>\n')
          writehandle.write('</a>\n')
          writehandle.write('<div id="data" style="display:none;">\n')
          writehandle.write('<button id="data_button" class="little">Copy Data</button>\n')
          writehandle.write('<div id="data_content">\n')
          writehandle.write('<table>\n<thead>\n<tr>\n')
          for header in self.tableModel.getHeaders():
            writehandle.write('<th>' + str(header) + '</th>\n')
          writehandle.write('</tr>\n</thead>\n')
          # write data table
          writehandle.write('<tbody>\n')
          resultsData = self.tableModel.getAllData()
          for row in resultsData:
            writehandle.write('<tr>\n')
            row = [self.parent.formatNumber(i) for i in row]
            rowstring = '</td><td>'.join(row)
            writehandle.write('<td>' + rowstring + '</td>')
            writehandle.write('\n</tr>\n')

          writehandle.write('</tbody>\n</table>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')
          writehandle.write('</div>\n')

        # write simulated data as well
        simX, simY = self.parent.fit[self.parent.activeFit].x, self.parent.fit[self.parent.activeFit].y
        writehandle.write('<div class="flexmatic">\n')
        writehandle.write('<a href="javascript:;" onclick="togglitsch(\'fxn\')" class="toggle">\n')
        writehandle.write('<h3 id="fxn_ctrl">&#9744; Simulated Curve</h3>\n')
        writehandle.write('</a>\n')
        writehandle.write('<div id="fxn" style="display:none;">\n')
        writehandle.write('<button id="fxn_button" class="little">Copy Curve</button>\n')
        writehandle.write('<div id="fxn_content">\n')
        writehandle.write('<table>\n<thead>\n<tr>\n')
        writehandle.write('<th>x</th>\n<th>f(x)</th>\n')
        writehandle.write('<tbody>\n')
        for row in range(len(simX)):
          writehandle.write('<tr>\n')
          writehandle.write('<td>' + self.parent.formatNumber(simX[row]) + '</td>')
          writehandle.write('<td>' + self.parent.formatNumber(simY[row]) + '</td>')
          writehandle.write('\n</tr>\n')
        writehandle.write('</tbody>\n</table>\n')
        writehandle.write('</div>\n')
        writehandle.write('</div>\n')
        writehandle.write('</div>\n')

        writehandle.write('</div>\n')
        writehandle.write('<div class="disclaimer">generated by fit-o-mat v' + VERSION + ' by AM lab</div>\n')

        # add style definitions
        writehandle.write('</body>\n')
        writehandle.write('<style type="text/css">\n')
        writehandle.write('.container {\npadding: 0;\nmargin: 0;\ndisplay: flex;\nflex-direction: row;\
          \nalign-items: flex-start;\n}\n')
        writehandle.write('.flexmatic {\npadding: 5px;\nmargin: 0;\nflex: 0 0 auto;\n}\n')
        writehandle.write('.flexmatic2 {\npadding: 5px;\nmargin: 0;\nflex: 1 1 auto;\n')
        if(max_width != 0):
          writehandle.write('max-width: ' + max_width + ';\n')
        writehandle.write('min-width: 200pt;\n}\n')
        writehandle.write('svg {\nwidth: 100%;\nheight: 100%;\n}\n')
        writehandle.write('h3 {\ntext-align: left;\nwhite-space: nowrap;\n}\n')
        writehandle.write('.disclaimer {\nposition: fixed;\nbottom: 0px;\nright: 0px;\nfont-size: 125%;\
                                        \ncolor: #333333;\nbackground-color: rgba(255, 255, 255, 0.5);\
                                        \nborder: 1px;\nborder-style: solid;\nborder-radius: 2px;\
                                        \nborder-color: #333333;\npadding: 2px 10px 2px 10px;\n}\n')
        writehandle.write('td.rite {\ntext-align: right;\n}\n')
        writehandle.write('td.fixed {\ncolor: #333333;\nfont-style: italic;\n}\n')
        writehandle.write('tr.last > td {\nborder-bottom: 1px solid #333333;\n}\n')
        writehandle.write('th {\nborder-bottom: 1px solid #333333;\n}\n')
        writehandle.write('table.param  > tbody > tr:nth-child(odd) > td {\nbackground-color: #cccccc;\n}\n')
        writehandle.write('a.toggle {\ntext-decoration: none;\ncolor: inherit;\n}\n')
        writehandle.write('button.little {\nfont-size: 75%;\n}\n')
        writehandle.write('</style>\n\n')

        # add script controls
        writehandle.write('<script language="javascript">\n')
        writehandle.write('function togglitsch(id){\n')
        writehandle.write('\tvar content;\n')
        writehandle.write('\tif(document.getElementById(id).style.display == \'none\'){\n')
        writehandle.write('\t\tdocument.getElementById(id).style.display = \'block\';\n')
        writehandle.write('\t\tcontent = document.getElementById(id + \'_ctrl\').innerHTML;\n')
        writehandle.write('\t\tdocument.getElementById(id + \'_ctrl\').innerHTML = \'&#9746;\' + content.slice(1)\n')
        writehandle.write('\t} else {\n')
        writehandle.write('\t\tdocument.getElementById(id).style.display = \'none\';\n')
        writehandle.write('\t\tcontent = document.getElementById(id + \'_ctrl\').innerHTML;\n')
        writehandle.write('\t\tdocument.getElementById(id + \'_ctrl\').innerHTML = \'&#9744;\' + content.slice(1)\n')
        writehandle.write('\t}\n}\n\n')

        writehandle.write('// controls for copy to clipboard\n')
        writehandle.write('function copyHelper(item, mode){\n')
        writehandle.write('\t// selects target range and then restores previous selection\n')
        writehandle.write('\tvar sel, backup = [];\n\n')
        writehandle.write('\t// backup ranges\n')
        writehandle.write('\tsel = window.getSelection();\n')
        writehandle.write('\tfor(let i = 0; i < sel.rangeCount; i++) {\n')
        writehandle.write('\t\tbackup[i] = sel.getRangeAt(i);\n')
        writehandle.write('\t}\n\n')
        writehandle.write('\t// delete previous ranges\n')
        writehandle.write('\tsel.removeAllRanges();\n')
        writehandle.write('\tif(mode){\n')
        writehandle.write('\t\tsel.addRange(item);\n')
        writehandle.write('\t} else {\n')
        writehandle.write('\t\titem.focus();\n')
        writehandle.write('\t\titem.select();\n')
        writehandle.write('\t}\n')
        writehandle.write('\t// copy selection\n')
        writehandle.write('\tdocument.execCommand(\'copy\');\n')
        writehandle.write('\t// restore previous selection\n')
        writehandle.write('\tsel.removeAllRanges();\n')
        writehandle.write('\tfor(let i = 0; i < backup.length; i++) {\n')
        writehandle.write('\t\tsel.addRange(backup[i]);\n')
        writehandle.write('\t}\n}\n\n')

        writehandle.write('function copyThis(targetId){\n')
        writehandle.write('\tvar body = document.body, target, range;\n')
        writehandle.write('\ttarget = document.getElementById(targetId);\n\n')
        writehandle.write('\tif (document.createRange && window.getSelection) {\n')
        writehandle.write('\t\t// select target stuff\n')
        writehandle.write('\t\trange = document.createRange();\n')
        writehandle.write('\t\ttry {\n')
        writehandle.write('\t\t\trange.selectNodeContents(target);\n')
        writehandle.write('\t\t} catch (e) {\n')
        writehandle.write('\t\t\trange.selectNode(target);\n')
        writehandle.write('\t\t}\n')
        writehandle.write('\t\tcopyHelper(range, true);\n')
        writehandle.write('\t}\n}\n\n')
        
        writehandle.write('// enable copy of SVG plots\n')
        writehandle.write('function copyThisInnerHTML(targetId){\n')
        writehandle.write('\tvar target, textarea, scrollX, scrollY;\n')
        writehandle.write('\ttarget = document.getElementById(targetId);\n')
        writehandle.write('\t// create dummy text area to temporarily paste innerHTML data\n')
        writehandle.write('\ttextarea = document.createElement(\'textarea\');\n')
        writehandle.write('\ttextarea.style.height = 0;\n')
        writehandle.write('\tscrollX = window.scrollX;\n')
        writehandle.write('\tscrollY = window.scrollY;\n')
        writehandle.write('\tdocument.body.appendChild(textarea);\n')
        writehandle.write('\t// now fill in textarea\n')
        writehandle.write('\ttextarea.value = target.innerHTML;\n')
        writehandle.write('\t// now call copyThis() on the temp object\n')
        writehandle.write('\tcopyHelper(textarea, false);\n')
        writehandle.write('\t// clean up the mess\n')
        writehandle.write('\tdocument.body.removeChild(textarea);\n')
        writehandle.write('\twindow.scroll(scrollX, scrollY);\n')
        writehandle.write('}\n\n')

        writehandle.write('// set up ctrl buttons\n')
        if(self.parent.lastFitType != 'none'):
          items = ['results']
        else:
          items = []
        if(dataFlag):
          items.append('data')
        items.extend(('param', 'fxn'))
        for entry in items:
          writehandle.write('var btn_' + entry + ' = document.getElementById(\'' + entry + '_button\');\n')
          writehandle.write('btn_' + entry + '.addEventListener(\'click\', function(event) {\n')
          writehandle.write('\tcopyThis(\'' + entry + '_content\');\n')
          writehandle.write('});\n\n')
      
        writehandle.write('var btn_plot = document.getElementById(\'plot_button\');\n')
        writehandle.write('btn_plot.addEventListener(\'click\', function(event) {\n')
        writehandle.write('\tcopyThisInnerHTML(\'plot_content\');\n')
        writehandle.write('});\n\n')

        writehandle.write('</script>\n')
        writehandle.write('</html>\n')
        writehandle.close()
        
        # save filename for future use
        self.currExportFile = filename
      
  def writeXLS(self, filename=None):
    # writes Results table to Excel file
    if(filename != None):
      try:
        workbook = xlsxwriter.Workbook(filename)
        worksheet = workbook.add_worksheet()
      except:
        self.parent.statusbar.showMessage('Cannot write data file ' + filename, self.parent.STATUS_TIME)
      else:
        # check whether current fit results are available
        index = 0
        if(self.parent.lastFitType != 'none'):
          # further check whether these are local or global results
          if(self.parent.lastFitType == 'local'):
            fitresults = self.parent.fitarea.outstring.splitlines()
          else:
            fitresults = self.parent.globalarea.globalOutstring.splitlines()
          for index, entry in enumerate(fitresults):
            worksheet.write(index, 0, entry)
        offset = index + 2
        # write header
        if((self.tableModel != None) and (self.tableModel.columnCount() > 0)):
          resultsHeader = self.tableModel.getHeaders()
          worksheet.write_row(offset, 0, resultsHeader)
          # write data
          resultsData = self.tableModel.getAllData()
          for rowIndex, row in enumerate(resultsData):
            row = [float(self.parent.formatNumber(i)) if (j != 'labels') else i for i, j in zip(row, resultsHeader)]
            worksheet.write_row(rowIndex + offset + 1, 0, row)
          coloffset = self.tableModel.columnCount() + 1
        else:
          coloffset = 0
        # write simulated data as well
        simX, simY = self.parent.fit[self.parent.activeFit].x, self.parent.fit[self.parent.activeFit].y
        worksheet.write(offset, coloffset, 'x')
        worksheet.write(offset, coloffset + 1, 'f(x)')
        for row in range(len(simX)):
          worksheet.write(row + offset + 1, coloffset, simX[row])
          worksheet.write(row + offset + 1, coloffset + 1, simY[row])
        # write graphics
        chart = workbook.add_chart({'type': 'scatter'})
        worksheet.insert_chart(chr(coloffset+1+67)+str(offset+2), chart)
        # write fit
        chart.add_series({'categories': ['Sheet1', offset+1, coloffset, offset + row + 1, coloffset],\
                          'values': ['Sheet1', offset+1, coloffset + 1, offset + row + 1, coloffset + 1],\
                          'line': {'color': 'red'},\
                          'name': 'fit',\
                          'marker': {'type': 'none'}})
        # write data (if present)
        if(('x' in self.descriptors) and ('y' in self.descriptors)):
          xcol = self.descriptors.index('x'); ycol = self.descriptors.index('y')
          rowcount = self.tableModel.rowCount()
          chartdict = {'categories': ['Sheet1', offset+1, xcol, offset + rowcount, xcol],\
                            'values': ['Sheet1', offset+1, ycol, offset + rowcount, ycol],\
                            'name': 'data',\
                            'marker': {'type': 'diamond'}}
          # include x-errors
          if('xerr' in self.descriptors):
            xerrcol = self.descriptors.index('xerr')
            rangestring = 'Sheet1!$' + chr(xerrcol + 65) + '$' + str(offset + 2) + ':$' + chr(xerrcol + 65) + '$' + str(offset + 1 + rowcount)
            chartdict['x_error_bars'] = {'type': 'custom',\
                     'plus_values': rangestring,\
                     'minus_values': rangestring}
          # include y-errors
          if('yerr' in self.descriptors):
            yerrcol = self.descriptors.index('yerr')
            rangestring = 'Sheet1!$' + chr(yerrcol + 65) + '$' + str(offset + 2) + ':$' + chr(yerrcol + 65) + '$' + str(offset + 1 + rowcount)
            chartdict['y_error_bars'] = {'type': 'custom',\
                     'plus_values': rangestring,\
                     'minus_values': rangestring}
          chart.add_series(chartdict)
    
        workbook.close()

  def setDataSet(self, currIndex=0, maxIndex=None):
    # updates spinbox for dataset selection
    if(maxIndex != None):
      self.dataSetSpinBox.setMaximum(maxIndex + 1)
      if(maxIndex):
        self.dataSetSpinBox.setEnabled(True)
      else:
        self.dataSetSpinBox.setEnabled(False)
    # set spin box
    self.dataSetSpinBox.blockSignals(True)
    self.dataSetSpinBox.setValue(currIndex + 1)
    self.dataSetSpinBox.blockSignals(False)
    # trigger update
    self.changeDataSet()

  def changeDataSet(self):
    # change dataset to display
    currIndex = self.dataSetSpinBox.value()
    values, descriptors = self.parent.data[currIndex - 1].getData_n_Fit()
    labels = self.parent.data[currIndex - 1].getLabels()
    self.dataSetName.setText(self.parent.data[currIndex - 1].name)
    # now set table content
    self.updateResults(values=values, descriptors=descriptors, labels=labels)
    
  def updateResults(self, values=[], descriptors=[], labels=[]):
    # updates results table
    if(len(values)):
      # prepare table
      if(len(labels)):
        descriptors.append('labels')
        values = values.tolist()
        values = [i + [str(j)] for i, j in zip(values, labels)]
      self.descriptors = descriptors
      self.tableModel = TableModel(values, self.resultstable)
      self.resultstable.setModel(self.tableModel)
      self.tableModel.setAllHeaders(self.descriptors)

      # set col width
      self.colWidth = int(self.resultstable.size().width() / 4.5)
      hheader = self.resultstable.horizontalHeader()
      hheader.setDefaultSectionSize(self.colWidth)
    else:
      self.tableModel = None
      nullModel = TableModel([], self.resultstable)
      self.resultstable.setModel(nullModel)

  def keyPressEvent(self, event):
    if event.matches(QtGui.QKeySequence.Copy):
      # prepare output
      selind = self.resultstable.selectionModel().selectedRows()
      selind = sorted([i.row() for i in selind])      
      # get data
      selectedData = self.tableModel.getDataRows(selind)
      output = ''
      for row in selectedData:
        row = [str(i) for i in row]
        output += '\t'.join(row) + '\n'
      
      clipboard = QtWidgets.QApplication.clipboard()
      clipboard.setText(output)
    else:
      QtWidgets.QWidget.keyPressEvent(self, event)

class BlankResizeMenu(KuhMenu):
  def __init__(self, parent = None, tableWidget = None):
    super(BlankResizeMenu, self).__init__()
    self.parent = parent
    self.tableWidget = tableWidget
    self.nrow, self.ncol = self.tableWidget.getDimension()
      
    # int validator
    self.validInt = MyValidInt()

    # set up GUI
    self.buildRessource()

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(not self.underMouse()):
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def buildRessource(self):
    # build gui for setting options
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[2]*4)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # heading
    self.blankResizeLabel = QtWidgets.QLabel()
    useFont = self.blankResizeLabel.font()
    useFont.setBold(True)
    self.blankResizeLabel.setFont(useFont)
    self.blankResizeLabel.setText('Blank/resize table')
    self.vLayout.addWidget(self.blankResizeLabel)
    
    # rows
    self.setRowGroup = QWidgetMac()
    self.vLayout.addWidget(self.setRowGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.setRowGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.setRowLabel = QtWidgets.QLabel('# rows')
    self.setRowLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.setRowLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.setRowLabel)

    self.setRowEntry = QLineEditClick()
    self.setRowEntry.setText(str(self.nrow))
    self.setRowEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.setRowEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.setRowEntry.editingFinished.connect(partial(self.setDimension, self.setRowEntry, 'row', 1, 1e6))
    self.setRowEntry.setValidator(self.validInt)
    self.hLayout.addWidget(self.setRowEntry)

    # cols
    self.setColGroup = QWidgetMac()
    self.vLayout.addWidget(self.setColGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.setColGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.setColLabel = QtWidgets.QLabel('# cols')
    self.setColLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.setColLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.setColLabel)

    self.setColEntry = QLineEditClick()
    self.setColEntry.setText(str(self.ncol))
    self.setColEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.setColEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.setColEntry.editingFinished.connect(partial(self.setDimension, self.setColEntry, 'col', 1, 1e6))
    self.setColEntry.setValidator(self.validInt)
    self.hLayout2.addWidget(self.setColEntry)
    
    # resize button
    self.resizeButton = QPushButtonMac()
    self.resizeButton.setText('Resize table')
    self.resizeButton.clicked.connect(self.resizeTable)
    self.resizeButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.resizeButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.vLayout.addWidget(self.resizeButton)

    # blank button
    self.blankButton = QPushButtonMac()
    self.blankButton.setText('Blank table')
    self.blankButton.clicked.connect(self.blankTable)
    self.blankButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.blankButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.vLayout.addWidget(self.blankButton)

    self.setFocus()    
    self.focusNextChild()

  def setDimension(self, entryfield=None, target=None, minval=1, maxval=100):
    # sets number of rows/cols in data table
    if((entryfield != None) and (target != None)):
      # check paramter boundaries
      try:
        value = int(entryfield.text())
        originalvalue = value
      except:
        value = 0
        originalvalue = 1
      value = min(value, maxval)
      value = max(value, minval)
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))

      # update row/column count
      if(target == 'row'):
        self.nrow = value
      else:
        self.ncol = value
          
  def blankTable(self):
    # resets table to empty new table
    self.tableWidget.generateEmptyTable(self.ncol, self.nrow)
    self.close()
    
  def resizeTable(self):
    # resizes table to new dimensions
    self.tableWidget.resizeTable(self.ncol, self.nrow)
    self.close()

class DataArea(QWidgetMac):
  def __init__(self, parent = None):
    super(DataArea, self).__init__()
    self.parent = parent
    self.errorModel, self.errorXModel = 0, 3
    self.errorConst, self.errorXConst = 1.0, 1.0
    self.errorPercent, self.errorXPercent = 5.0, 5.0
    self.errorPropagate = True
    self.reductionModel = 0
    self.reductionSkip = 1
    self.reductionAvg = 2
    self.reductionMovAvg = 2
    self.reductionLog = 100
    self.sheetNumber = 1
    self.transposeData = False
    self.importFilter = ''

    self.buildRessource()
    self.tableWidget.generateEmptyTable(3, 50)
    
    # set up namespace
    # import numpy again
    import numpy as np
    # import common functions from numpy for ease of access
    from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh
    self.mySpace = locals()

  def buildRessource(self):
    # set up GUI
    self.validFloat = MyValidFloat()
    self.validInt = MyValidInt()
    self.validInt.setBottom(1)

    # set up data table
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    self.importBox = QWidgetMac()
    self.vLayout.addWidget(self.importBox)
    self.importLayout = QtWidgets.QHBoxLayout(self.importBox)
    self.importLayout.setContentsMargins(0, 0, 0, 0)
    self.importLayout.setAlignment(QtCore.Qt.AlignLeft)
    
    self.importButton = QPushButtonMac()
    self.importButton.setText('Open File')
    self.importButton.clicked.connect(self.loadData)
    self.importButton.setMaximumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.importButton.setMinimumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.importLayout.addWidget(self.importButton)

    self.resizeButton = QPushButtonMac()
    self.resizeButton.setText('Blank/Resize \u25be')
    self.resizeButton.clicked.connect(partial(self.blankResizeTable, self.resizeButton))
    self.resizeButton.setMaximumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.resizeButton.setMinimumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.importLayout.addWidget(self.resizeButton)

    self.killCommaButton = QPushButtonMac()
    self.killCommaButton.setText('Replace Comma')
    self.killCommaButton.clicked.connect(self.killTheComma)
    self.killCommaButton.setMaximumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.killCommaButton.setMinimumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.importLayout.addWidget(self.killCommaButton)

    self.transposeCheck = QPushButtonCheckable()
    self.transposeCheck.setText('transpose?')
    self.transposeCheck.setChecked(False)
    self.transposeCheck.setMaximumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.transposeCheck.setMinimumSize(scaledDPI(90), scaledDPI(BASE_SIZE))
    self.transposeCheck.clicked.connect(self.dataTransposition)
    self.importLayout.addWidget(self.transposeCheck)
    
    self.sheetBox = QWidgetMac()
    self.vLayout.addWidget(self.sheetBox)
    self.sheetLayout = QtWidgets.QHBoxLayout(self.sheetBox)
    self.sheetLayout.setContentsMargins(0, 0, 0, 0)
    self.sheetLayout.setAlignment(QtCore.Qt.AlignLeft)

    self.importSheetLabel = QtWidgets.QLabel('sheet')
    self.importSheetLabel.setMaximumSize(scaledDPI(28), scaledDPI(BASE_SIZE))
    self.importSheetLabel.setMinimumSize(scaledDPI(28), scaledDPI(BASE_SIZE))
    self.sheetLayout.addWidget(self.importSheetLabel)
    self.importSheetLabel.setEnabled(False)
    
    self.importSheetSpinBox = QtWidgets.QSpinBox()
    self.importSheetSpinBox.setAlignment(QtCore.Qt.AlignRight)
    self.importSheetSpinBox.setMinimum(1)
    self.importSheetSpinBox.setMaximum(self.sheetNumber)
    self.importSheetSpinBox.setValue(1)
    self.importSheetSpinBox.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.importSheetSpinBox.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
    self.importSheetSpinBox.valueChanged.connect(self.changeSheet)
    self.importSheetSpinBox.setEnabled(False)
    self.sheetLayout.addWidget(self.importSheetSpinBox)
    
    self.importSheetName = QtWidgets.QLabel()
    self.sheetLayout.addWidget(self.importSheetName)
    self.sheetBox.hide()

    self.tableWidget = DataTable(self)
    self.vLayout.addWidget(self.tableWidget)
    
    # set up box for error specification
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    
    # set up box for x-error specification
    self.errorXSelectorBox = QWidgetMac()
    self.errorXSelectorBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.errorXSelectorBox)
    self.errorXSelectorLayout = QtWidgets.QHBoxLayout(self.errorXSelectorBox)
    self.errorXSelectorLayout.setContentsMargins(0, 0, 0, 0)
    
    self.errorXSelectorLabel = QtWidgets.QLabel('errorX')
    self.errorXSelectorLabel.setMaximumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.errorXSelectorLabel.setMinimumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.errorXSelectorLayout.addWidget(self.errorXSelectorLabel)
    
    self.errorXSelectorGroup = QtWidgets.QGroupBox()
    self.errorXSelectorGroup.setMinimumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorXSelectorGroup.setMaximumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorXSelectorLayout.addWidget(self.errorXSelectorGroup)

    self.errorXGroupLayout = QtWidgets.QHBoxLayout()
    self.errorXSelectorGroup.setLayout(self.errorXGroupLayout)
    
    self.errorXSelectorButtons = []
    self.errorXSelectorButtons.append(QtWidgets.QRadioButton(self.errorXSelectorGroup))
    self.errorXSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.errorXSelectorButtons[-1].setChecked(True)
    self.errorXSelectorButtons[-1].toggled.connect(partial(self.toggleErrorXModel, 3))
    self.errorXSelectorButtons[-1].setText('none')
    
    self.errorXSelectorButtons.append(QtWidgets.QRadioButton(self.errorXSelectorGroup))
    self.errorXSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(286), scaledDPI(2), scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.errorXSelectorButtons[-1].setChecked(False)
    self.errorXSelectorButtons[-1].toggled.connect(partial(self.toggleErrorXModel, 0))
    self.errorXSelectorButtons[-1].setText(u'\N{GREEK CAPITAL LETTER DELTA}x')
    
    self.errorXSelectorButtons.append(QtWidgets.QRadioButton(self.errorXSelectorGroup))
    self.errorXSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(52), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.errorXSelectorButtons[-1].setChecked(False)
    self.errorXSelectorButtons[-1].toggled.connect(partial(self.toggleErrorXModel, 1))
    self.errorXSelectorButtons[-1].setText('const')
    self.errorXConstEntry = QLineEditClick(self.errorXSelectorGroup)
    self.errorXConstEntry.setGeometry(QtCore.QRect(scaledDPI(106), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorXConstEntry.setText(str(self.errorXConst))
    self.errorXConstEntry.setValidator(self.validFloat)
    self.errorXConstEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorXConstEntry, 'errorXConst'))
    self.errorXConstEntry.focusOutEvent = partial(self.lostFocus, self.errorXConstEntry, 'errorXConst', self.errorXConstEntry.focusOutEvent)
    self.errorXConstEntry.focusInEvent = partial(self.gainFocus, self.errorXSelectorButtons[-1], self.errorXConstEntry.focusInEvent)
    
    self.errorXSelectorButtons.append(QtWidgets.QRadioButton(self.errorXSelectorGroup))
    self.errorXSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(172), scaledDPI(2), scaledDPI(42), scaledDPI(BASE_SIZE)))
    self.errorXSelectorButtons[-1].setChecked(False)
    self.errorXSelectorButtons[-1].toggled.connect(partial(self.toggleErrorXModel, 2))
    self.errorXSelectorButtons[-1].setText('prop')
    self.errorXPercentEntry = QLineEditClick(self.errorXSelectorGroup)
    self.errorXPercentEntry.setGeometry(QtCore.QRect(scaledDPI(218), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorXPercentEntry.setText(str(self.errorXPercent))
    self.errorXPercentEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorXPercentEntry, 'errorXPercent'))
    self.errorXPercentEntry.focusOutEvent = partial(self.lostFocus, self.errorXPercentEntry, 'errorXPercent', self.errorXPercentEntry.focusOutEvent)
    self.errorXPercentEntry.focusInEvent = partial(self.gainFocus, self.errorXSelectorButtons[-1], self.errorXPercentEntry.focusInEvent)
    self.errorXPercentEntry.setValidator(self.validFloat)
    self.errorXPercentLabel = QtWidgets.QLabel(self.errorXSelectorGroup)
    self.errorXPercentLabel.setGeometry(QtCore.QRect(scaledDPI(262), scaledDPI(2), scaledDPI(18), scaledDPI(BASE_SIZE)))
    self.errorXPercentLabel.setText('%')

    # set up controls for y error
    self.errorSelectorBox = QWidgetMac()
    self.errorSelectorBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.errorSelectorBox)
    self.errorSelectorLayout = QtWidgets.QHBoxLayout(self.errorSelectorBox)
    self.errorSelectorLayout.setContentsMargins(0, 0, 0, 0)
    
    self.errorSelectorLabel = QtWidgets.QLabel('errorY')
    self.errorSelectorLabel.setMaximumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.errorSelectorLabel.setMinimumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.errorSelectorLayout.addWidget(self.errorSelectorLabel)
    
    self.errorSelectorGroup = QtWidgets.QGroupBox()
    self.errorSelectorGroup.setMinimumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorSelectorGroup.setMaximumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorSelectorLayout.addWidget(self.errorSelectorGroup)

    self.errorGroupLayout = QtWidgets.QHBoxLayout()
    self.errorSelectorGroup.setLayout(self.errorGroupLayout)
    
    self.errorSelectorButtons = []
    self.errorSelectorButtons.append(QtWidgets.QRadioButton(self.errorSelectorGroup))
    self.errorSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.errorSelectorButtons[-1].setChecked(False)
    self.errorSelectorButtons[-1].toggled.connect(partial(self.toggleErrorModel, 3))
    self.errorSelectorButtons[-1].setText('none')
    
    self.errorSelectorButtons.append(QtWidgets.QRadioButton(self.errorSelectorGroup))
    self.errorSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(286), scaledDPI(2), scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.errorSelectorButtons[-1].setChecked(True)
    self.errorSelectorButtons[-1].toggled.connect(partial(self.toggleErrorModel, 0))
    self.errorSelectorButtons[-1].setText(u'\N{GREEK CAPITAL LETTER DELTA}y')
    
    self.errorSelectorButtons.append(QtWidgets.QRadioButton(self.errorSelectorGroup))
    self.errorSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(52), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.errorSelectorButtons[-1].setChecked(False)
    self.errorSelectorButtons[-1].toggled.connect(partial(self.toggleErrorModel, 1))
    self.errorSelectorButtons[-1].setText('const')
    self.errorConstEntry = QLineEditClick(self.errorSelectorGroup)
    self.errorConstEntry.setGeometry(QtCore.QRect(scaledDPI(106), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorConstEntry.setText(str(self.errorConst))
    self.errorConstEntry.setValidator(self.validFloat)
    self.errorConstEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorConstEntry, 'errorConst'))
    self.errorConstEntry.focusOutEvent = partial(self.lostFocus, self.errorConstEntry, 'errorConst', self.errorConstEntry.focusOutEvent)
    self.errorConstEntry.focusInEvent = partial(self.gainFocus, self.errorSelectorButtons[-1], self.errorConstEntry.focusInEvent)
    
    self.errorSelectorButtons.append(QtWidgets.QRadioButton(self.errorSelectorGroup))
    self.errorSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(172), scaledDPI(2), scaledDPI(42), scaledDPI(BASE_SIZE)))
    self.errorSelectorButtons[-1].setChecked(False)
    self.errorSelectorButtons[-1].toggled.connect(partial(self.toggleErrorModel, 2))
    self.errorSelectorButtons[-1].setText('prop')
    self.errorPercentEntry = QLineEditClick(self.errorSelectorGroup)
    self.errorPercentEntry.setGeometry(QtCore.QRect(scaledDPI(218), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.errorPercentEntry.setText(str(self.errorPercent))
    self.errorPercentEntry.editingFinished.connect(partial(self.validateErrorEntry, self.errorPercentEntry, 'errorPercent'))
    self.errorPercentEntry.focusOutEvent = partial(self.lostFocus, self.errorPercentEntry, 'errorPercent', self.errorPercentEntry.focusOutEvent)
    self.errorPercentEntry.focusInEvent = partial(self.gainFocus, self.errorSelectorButtons[-1], self.errorPercentEntry.focusInEvent)
    self.errorPercentEntry.setValidator(self.validFloat)
    self.errorPercentLabel = QtWidgets.QLabel(self.errorSelectorGroup)
    self.errorPercentLabel.setGeometry(QtCore.QRect(scaledDPI(262), scaledDPI(2), scaledDPI(18), scaledDPI(BASE_SIZE)))
    self.errorPercentLabel.setText('%')
    
    # set up controls for error propagation
    self.errorPropagateBox = QWidgetMac()
    self.errorPropagateBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.errorPropagateBox)
    self.errorPropagateLayout = QtWidgets.QHBoxLayout(self.errorPropagateBox)
    self.errorPropagateLayout.setContentsMargins(0, 0, 0, 0)
    
    self.errorPropagateLabel = QtWidgets.QLabel('errors')
    self.errorPropagateLabel.setMaximumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.errorPropagateLabel.setMinimumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.errorPropagateLayout.addWidget(self.errorPropagateLabel)
    
    self.errorPropagateGroup = QtWidgets.QGroupBox()
    self.errorPropagateGroup.setMinimumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorPropagateGroup.setMaximumHeight(scaledDPI(BASE_SIZE + 4))
    self.errorPropagateLayout.addWidget(self.errorPropagateGroup)

    self.errorPropagateCheck = QPushButtonCheckable(self.errorPropagateGroup)
    self.errorPropagateCheck.setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.errorPropagateCheck.setChecked(self.errorPropagate)
    self.errorPropagateCheck.setText('propagate?')
    self.errorPropagateCheck.clicked.connect(self.toggleErrorPropagation)

    # set up box for data reduction
    self.dataReductionBox = QWidgetMac()
    self.dataReductionBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.dataReductionBox)
    self.dataReductionLayout = QtWidgets.QHBoxLayout(self.dataReductionBox)
    self.dataReductionLayout.setContentsMargins(0, 0, 0, 0)
    
    self.dataReductionLabel = QtWidgets.QLabel('reduce')
    self.dataReductionLabel.setMaximumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.dataReductionLabel.setMinimumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.dataReductionLayout.addWidget(self.dataReductionLabel)
    
    self.dataReductionGroup = QtWidgets.QGroupBox()
    self.dataReductionGroup.setMinimumHeight(scaledDPI(2 * BASE_SIZE + 8))
    self.dataReductionGroup.setMaximumHeight(scaledDPI(2 * BASE_SIZE + 8))
    self.dataReductionLayout.addWidget(self.dataReductionGroup)
    
    self.dataReductionButtons = []
    self.dataReductionButtons.append(QtWidgets.QRadioButton(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(True)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 0))
    self.dataReductionButtons[-1].setText('none')
    
    self.dataReductionButtons.append(QtWidgets.QRadioButton(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(52), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(False)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 1))
    self.dataReductionButtons[-1].setText('skip')

    self.dataSkipEntry = QLineEditClick(self.dataReductionGroup)
    self.dataSkipEntry.setGeometry(QtCore.QRect(scaledDPI(106), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataSkipEntry.setText(str(self.reductionSkip))
    self.dataSkipEntry.editingFinished.connect(partial(self.validateReductionEntry, self.dataSkipEntry, 'reductionSkip'))
    self.dataSkipEntry.focusOutEvent = partial(self.lostFocusInt, self.dataSkipEntry, 'reductionSkip', self.dataSkipEntry.focusOutEvent)
    self.dataSkipEntry.focusInEvent = partial(self.gainFocus, self.dataReductionButtons[-1], self.dataSkipEntry.focusInEvent)
    self.dataSkipEntry.setValidator(self.validInt)
    
    self.dataSkipLabel = QtWidgets.QLabel(self.dataReductionGroup)
    self.dataSkipLabel.setGeometry(QtCore.QRect(scaledDPI(150), scaledDPI(2), scaledDPI(15), scaledDPI(BASE_SIZE)))
    self.dataSkipLabel.setText('pts')

    self.dataReductionButtons.append(QtWidgets.QRadioButton(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(172), scaledDPI(2), scaledDPI(36), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(False)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 2))
    self.dataReductionButtons[-1].setText('avg')

    self.dataAvgEntry = QLineEditClick(self.dataReductionGroup)
    self.dataAvgEntry.setGeometry(QtCore.QRect(scaledDPI(218), scaledDPI(2), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataAvgEntry.setText(str(self.reductionAvg))
    self.dataAvgEntry.editingFinished.connect(partial(self.validateReductionEntry, self.dataAvgEntry, 'reductionAvg'))
    self.dataAvgEntry.focusOutEvent = partial(self.lostFocusInt, self.dataAvgEntry, 'reductionAvg', self.dataAvgEntry.focusOutEvent)
    self.dataAvgEntry.focusInEvent = partial(self.gainFocus, self.dataReductionButtons[-1], self.dataAvgEntry.focusInEvent)
    self.dataAvgEntry.setValidator(self.validInt)
    
    self.dataAvgLabel = QtWidgets.QLabel(self.dataReductionGroup)
    self.dataAvgLabel.setGeometry(QtCore.QRect(scaledDPI(262), scaledDPI(2), scaledDPI(15), scaledDPI(BASE_SIZE)))
    self.dataAvgLabel.setText('pts')

    self.dataReductionButtons.append(QtWidgets.QRadioButton(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(52), scaledDPI(BASE_SIZE + 4), scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(False)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 3))
    self.dataReductionButtons[-1].setText('mvavg')

    self.dataMovAvgEntry = QLineEditClick(self.dataReductionGroup)
    self.dataMovAvgEntry.setGeometry(QtCore.QRect(scaledDPI(106), scaledDPI(BASE_SIZE + 4), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataMovAvgEntry.setText(str(self.reductionMovAvg))
    self.dataMovAvgEntry.editingFinished.connect(partial(self.validateReductionEntry, self.dataMovAvgEntry, 'reductionMovAvg'))
    self.dataMovAvgEntry.focusOutEvent = partial(self.lostFocusInt, self.dataMovAvgEntry, 'reductionMovAvg', self.dataMovAvgEntry.focusOutEvent)
    self.dataMovAvgEntry.focusInEvent = partial(self.gainFocus, self.dataReductionButtons[-1], self.dataMovAvgEntry.focusInEvent)
    self.dataMovAvgEntry.setValidator(self.validInt)
    
    self.dataMovAvgLabel = QtWidgets.QLabel(self.dataReductionGroup)
    self.dataMovAvgLabel.setGeometry(QtCore.QRect(scaledDPI(150), scaledDPI(BASE_SIZE + 4), scaledDPI(15), scaledDPI(BASE_SIZE)))
    self.dataMovAvgLabel.setText('pts')

    self.dataReductionButtons.append(QtWidgets.QRadioButton(self.dataReductionGroup))
    self.dataReductionButtons[-1].setGeometry(QtCore.QRect(scaledDPI(172), scaledDPI(BASE_SIZE + 4), scaledDPI(36), scaledDPI(BASE_SIZE)))
    self.dataReductionButtons[-1].setChecked(False)
    self.dataReductionButtons[-1].toggled.connect(partial(self.toggleDataReduction, 4))
    self.dataReductionButtons[-1].setText('log')

    self.dataLogEntry = QLineEditClick(self.dataReductionGroup)
    self.dataLogEntry.setGeometry(QtCore.QRect(scaledDPI(218), scaledDPI(BASE_SIZE + 4), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataLogEntry.setText(str(self.reductionLog))
    self.dataLogEntry.editingFinished.connect(partial(self.validateReductionEntry, self.dataLogEntry, 'reductionLog'))
    self.dataLogEntry.focusOutEvent = partial(self.lostFocusInt, self.dataLogEntry, 'reductionLog', self.dataLogEntry.focusOutEvent)
    self.dataLogEntry.focusInEvent = partial(self.gainFocus, self.dataReductionButtons[-1], self.dataLogEntry.focusInEvent)
    self.dataLogEntry.setValidator(self.validInt)

    self.dataLogLabel = QtWidgets.QLabel(self.dataReductionGroup)
    self.dataLogLabel.setGeometry(QtCore.QRect(scaledDPI(262), scaledDPI(BASE_SIZE + 4), scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.dataLogLabel.setText('pts (ca.)')

    # set up box for data transform
    self.dataTransformBox = QWidgetMac()
    self.dataTransformBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.dataTransformBox)
    self.dataTransformLayout = QtWidgets.QHBoxLayout(self.dataTransformBox)
    self.dataTransformLayout.setContentsMargins(0, 0, 0, 0)
    
    self.dataTransformLabel = QtWidgets.QLabel('transf.')
    self.dataTransformLabel.setMaximumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.dataTransformLabel.setMinimumSize(scaledDPI(32), scaledDPI(BASE_SIZE))
    self.dataTransformLayout.addWidget(self.dataTransformLabel)

    self.dataTransformGroup = QtWidgets.QGroupBox()
    self.dataTransformGroup.setMinimumHeight(scaledDPI(2 * BASE_SIZE + 8))
    self.dataTransformGroup.setMaximumHeight(scaledDPI(2 * BASE_SIZE + 8))
    self.dataTransformLayout.addWidget(self.dataTransformGroup)

    self.dataTransformXCheck = QPushButtonCheckable(self.dataTransformGroup)
    self.dataTransformXCheck.setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.dataTransformXCheck.setChecked(False)
    self.dataTransformXCheck.setText('x =')

    self.dataTransformXEntry = QLineEditClick(self.dataTransformGroup)
    self.dataTransformXEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.dataTransformXEntry.setGeometry(QtCore.QRect(scaledDPI(44), scaledDPI(2), scaledDPI(300), scaledDPI(BASE_SIZE)))
    self.dataTransformXEntry.setText('x')
    self.dataTransformXEntry.textChanged.connect(partial(self.dataTransformXCheck.setChecked, True))

    self.dataTransformYCheck = QPushButtonCheckable(self.dataTransformGroup)
    self.dataTransformYCheck.setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(BASE_SIZE + 4), scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.dataTransformYCheck.setChecked(False)
    self.dataTransformYCheck.setText('y =')

    self.dataTransformYEntry = QLineEditClick(self.dataTransformGroup)
    self.dataTransformYEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.dataTransformYEntry.setGeometry(QtCore.QRect(scaledDPI(44), scaledDPI(BASE_SIZE + 4), scaledDPI(300), scaledDPI(BASE_SIZE)))
    self.dataTransformYEntry.setText('y')
    self.dataTransformYEntry.textChanged.connect(partial(self.dataTransformYCheck.setChecked, True))

    # set up data import controls
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    
    self.refreshBox = QWidgetMac()
    self.refreshBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.refreshBox)
    self.refreshLayout = QtWidgets.QHBoxLayout(self.refreshBox)
    self.refreshLayout.setContentsMargins(0, 0, 0, 0)
    self.refreshButton = QPushButtonMac()
    self.refreshButton.setText('Import Data')
    self.refreshButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.refreshButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.refreshButton.clicked.connect(partial(self.updateData, False, True, False))
    self.refreshLayout.addWidget(self.refreshButton)

    self.dataSeriesButton = QPushButtonMac()
    self.dataSeriesButton.setText('Import Data Series')
    self.dataSeriesButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.dataSeriesButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.dataSeriesButton.clicked.connect(self.importDataSeries)
    self.refreshLayout.addWidget(self.dataSeriesButton)
    
    self.refreshCheck = QPushButtonCheckable()
    self.refreshCheck.setText('Auto Import?')
    self.refreshCheck.setChecked(False)
    self.refreshCheck.clicked.connect(partial(self.updateData, True, True, False))
    #self.refreshLayout.addWidget(self.refreshCheck)

  def reportState(self):
    # reports data content for saveState function
    retv = self.tableWidget.tableModel.getAllData()
    return retv

  def restoreState(self, data):
    # restores data content from loadState function
    try:
      tableData = literal_eval(data[0])
      self.resetSheetSpinBox(currVal=1, maxVal=1, currName='')
      self.transposeCheck.setChecked(False)
      
      self.tableWidget.restoreTable(tableData=tableData)
    except:
      print('Failed to restore data table ' + data[0])

  def killTheComma(self):
    # scour data table for commata and replace them
    self.tableWidget.killTheComma()

  def dataTransposition(self):
    # set data transposition flag
    self.transposeData = self.transposeCheck.isChecked()
    # trigger data transposition
    self.tableWidget.transposeTable()

  def resetSheetSpinBox(self, currVal=1, maxVal=1, currName=''):
    # updates import spin box
    self.importSheetSpinBox.setMaximum(maxVal)
    self.sheetNumber = currVal
    self.importSheetSpinBox.setValue(self.sheetNumber)
    
    if(maxVal > 1):
      self.sheetBox.show()
      self.importSheetSpinBox.setEnabled(True)
      self.importSheetLabel.setEnabled(True)
      self.importSheetName.setText(currName)
    else:
      self.importSheetSpinBox.setEnabled(False)
      self.importSheetLabel.setEnabled(False)
      self.importSheetName.setText('')
      self.sheetBox.hide()

  def changeSheet(self):
    # change current sheet in Excel files with several sheets
    self.sheetNumber = self.importSheetSpinBox.value()
    self.tableWidget.changeSheet(self.sheetNumber, transpose=self.transposeData)

  def gainFocus(self, toggleOption=None, defaultHandler=None, event=None):
    # entry field gained focus
    # select corresponding option
    if(toggleOption != None):
      toggleOption.setChecked(True)

    # pass signal to original handler
    if(defaultHandler != None):
      defaultHandler(event)

  def toggleDataReduction(self, mode=0):
    # change error model
    self.reductionModel = mode

  def toggleErrorModel(self, mode=0):
    # change error model
    self.errorModel = mode

  def toggleErrorXModel(self, mode=0):
    # change error model
    self.errorXModel = mode

  def toggleErrorPropagation(self):
    # toggles error propagation
    self.errorPropagate = self.errorPropagateCheck.isChecked()

  def lostFocusInt(self, entryobject=None, quantity=None, defaultHandler=None, event=None):
    # entry field lost focus, perform sanity check
    if(entryobject != None):
      entrytext = entryobject.text()
      if(self.parent.isNumber(entrytext)):
        self.__dict__[quantity] = int(entrytext)
      else:
        # restore previous value
        entryobject.setText(str(self.__dict__[quantity]))
    # pass signal to original handler
    if(defaultHandler != None):
      defaultHandler(event)
    
  def validateReductionEntry(self, entryobject=None, quantity=None):
    # validates entryfield
    if(entryobject != None):
      entrytext = entryobject.text()
      if(self.parent.isNumber(entrytext)):
        newnumber = int(entrytext)
        self.__dict__[quantity] = np.abs(newnumber)
      else:
        # restore previous value
        entryobject.setText(str(self.__dict__[quantity]))

  def lostFocus(self, entryobject=None, quantity=None, defaultHandler=None, event=None):
    # entry field lost focus, perform sanity check
    if(entryobject != None):
      entrytext = entryobject.text()
      if(self.parent.isNumber(entrytext)):
        self.__dict__[quantity] = float(entrytext)
      else:
        # restore previous value
        entryobject.setText(str(self.__dict__[quantity]))
    # pass signal to original handler
    if(defaultHandler != None):
      defaultHandler(event)
    
  def validateErrorEntry(self, entryobject=None, quantity=None):
    # validates entryfield
    if(entryobject != None):
      entrytext = entryobject.text()
      if(self.parent.isNumber(entrytext)):
        newnumber = float(entrytext)
        self.__dict__[quantity] = np.abs(newnumber)
        if(newnumber < 0):
          entryobject.setText(str(np.abs(newnumber)))
      else:
        # restore previous value
        entryobject.setText(str(self.__dict__[quantity]))

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def importDataSeries(self):
    # greedy import of data
    cycleColors = [[0.886, 0.290, 0.2, 1.0], [0.204, 0.541, 0.741, 1.0], [0.596, 0.557, 0.835, 1.0]]
    cycleColors.extend([[0.467, 0.467, 0.467, 1.0], [0.984, 0.757, 0.369, 1.0], [0.557, 0.729, 0.259, 1.0]])
    # check whether any data has been loaded
    if((self.tableWidget.tableModel == None) or (self.tableWidget.tableModel.rowCount() == 0)):
      self.parent.statusbar.showMessage('Open a data file first!', self.parent.STATUS_TIME)
    else:
      # can do this by repeatedly calling updateData
      roles = self.tableWidget.roles
      columnCount = self.tableWidget.tableModel.columnCount()
      
      # check for presence of x and y
      if((not 'x' in roles) or (not 'y' in roles)):
        self.parent.statusbar.showMessage('Assign x and y columns!', self.parent.STATUS_TIME)
      else:
        # remember original y column
        originalY = roles['y']
        
        # change dataset style to line and no symbol
        style = self.parent.data[self.parent.activeData].getStyle()
        if(style['linestyle'] == 'None'):
          self.parent.data[self.parent.activeData].setStyle('linestyle', 'solid', redraw=False)
        if(style['marker'] != 'None'):
          self.parent.data[self.parent.activeData].setStyle('marker', 'None', redraw=False)
        
        # loop over columns
        successes = 0
        currY = originalY
        while((currY < columnCount) and (successes < 100)):
          # check whether current column is already assigned to sth. else
          if((currY == originalY) or (not (currY in list(roles.values())))):
            # update status message as this can take a while
            self.parent.statusbar.showMessage('Now processing column ' + str(currY + 1) + '!', self.parent.STATUS_TIME, color='blue')
            # set current color
            currColor = (currY - originalY) % len(cycleColors)
            self.parent.data[self.parent.activeData].setStyle('color', cycleColors[currColor], redraw=False)
            # assign new y column
            self.tableWidget.roles['y'] = currY
            # get the new data
            self.updateData(docheck=False, redraw=False, quiet=True)
            # check the new data
            nuData = self.parent.data[self.parent.activeData].value()
            if(('x' in nuData) and (len(nuData['x']))):
              # keep track of successes
              successes += 1
              if((currY + 1 < columnCount) and (successes < 100)):
                # generate a new data set (if needed)
                self.parent.data.append(DataObject(self.parent))
                self.parent.data[-1].setName('Data_' + str(len(self.parent.data)-1))
                # need to copy contents of original object
                self.parent.data[-1].spawned(self.parent.data[self.parent.activeData])
                # set new data object as active
                self.parent.activeData = (len(self.parent.data) - 1)
          currY += 1
        
        # restore original roles
        self.tableWidget.roles['y'] = originalY
        
        # update objects area
        self.parent.objectsarea.refreshDataTable()
        self.parent.objectsarea.refreshResidTable()
        self.parent.objectsarea.refreshCurvesTable()
        self.parent.objectsarea.refreshExtrasTable()
        self.parent.globalarea.updateDataSetTable()
        
        # issue refresh of plots
        self.parent.plotArea.dataplotwidget.myRefresh()
        self.parent.plotArea.residplotwidget.myRefresh()

  def updateData(self, docheck=False, redraw=True, quiet=False):
    # check whether autoimport enabled
    if ((not docheck) or (self.refreshCheck.isChecked())):
      # check whether any data has been loaded
      if((self.tableWidget.tableModel == None) or (self.tableWidget.tableModel.rowCount() == 0)):
        self.parent.statusbar.showMessage('Open a data file first!', self.parent.STATUS_TIME)
      else:
        QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        QtCore.QCoreApplication.processEvents()
        
        # check whether we need to retrieve x-err and y-err columns at all
        needXErr, needYErr = not self.errorXModel, not self.errorModel
        # get and process data
        useLabelFlag = False
        new_data, roles = self.tableWidget.getData(needXErr=needXErr, needYErr=needYErr)
        if('labels' in roles):
          # separate numerical data from labels
          labelCol = roles.index('labels')
          labels = [i[labelCol] for i in new_data]
          new_data = [[k for j, k in enumerate(i) if j != labelCol] for i in new_data]
          newRoles = [i for i in roles if i != 'labels']
          # check whether x values in roles
          # if no x-values present (but labels), generate pseudo-x categories on the fly
          if(not 'x' in roles):
            newRoles.append('x')
            roles.append('x')
            for index, row in enumerate(new_data):
              row.append(index)
            useLabelFlag = True
        else:
          labels = []
          newRoles = roles
        labels = np.array(labels)
        new_data = np.array(new_data)

        # check for presence of x and y
        if((not 'x' in roles) or (not 'y' in roles)):
          if(not quiet):
            self.parent.statusbar.showMessage('Assign x (or, labels) and y columns!', self.parent.STATUS_TIME)
        else:
          # check whether the new selection makes sense
          array_dim = new_data.shape
          if(len(array_dim) == 1):
            if(array_dim[0] > 0):
              if(not quiet):
                self.parent.statusbar.showMessage('Select at least two data rows!', self.parent.STATUS_TIME)
            elif(self.tableWidget.hasComma()):
              if(not quiet):
                self.parent.statusbar.showMessage('Select some data to import them -- try replacing comma in data!', self.parent.STATUS_TIME)
            else:
              if(not quiet):
                self.parent.statusbar.showMessage('Select some data to import them!', self.parent.STATUS_TIME)
          elif ((len(array_dim) > 1) and (array_dim[1] > 1)):
            # process the error model for y
            if(1 <= self.errorModel <= 2):
              if(self.errorModel == 1):
                # use const
                errors = [self.errorConst] * array_dim[0]
                errors = np.array(errors)
              elif(self.errorModel ==2):
                # use percentage of y
                if('y' in newRoles):
                  index = newRoles.index('y')
                  errors = [self.errorPercent/100.0 * i for i in new_data[:,index]]
                  errors = np.array(errors)
                  #errors = errors.transpose()
                else:
                  if(not quiet):
                    self.parent.statusbar.showMessage('Cannot locate y values for percentage error calculation!', self.parent.STATUS_TIME, color='blue')
                  
              # check if y-error column already exists
              if('yerr' in newRoles):
                index = newRoles.index('yerr')
                new_data[:,index] = errors
              else:
                newRoles.append('yerr')
                # repackage errors to enable hstacking
                errors = [[i] for i in errors]
                errors = np.array(errors)
                new_data = np.hstack((new_data, errors))
            elif(self.errorModel == 3):
              # no errors => possibly delete yerr column
              if('yerr' in newRoles):
                index = newRoles.index('yerr')
                newRoles.pop(index)
                new_data = np.delete(new_data, index, 1)
              
            # process the error model for x
            if(1 <= self.errorXModel <= 2):
              if(self.errorXModel == 1):
                # use const
                errors = [self.errorXConst] * array_dim[0]
                errors = np.array(errors)
              elif(self.errorXModel ==2):
                # use percentage of x
                if('x' in newRoles):
                  index = newRoles.index('x')
                  errors = [self.errorXPercent/100.0 * i for i in new_data[:,index]]
                  errors = np.array(errors)
                  #errors = errors.transpose()
                else:
                  if(not quiet):
                    self.parent.statusbar.showMessage('Cannot locate x values for percentage error calculation!', self.parent.STATUS_TIME, color='blue')
                  
              # check if x-error column already exists
              if('xerr' in newRoles):
                index = newRoles.index('xerr')
                new_data[:,index] = errors
              else:
                newRoles.append('xerr')
                # repackage errors to enable hstacking
                errors = [[i] for i in errors]
                errors = np.array(errors)
                new_data = np.hstack((new_data, errors))
            elif(self.errorXModel == 3):
              # no x errors => possibly delete xerr column
              if('xerr' in newRoles):
                index = newRoles.index('xerr')
                newRoles.pop(index)
                new_data = np.delete(new_data, index, 1)
              
             # process the data reduction model
            if(self.reductionModel != 0):
              if(self.reductionModel == 1):
                # skip data points by numpy slicing
                new_data = new_data[::self.reductionSkip + 1]
                if('labels' in roles):
                  labels = labels[::self.reductionSkip + 1]
              elif(self.reductionModel == 2):
                # average with error propagation
                if('labels' in roles):
                  new_data, labels = self.movingAverage(sourceData=new_data, roles=newRoles, average=self.reductionAvg, stepsize=self.reductionAvg, labels=labels)
                else:
                  new_data = self.movingAverage(sourceData=new_data, roles=newRoles, average=self.reductionAvg, stepsize=self.reductionAvg)
              elif(self.reductionModel == 3):
                # moving average with error propagation
                if('labels' in roles):
                  new_data, labels = self.movingAverage(sourceData=new_data, roles=newRoles, average=self.reductionMovAvg, stepsize=1, labels=labels)
                else:
                  new_data = self.movingAverage(sourceData=new_data, roles=newRoles, average=self.reductionMovAvg, stepsize=1)
              elif(self.reductionModel == 4):
                # logarithmic data reduction
                if('labels' in roles):
                  new_data, labels = self.logAverage(sourceData=new_data, roles=newRoles, targetpoints=self.reductionLog, labels=labels)
                else:
                  new_data = self.logAverage(sourceData=new_data, roles=newRoles, targetpoints=self.reductionLog)
                
            # do data transform if necessary
            # make copy of original data in case we also have to transform y axis
            if(self.dataTransformYCheck.isChecked()):
              new_data2 = deepcopy(new_data)
            if(self.dataTransformXCheck.isChecked()):
              formula = str(self.dataTransformXEntry.text())
              if(len(formula) > 0):
                # transformer
                formula = 'x = ' + formula
                new_data = self.transformer(sourceData=new_data, roles=newRoles, formula=formula, axis='x')
              else:
                if(not quiet):
                  self.parent.statusbar.showMessage('Enter formula for x transformation!', self.parent.STATUS_TIME)
                
            if(self.dataTransformYCheck.isChecked()):
              formula = str(self.dataTransformYEntry.text())
              if(len(formula) > 0):
                # transformer
                formula = 'y = ' + formula
                new_data2 = self.transformer(sourceData=new_data2, roles=newRoles, formula=formula, axis='y')
                # replace y and yerr columns in new_data
                ycol = newRoles.index('y')
                new_data[:,ycol] = new_data2[:,ycol]
                # do error propagation?
                if(('yerr' in newRoles) and self.errorPropagate):
                  yerrcol = newRoles.index('yerr')
                  new_data[:,yerrcol] = new_data2[:,yerrcol]
              else:
                if(not quiet):
                  self.parent.statusbar.showMessage('Enter formula for y transformation!', self.parent.STATUS_TIME)
                
            # delete all rows with non-numerical content
            for role in newRoles:
              index = newRoles.index(role)
              if('labels' in roles):
                labels = labels[np.isfinite(new_data[:,index])]
              new_data = new_data[np.isfinite(new_data[:,index])]
  
            # assign new data
            if('labels' in roles):
              labels = list(labels)
              self.parent.data[self.parent.activeData].setData(new_data, newRoles, labels=labels)
            else:
              self.parent.data[self.parent.activeData].setData(new_data, newRoles)
              
            # here we should update the plot
            self.parent.data[self.parent.activeData].handleData, self.parent.data[self.parent.activeData].handleErr, self.parent.data[self.parent.activeData].handleErrShady,\
              self.parent.data[self.parent.activeData].handleBar, self.parent.data[self.parent.activeData].handleStack, self.parent.data[self.parent.activeData].handleStackNeg,\
              self.parent.data[self.parent.activeData].handleText, self.parent.data[self.parent.activeData].handleViolin = \
              self.parent.plotArea.plotData(self.parent.data[self.parent.activeData].value(), dataobject = self.parent.data[self.parent.activeData], \
              handleData = self.parent.data[self.parent.activeData].handleData, handleErr = self.parent.data[self.parent.activeData].handleErr, handleErrShady=self.parent.data[self.parent.activeData].handleErrShady,\
              handleBar = self.parent.data[self.parent.activeData].handleBar, handleStack = self.parent.data[self.parent.activeData].handleStack,\
              handleStackNeg = self.parent.data[self.parent.activeData].handleStackNeg, handleText = self.parent.data[self.parent.activeData].handleText, handleViolin = self.parent.data[self.parent.activeData].handleViolin, redraw=False, autoIgnoreCurrentY=True)
            self.parent.data[self.parent.activeData].handleData_div, self.parent.data[self.parent.activeData].handleErr_div, self.parent.data[self.parent.activeData].handleErrShady_div,\
              self.parent.data[self.parent.activeData].handleBar_div, self.parent.data[self.parent.activeData].handleStack_div, self.parent.data[self.parent.activeData].handleStackNeg_div,\
              self.parent.data[self.parent.activeData].handleText_div, self.parent.data[self.parent.activeData].handleViolin_div = \
              self.parent.plotArea.plotData(self.parent.data[self.parent.activeData].value(), dataobject = self.parent.data[self.parent.activeData], \
              handleData = self.parent.data[self.parent.activeData].handleData_div, handleErr = self.parent.data[self.parent.activeData].handleErr_div, handleErrShady=self.parent.data[self.parent.activeData].handleErrShady_div,\
              handleBar = self.parent.data[self.parent.activeData].handleBar_div, handleStack = self.parent.data[self.parent.activeData].handleStack_div,\
              handleStackNeg = self.parent.data[self.parent.activeData].handleStackNeg_div, handleText = self.parent.data[self.parent.activeData].handleText_div, handleViolin = self.parent.data[self.parent.activeData].handleViolin_div, redraw=False, splitX=True, autoIgnoreCurrentY=True)
            # and we should redraw the fit function to cover new x-range
            self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
              fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
              redraw=False, doAutoZoom=False)
            self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
              fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
              redraw=False, splitX=True, doAutoZoom=False)
            # check whether we should set category labels on x-axis
            if(useLabelFlag):
              self.parent.plotArea.setDataAxisTicks(dataSet=self.parent.activeData, redraw=False, target='plot')
              self.parent.plotArea.setDataAxisTicks(dataSet=self.parent.activeData, redraw=False, target='resid')
            # and we should update the legend
            self.updateLegend(redraw=redraw)
            # and we should update the corresponding residuals
            self.parent.data[self.parent.activeData].handleResid, self.parent.plotArea.handleResidZero,\
              self.parent.data[self.parent.activeData].handleResidBar, self.parent.data[self.parent.activeData].handleResidStack, self.parent.data[self.parent.activeData].handleResidStackNeg, self.parent.data[self.parent.activeData].handleResidText = self.parent.plotArea.plotResid(\
              dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid,\
              handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar,\
              handleResidStack = self.parent.data[self.parent.activeData].handleResidStack, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg,\
              handleResidText = self.parent.data[self.parent.activeData].handleResidText, redraw=False)
            self.parent.data[self.parent.activeData].handleResid_div, self.parent.plotArea.handleResidZero_div,\
              self.parent.data[self.parent.activeData].handleResidBar_div, self.parent.data[self.parent.activeData].handleResidStack_div, self.parent.data[self.parent.activeData].handleResidStackNeg_div, self.parent.data[self.parent.activeData].handleResidText_div = self.parent.plotArea.plotResid(\
              dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid_div,\
              handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar_div,\
              handleResidStack = self.parent.data[self.parent.activeData].handleResidStack_div, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg_div,\
              handleResidText = self.parent.data[self.parent.activeData].handleResidText_div, redraw=False, splitX=True)
            # and we should update the resid plot (as x-axis will most likely have rescaled)
            self.parent.plotArea.setAxisLimits(lower=self.parent.plotArea.minX, upper=self.parent.plotArea.maxX, axis='x',\
              updateLabel=False, target='resid', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=self.parent.plotArea.minX_div, upper=self.parent.plotArea.maxX_div, axis='x2',\
              updateLabel=False, target='resid', redraw=False, updateGrid=True)
            # draw resid line (again) to ensure coverage of entire x range
            self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero, redraw=False)
            self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero_div, redraw=redraw, splitX=True)
            
            # and we should update the results table
            self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData)
          
        QtWidgets.QApplication.restoreOverrideCursor()

  def transformer(self, sourceData=None, roles=None, formula='', axis='x'):
    self.EPSILON = 1e-9
    # does axis transform
    if(axis in ['x', 'y']):
      if(type(sourceData) != type(None)):
        if(axis in roles):
          # try defining transformation function
          try:
            funcstr = 'def transformThis(self, x, y):'
            funcstr += '\n\t' + formula + '\n\treturn ' + axis
            # generate ffunc in local namespace (this is needed for Python3 vs. Python2, bummer)
            namespace = self.mySpace
            exec(funcstr, namespace)
            # now define the new function in the object scope
            setattr(DataArea, 'transformThis', namespace['transformThis'])
          except:
            self.parent.statusbar.showMessage('Error when setting transformation for ' + axis, self.parent.STATUS_TIME)
          else:
            # do the actual transform
            index = roles.index(axis); #val = sourceData[:,index]
            xindex = roles.index('x'); xval = deepcopy(sourceData[:,xindex])
            yindex = roles.index('y'); yval = deepcopy(sourceData[:,yindex])
            try:
              newVal = self.transformThis(xval, yval)
              # now copy transformed data to data matrix
              sourceData[:,index] = newVal
            except:
              self.parent.statusbar.showMessage('Error when calculating transform for ' + axis, self.parent.STATUS_TIME)
            else:
              # deal with data errors
              errname = axis + 'err'
              if(errname in roles):
                errindex = roles.index(errname)
                # numerically determine derivatives in x and y
                # consider x
                if('xerr' in roles):
                  xerrindex = roles.index('xerr'); xerrval = sourceData[:,xerrindex]; xerrval = xerrval ** 2
                  try:
                    xderiv = self.transformThis(xval + self.EPSILON, yval)
                    xderiv = (xderiv - newVal) / self.EPSILON
                    xderiv = xderiv ** 2
                    newErr = xerrval * xderiv
                  except:
                    pass
                else:
                  newErr = np.array([0] * len(newVal))
                
                # consider y
                if('yerr' in roles):
                  yerrindex = roles.index('yerr'); yerrval = sourceData[:,yerrindex]; yerrval = yerrval ** 2
                  try:
                    yderiv = self.transformThis(xval, yval + self.EPSILON)
                    yderiv = (yderiv - newVal) / self.EPSILON
                    yderiv = yderiv ** 2
                    newErr = newErr + (yerrval * yderiv)
                  except:
                    pass
                  
                # calculate root of error
                newErr = newErr ** 0.5
                sourceData[:,errindex] = newErr

    return sourceData

  def logAverage(self, sourceData=None, roles=None, targetpoints=100, labels=np.array([])):
    # reduces data logarithmically to (approx.) target no. of points
    if(type(sourceData) != type(None)):
      if(('x' in roles) and ('y' in roles)):
        # locate x values
        xcol = roles.index('x')
        xval = sourceData[:,xcol]

        # get positive x values
        posXval = xval[xval > 0]
        if(len(posXval) > 0):
          # calculate target x values on log-spaced scale
          logXval = np.linspace(np.log(np.min(posXval)), np.log(np.max(posXval)), targetpoints)
          targetXval = np.exp(logXval)
          targetBoundary = [0]
          targetBoundary.extend([(targetXval[i] + targetXval[i+1])/2 for i in range(len(targetXval)-1)])
          targetBoundary.append(targetXval[-1])

          # cycle through boundary list
          output = np.array([]); avgLabels = []
          for index, entry in enumerate(targetBoundary[:-1]):
            targetRows = sourceData[sourceData[:,xcol] > targetBoundary[index]]
            labelIndex = len(sourceData[sourceData[:,xcol] <= targetBoundary[index]])
            targetRows = targetRows[targetRows[:,xcol] <= targetBoundary[index+1]]
          
            # check current entry
            if(targetRows.size > 0):
              if((len(targetRows.shape) > 1) and (targetRows.shape[0] > 1)):
                # calculate averages
                newRow = []
                for index2, entry2 in enumerate(roles):
                  if(entry2 in ['x', 'y']):
                    # numerically average x and y values
                    newRow.append(np.average(targetRows[:,index2]))
                  elif(entry2 in ['xerr', 'yerr']):
                    errVal = (targetRows[:,index2] / len(targetRows[:,index2])) ** 2
                    errVal = np.sum(errVal) ** 0.5
                    newRow.append(errVal)
                    
                targetRows = np.array(newRow)
                
              if(labels.size):
                avgLabels.append(labels[labelIndex])

              # append current line to output
              if(len(output) > 0):
                output = np.vstack((output, targetRows))
              else:
                output = targetRows
          
          if(labels.size):
            return output, np.array(avgLabels)
          else:
            return output
  
        else:
          self.parent.statusbar.showMessage('No positive x values, cannot do any reduction!', self.parent.STATUS_TIME)
          return sourceData

  def movingAverage(self, sourceData=None, roles=None, average=1, stepsize=1, labels=np.array([])):
    # calculate a moving average with error propagation
    if(type(sourceData) != type(None)):
      if(('x' in roles) and ('y' in roles)):
        # locate x and y values
        xcol = roles.index('x'); ycol = roles.index('y')
        xval = sourceData[:,xcol]
        yval = sourceData[:,ycol]
        # moving average
        avgXval = np.array([np.average(xval[i:i+average]) for i in range(0, len(xval) - average + 1, stepsize)])
        avgYval = np.array([np.average(yval[i:i+average]) for i in range(0, len(yval) - average + 1, stepsize)])
        # check for presence of error values
        if('yerr' in roles):
          # need to do error propagation
          yerrcol = roles.index('yerr')
          yerrval = sourceData[:,yerrcol]
          yerrval = (yerrval / average) ** 2
          # error propagation
          avgYerrval = np.array([np.sum(yerrval[i:i+average]) for i in range(0, len(yerrval) - average + 1, stepsize)])
          avgYerrval = avgYerrval ** 0.5
        elif('xerr' in roles):
          # need to do error propagation
          xerrcol = roles.index('xerr')
          xerrval = sourceData[:,xerrcol] 
          xerrval = (xerrval / average) ** 2
          # error propagation
          avgXerrval = np.array([np.sum(xerrval[i:i+average]) for i in range(len(0, xerrval) - average + 1, stepsize)])
          avgXerrval = avgXerrval ** 0.5
          
        # deal with data labels
        if(labels.size):
          # use label of first data point to be averaged
          avgLabel = np.array([labels[i] for i in range(0, len(xval) - average + 1, stepsize)])

        # now need to assemble columns according to roles
        procData = np.array([])
        for entry in roles:
          # get current column
          if(entry == 'x'):
            addItem = avgXval
          elif(entry == 'y'):
            addItem = avgYval
          elif(entry == 'xerr'):
            addItem = avgXerrval
          elif(entry == 'yerr'):
            addItem = avgYerrval
          
          # assemble output data
          if(procData.size > 0):
            procData = np.vstack((procData, addItem))
          else:
            procData = addItem

        if(labels.size):
          return procData.transpose(), avgLabel
        else:
          return procData.transpose()
        
  def loadData(self):
    global REMEMBERDIR
    if(PYCORN_PRESENT):
      filter_options = ['Excel Files (*.xls; *.xlsx)', 'Text Tab Delimited (*.txt)', 'Text Comma Separated (*.txt; *.csv)', 'Text Whitespace Delimited (*.txt)', 'Unicorn Files (*.res)']
    else:
      filter_options = ['Excel Files (*.xls; *.xlsx)', 'Text Tab Delimited (*.txt)', 'Text Comma Separated (*.txt; *.csv)', 'Text Whitespace Delimited (*.txt)']
    filterstring = ';;'.join(filter_options)
    filename, filter_ = QtWidgets.QFileDialog.getOpenFileName(self, filter=filterstring, directory = REMEMBERDIR, caption='Open Data', initialFilter=self.importFilter)
    self.importFilter = filter_
    filename = str(filename)
    if(PATH_SEPARATOR in filename):
      REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    elif('/' in filename):
      REMEMBERDIR = filename.split('/')[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    if(len(filename) > 0):
      mode = filter_options.index(filter_)
      if(mode == 0):
        self.tableWidget.loadXLS(filename=filename, transpose=self.transposeData)
      elif(mode == 1):
        self.tableWidget.loadTextFile(filename=filename, delimiter='\t', transpose=self.transposeData)
      elif(mode == 2):
        self.tableWidget.loadTextFile(filename=filename, delimiter=',', transpose=self.transposeData)
      elif(mode == 3):
        self.tableWidget.loadTextFile(filename=filename, delimiter=None, transpose=self.transposeData)
      elif(mode == 4):
        self.tableWidget.loadUnicornFile(filename=filename, transpose=self.transposeData)
    else:
      return False
    return True

  def blankResizeTable(self, callButton=None):
    # opens a QMenu to allow blanking and resizing of data table
    self.menu = BlankResizeMenu(self, self.tableWidget)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuY += callButton.geometry().height()
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()

    # open at mouse pointer
    self.menu.popup(QtCore.QPoint(menuX, menuY))

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.plotArea.setLegend(value=value, redraw=redraw)

class ShrinkoWidget(QWidgetMac):
  def __init__(self, notify=None, notifyResid=False):
    super(ShrinkoWidget, self).__init__()
    self.notify = notify
    self.notifyResid = notifyResid
    
  def resizeEvent(self, event):
    # do the regular resize event
    QtWidgets.QWidget.resizeEvent(self, event)
    # is this the container with the matplot inside?
    if(self.notify != None):
      if(self.notifyResid):
        # can probably skip the horizontal resize as this is already done by the partner shrink-o-widget
        self.notify.verticalRulerResid.updateRuler()
      else:
        self.notify.horizontalRuler.updateRuler()
        self.notify.verticalRuler.updateRuler()

class Ruler(QtWidgets.QFrame):
  def __init__(self, parent=None, mode=0, resid=False, numTicks=5):
    super(Ruler, self).__init__()
    self.parent = parent
    self.mode = mode
    self.resid = resid
    self.ticks = {}
    self.LARGE_RECTANGLE = 1000
    self.NUMBER_TICKS = numTicks
    self.ROUNDNESS = 3
    
    # init appearance
    self.setFrameShape(QtWidgets.QFrame.Box)
    self.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.setStyleSheet('background-color: rgb(255, 255, 255);')

  def paintEvent(self, event):
    # draw ruler
    s = self.size()
    width, height = s.width(), s.height()
    qp = QtGui.QPainter()
    qp.begin(self)
    qp.setRenderHint(QtGui.QPainter.Antialiasing, True)
    qp.drawRoundedRect(0, 0, width, height, scaledDPI(self.ROUNDNESS), scaledDPI(self.ROUNDNESS))
    
    # draw ticks
    if(self.mode):
      # vertical ruler
      qp.rotate(90)
      for entry in self.ticks:
        posY = int(entry * height + 0.5) - self.LARGE_RECTANGLE / 2
        label = self.ticks[entry]
        if(entry > 0):
          qp.drawText(posY, -scaledDPI(BASE_SIZE) - scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter, label)
          
      # draw dots in between
      labelPos = sorted(list(self.ticks.keys()))
      if(len(labelPos) > 1):
        # extend by one to draw dots beyond last number
        labelPos.append(2.0 * labelPos[-1] - labelPos[-2])
      for index in range(len(labelPos) - 1):
        posY = ((labelPos[index] + labelPos[index + 1]) / 2.0)
        posY = int(posY * height + 0.5) - self.LARGE_RECTANGLE / 2
        qp.drawText(posY, -scaledDPI(BASE_SIZE) - scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter, '\u2022')
        if(not self.resid):
          # small dots
          posY = ((3.0 * labelPos[index] + labelPos[index + 1]) / 4.0)
          posY = int(posY * height + 0.5) - self.LARGE_RECTANGLE / 2
          qp.drawText(posY, -scaledDPI(BASE_SIZE) - scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter, '\u00b7')
          posY = ((labelPos[index] + 3.0 * labelPos[index + 1]) / 4.0)
          posY = int(posY * height + 0.5) - self.LARGE_RECTANGLE / 2
          qp.drawText(posY, -scaledDPI(BASE_SIZE) - scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter, '\u00b7')
      qp.rotate(-90)
    else:
      # horizontal ruler
      for entry in self.ticks:
        posX = int(entry * width + 0.5) - self.LARGE_RECTANGLE / 2
        label = self.ticks[entry]
        if(entry > 0):
          # for alignment of text, need to specify a bounding box (which can be fairly large)
          qp.drawText(posX, scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop, label)
          
      # draw dots in between
      labelPos = sorted(list(self.ticks.keys()))
      if(len(labelPos) > 1):
        # extend by one to draw dots beyond last number
        labelPos.append(2.0 * labelPos[-1] - labelPos[-2])
      for index in range(len(labelPos) - 1):
        posX = ((labelPos[index] + labelPos[index + 1]) / 2.0)
        posX = int(posX * width + 0.5) - self.LARGE_RECTANGLE / 2
        qp.drawText(posX, scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop, '\u2022')
        # small dots
        posX = ((3.0 * labelPos[index] + labelPos[index + 1]) / 4.0)
        posX = int(posX * width + 0.5) - self.LARGE_RECTANGLE / 2
        qp.drawText(posX, scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop, '\u00b7')
        posX = ((labelPos[index] + 3.0 * labelPos[index + 1]) / 4.0)
        posX = int(posX * width + 0.5) - self.LARGE_RECTANGLE / 2
        qp.drawText(posX, scaledDPI(2), self.LARGE_RECTANGLE, scaledDPI(BASE_SIZE), QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop, '\u00b7')
      
    qp.end()

  def resizeEvent(self, event):
    # custom resize event
    QtWidgets.QFrame.resizeEvent(self, event)
    ###self.updateRuler()
    ### need to get the synchronization right, has to trigger after canvas resize
    ### we better trigger the update in the parental shrink-o-widget

  def updateRuler(self):
    # updates the ruler
    # first delete all previous ticks
    self.ticks = {}

    # caluclate new ones
    if(self.resid):
      currwidth, currheight = self.parent.residplot.get_size_inches()
    else:
      currwidth, currheight = self.parent.matplot.get_size_inches()
    
    if(self.mode):
      # horizontal ruler
      incrementV = int(currheight / self.NUMBER_TICKS)
      # check for large zoom scale
      escalate = 1
      while(not incrementV):
        escalate *= 2.0
        incrementV = int(escalate * currheight / self.NUMBER_TICKS)
      incrementV *= 1.0 / escalate
      # and the actual calculation
      currPos, incPos = 0, 1.0 * incrementV / currheight
      while((currPos * incPos) < 1):
        posY = currPos * incPos
        label = currPos * incrementV
        self.ticks[posY] = '{0:g}'.format(label)
        currPos += 1
    else:
      # horizontal ruler
      incrementH = int(currwidth / self.NUMBER_TICKS)
      # check for large zoom scale
      escalate = 1
      while(not incrementH):
        escalate *= 2.0
        incrementH = int(escalate * currwidth / self.NUMBER_TICKS)
      incrementH *= 1.0 / escalate
      # and the actual calculation
      currPos, incPos = 0, 1.0 * incrementH / currwidth
      while((currPos * incPos) < 1):
        posX = currPos * incPos
        label = currPos * incrementH
        self.ticks[posX] = '{0:g}'.format(label)
        currPos += 1
      
    # issue paint event
    self.update()

class MyAutoMinorLocator(matplotlib.ticker.AutoMinorLocator):
  # custom minor locator to heed missing major ticks
  def __init__(self, n=None):
    super(MyAutoMinorLocator, self).__init__(n=n)

  def __call__(self):
    'Return the locations of the ticks'
    majorlocs = self.axis.get_majorticklocs()
    # are we on a log scale?
    mode = self.axis.get_scale()

    if(mode != 'log'):
      try:
        majorstep = majorlocs[1] - majorlocs[0]
      except IndexError:
        return []
    else:
      try:
        majorstep = majorlocs[1] / majorlocs[0]
      except IndexError:
        return []
      except ZeroDivisionError:
        return []

    if self.ndivs is None:
      ndivs = 9
    else:
      ndivs = self.ndivs

    # view interval
    vmin, vmax = self.axis.get_view_interval()
    if vmin > vmax:
      vmin, vmax = vmax, vmin

    # calculate minor ticks
    locs = np.array([])
    for index in range(len(majorlocs) - 1):
      # can treat linear and log axes the same
      nulocs = np.linspace(majorlocs[index], majorlocs[index + 1], ndivs + 1)
      locs = np.hstack((locs, nulocs[1: -1]))
    
    # run through conditions
    cond1 = locs >= vmin
    cond2 = locs <= vmax
    locs = locs.compress(cond1 & cond2)

    return self.raise_if_exceeds(np.array(locs))

class MatplotlibCanvas(QWidgetMac):
  def __init__(self, parent=None):
    super(MatplotlibCanvas, self).__init__()
    self.parent = parent
    
    # initialize param values
    self.initParam()

    # set initial matplotlib style
    matplotlib.style.use(self.stylemodel)
    
    # a validator
    self.validFloat = MyValidFloat()
    
    # generate GUI elements
    self.buildRessource()
    
    # initialize plot
    self.initPlot(initialize=True)

    # toggle split axes
    self.toggleSplit(redraw=False)
    
    # update rulers
    self.horizontalRuler.updateRuler()
    self.verticalRuler.updateRuler()
    self.verticalRulerResid.updateRuler()
    
  def initParam(self):
    # allow some spacing around data when autoscaling
    self.data_spacer = 0.025
    
    # initialize some values
    self.x, self.y, self.y2 = np.array([]), np.array([]), np.array([])
    self.minX = 0.0; self.maxX = 1.0
    self.minY = 0.0; self.maxY = 1.0
    self.storeCoord = []
    self.minResidY = -0.5; self.maxResidY = 0.5
    self.modeX, self.modeY = 'linear', 'linear'
    self.EPSILON = 1e-6
    self.DATAPOINTS_SIMULATION = 2000
    self.autoScaleX, self.autoScaleY = True, True
    self.labelX = 'x'
    self.labelY = 'y'
    self.labelXShow, self.labelYShow = True, True
    self.labelXColor, self.labelYColor = [0.2, 0.2, 0.2, 1.0], [0.2, 0.2, 0.2, 1.0]
    self.labelXSize, self.labelYSize = 14.0, 14.0
    self.labelXWeight, self.labelYWeight = 'normal', 'normal'
    self.labelXStyle, self.labelYStyle = 'italic', 'italic'
    self.labelXVariant, self.labelYVariant = 'normal', 'normal'
    self.labelXPad, self.labelYPad = 4.0, 4.0
    self.labelXPos, self.labelYPos = 0.5, 0.5
    self.labelXAngle, self.labelYAngle = 0.0, 90.0
    self.labelXAlignment, self.labelYAlignment = 'center', 'center'
    self.labelXAlignmentVertical, self.labelYAlignmentVertical = 'top', 'baseline'
    self.axisVisible = {'left':True, 'right':True, 'bottom':True, 'top':True, 'left2':True, 'right2':True}
    self.axisWidth = {'left':1.0, 'right':1.0, 'bottom':1.0, 'top':1.0, 'left2':1.0, 'right2':1.0}
    self.axisStyle = {'left':'solid', 'right':'solid', 'bottom':'solid', 'top':'solid', 'left2':'solid', 'right2':'solid'}
    self.axisDashStyle = {'left':'butt', 'right':'butt', 'bottom':'butt', 'top':'butt', 'left2':'butt', 'right2':'butt'}
    self.axisColor = {'left':[0.2, 0.2, 0.2, 1.0], 'right':[0.2, 0.2, 0.2, 1.0], 'bottom':[0.2, 0.2, 0.2, 1.0],\
                      'top':[0.2, 0.2, 0.2, 1.0], 'left2':[0.2, 0.2, 0.2, 1.0], 'right2':[0.2, 0.2, 0.2, 1.0]}
    self.axisFont = {'x': 'DejaVu Sans', 'y': 'DejaVu Sans', 'y2': 'DejaVu Sans'}
    self.axisPosition = {'left':'axes', 'right':'axes', 'bottom':'axes', 'top':'axes', 'left2':'axes', 'right2':'axes'}
    self.axisPositionValue = {'left':0.0, 'right':1.0, 'bottom':0.0, 'top':1.0, 'left2':0.0, 'right2':1.0}
    self.tickFont = {'x': 'DejaVu Sans', 'y': 'DejaVu Sans', 'y2': 'DejaVu Sans'}
    self.ticksVisible = {'left':True, 'right':True, 'bottom':True, 'top':True, 'left2':False, 'right2':True}
    self.ticksWidth = {'left':0.5, 'right':0.5, 'bottom':0.5, 'top':0.5, 'left2':0.5, 'right2':0.5}
    self.ticksLength = {'left':5.0, 'right':5.0, 'bottom':5.0, 'top':5.0, 'left2':5.0, 'right2':5.0}
    self.ticksColor = {'left':[0.2, 0.2, 0.2, 1.0], 'right':[0.2, 0.2, 0.2, 1.0], 'bottom':[0.2, 0.2, 0.2, 1.0],\
                       'top':[0.2, 0.2, 0.2, 1.0], 'left2':[0.2, 0.2, 0.2, 1.0], 'right2':[0.2, 0.2, 0.2, 1.0]}
    self.ticksDirection = {'left':'in', 'right':'in', 'bottom':'in', 'top':'in', 'left2':'in', 'right2':'in'}
    self.canvasColor = [0.9, 0.9, 0.9, 1.0]
    self.canvasFill, self.figureFill, self.frameDraw = True, True, False
    self.figureColor = [1.0, 1.0, 1.0, 1.0]
    self.ticksX, self.ticksY, self.ticksResidY = [], [], []
    self.ticksXShow, self.ticksYShow, self.ticksResidYShow = True, True, True
    self.ticksXAuto, self.ticksYAuto, self.ticksResidYAuto = True, True, True
    self.ticksXMinor, self.ticksYMinor, self.ticksY2Minor, self.ticksResidYMinor = 2, 2, 2, 2
    self.ticksMinorRelativeLength = 0.5
    self.ticksXLabel = []
    self.ticksXColor = [0.2, 0.2, 0.2, 1.0]
    self.ticksYColor = [0.2, 0.2, 0.2, 1.0]
    self.ticksXSize, self.ticksYSize = 12.0, 12.0
    self.ticksXWeight, self.ticksYWeight = 'normal', 'normal'
    self.ticksXStyle, self.ticksYStyle = 'normal', 'normal'
    self.ticksXAngle, self.ticksYAngle = 0.0, 0.0
    self.ticksXAlignment, self.ticksYAlignment = 'center', 'right'
    self.ticksXAlignmentVertical, self.ticksYAlignmentVertical = 'top', 'center'
    self.ticksXPad, self.ticksYPad = 4.0, 4.0
    self.ticksXPad2, self.ticksYPad2 = 0.0, 0.0
    self.ticksXFormat, self.ticksYFormat, self.ticksY2Format, self.ticksResidYFormat = 'default', 'default', 'default', 'default'
    self.ticksXFormatPrecision, self.ticksYFormatPrecision, self.ticksY2FormatPrecision, self.ticksResidYFormatPrecision = 2, 2, 2, 2
    self.ticksXFormatTrailZero, self.ticksYFormatTrailZero, self.ticksY2FormatTrailZero, self.ticksResidYFormatTrailZero = False, False, False, False
    self.ticksXFormatSeparator, self.ticksYFormatSeparator, self.ticksY2FormatSeparator, self.ticksResidYFormatSeparator = False, False, False, False
    self.ticksXFormatPrefix, self.ticksYFormatPrefix, self.ticksY2FormatPrefix, self.ticksResidYFormatPrefix = '', '', '', ''
    self.ticksXFormatPostfix, self.ticksYFormatPostfix, self.ticksY2FormatPostfix, self.ticksResidYFormatPostfix = '', '', '', ''
    self.fallback_ticksXFormat, self.fallback_ticksYFormat, self.fallback_ticksY2Format, self.fallback_ticksResidYFormat = None, None, None, None
    self.gridVisible = {'x': False, 'x2': False, 'y': False, 'y2': False}
    self.gridLinesStore = {'x': [], 'x2': [], 'y': [], 'y2': []}
    self.gridLinesStore_resid = {'x': [], 'x2': [], 'y': [], 'y2': []}
    self.gridWidth = {'x': 0.5, 'x2': 0.5, 'y': 0.5, 'y2': 0.5}
    self.gridStyle = {'x': 'solid', 'x2': 'solid', 'y': 'solid', 'y2': 'solid'}
    self.gridDashStyle = {'x': 'butt', 'x2': 'butt', 'y': 'butt', 'y2': 'butt'}
    self.gridColor = {'x': [0.2, 0.2, 0.2, 1.0], 'x2': [0.2, 0.2, 0.2, 1.0], 'y': [0.2, 0.2, 0.2, 1.0], 'y2': [0.2, 0.2, 0.2, 1.0]}
    self.gridOrder = {'x': 'back', 'x2': 'back', 'y': 'back', 'y2': 'back'}
    self.exportWidth = 8.0; self.exportHeight = 6.0
    self.padSize = {'left':0.15, 'right':0.95, 'bottom':0.15, 'top':0.95}
    self.frameWidth, self.frameColor, self.frameStyle, self.frameDashStyle = 0.5, [0.2, 0.2, 0.2, 1.0], 'solid', 'butt'
    self.visibilityResidLine = True
    self.zorderResidLine = 1
    self.legendVisible = True
    self.legendPlacement = 'best'
    self.legendColor = {'face':[1.0, 1.0, 1.0, 0.5], 'edge':[0.2, 0.2, 0.2, 1.0]}
    self.legendEdgeWidth = 0.5
    self.legendShadow = False
    self.legendLabelColor = [0.0, 0.0, 0.0, 1.0]
    self.legendLabelSize = 14
    self.legendLabelWeight, self.legendLabelStyle = 'normal', 'normal'
    self.legendLabelFont = 'DejaVu Sans'
    self.legendNumPoints = 1
    self.legendMarkerFirst = True
    self.legendNumCol = 1
    self.legendMarkerScale = 1.0
    self.legendBorderPad = 0.4
    self.legendLabelSpacing = 0.4
    self.legendColumnSpacing = 2
    self.legendFill = True
    self.xkcd = False
    self.xkcdScale, self.xkcdLength, self.xkcdRandomness = 1.0, 100.0, 2.0
    self.xkcdStoreFonts = ['DejaVu Sans']
    self.applyPathStroke = False
    self.pathStrokeWidth, self.pathStrokeColor = 2.0, [1.0, 1.0, 1.0, 1.0]
    self.applyPathShadow = False
    self.pathShadowX, self.pathShadowY, self.pathShadowColor, self.pathShadowAlpha = 2, -2, [0.4, 0.4, 0.4, 0.5], 0.5
    self.pathRhoCheck, self.pathRho = True, 0.5
    self.handleArrow = {'x': None, 'y': None}
    self.handleArrowResid = {'x': None, 'y': None}
    self.arrowVisible = {'x': False, 'y': False}
    self.arrowOverhang = {'x': 0.1, 'y': 0.1}
    self.arrowColor = {'x': [0.2, 0.2, 0.2, 1.0], 'y': [0.2, 0.2, 0.2, 1.0]}
    self.arrowFill = {'x': [0.2, 0.2, 0.2, 1.0], 'y': [0.2, 0.2, 0.2, 1.0]}
    self.arrowHeadLength = {'x': 0.05, 'y': 0.05}
    self.arrowHeadWidth = {'x': 0.03, 'y': 0.03}
    self.arrowOffset = {'x': 0.2, 'y': 0.2}
    self.tickLabelData = False
    self.cursorVisible = False
    self.cursor = None
    self.pickedExtra, self.pickedAxes, self.pickedBackground, self.pickedMode, self.inAxes = None, None, None, 0, None
    
    # second y axis
    self.minY2, self.maxY2 = 0.0, 1.0
    self.modeY2 = 'linear'
    self.autoScaleY2 = True
    self.storeCoord2 = []
    self.ticksY2 = []
    self.ticksY2Show = True
    self.ticksY2Auto = True
    self.ticksY2Color = [0.2, 0.2, 0.2, 1.0]
    self.ticksY2Size = 12.0
    self.ticksY2Weight = 'normal'
    self.ticksY2Style = 'normal'
    self.ticksY2Angle = 0.0
    self.ticksY2Alignment = 'left'
    self.ticksY2AlignmentVertical = 'center'
    self.ticksY2Pad, self.ticksY2Pad2 = 4.0, 0.0
    self.labelY2 = 'y'
    self.labelY2Show = True
    self.labelY2Color = [0.2, 0.2, 0.2, 1.0]
    self.labelY2Size = 14.0
    self.labelY2Weight = 'normal'
    self.labelY2Style = 'italic'
    self.labelY2Variant = 'normal'
    self.labelY2Pad = 4.0
    self.labelY2Pos = 0.5
    self.labelY2Angle = 90.0
    self.labelY2Alignment = 'center'
    self.labelY2AlignmentVertical = 'top'
    
    self.splitShow, self.splitFraction, self.splitPad = False, 1.0, 0.1
    self.minX_div, self.maxX_div, self.modeX_div = 0, 1.0, 'linear'
    self.innerAxes, self.innerTicks = True, True
    self.ticksX_div, self.ticksXLabel_div, self.ticksXAuto_div, self.ticksXShow_div, self.ticksXShow_resid_div = [], [], True, True, True
    self.ticksXFormat_div, self.ticksXFormatPrecision_div, self.fallback_ticksXFormat_div, self.ticksXFormatTrailZero_div, self.ticksXFormatSeparator_div = 'default', 2, None, False, False
    self.ticksXFormatPrefix_div, self.ticksXFormatPostfix_div = '', ''
    self.cursor_div = None
    self.autoScaleX_div = False
    self.ticksXMinor_div = 2
    
    self.canvasGradientVisible = False
    self.canvasGradient = []
    self.canvasGradientStyle = 'linear'
    self.canvasGradientColor1, self.canvasGradientColor2 = [0.8, 0.8, 0.8, 1.0], [0.2, 0.2, 0.2, 1.0]
    self.canvasGradientAngle, self.canvasGradientWidth, self.canvasGradientCenter = 0.0, 0.5, [0.5, 0.5]

    # store information for graphics export as Python script
    self.rememberSetting = {}
    self.rememberSettingResidLine = {}
    
    # generate copies of certain settings for improved drawing control for resid window
    items = 'axisVisible,axisWidth,axisStyle,axisDashStyle,axisPosition,axisPositionValue,axisColor,labelX,labelY,labelXShow,labelYShow'.split(',')
    items.extend('labelXColor,labelYColor,labelXSize,labelYSize,labelXWeight,labelYWeight,labelXStyle,labelYStyle,labelXVariant,labelYVariant'.split(','))
    items.extend('labelXPad,labelYPad,labelXPos,labelYPos,labelXAlignment,labelYAlignment,labelXAlignmentVertical,labelYAlignmentVertical,labelXAngle,labelYAngle,axisFont'.split(','))
    items.extend('tickFont,ticksVisible,ticksWidth,ticksLength,ticksColor,ticksDirection'.split(','))
    items.extend('ticksXShow,ticksYShow,ticksXColor,ticksYColor,ticksXSize,ticksYSize,ticksXWeight,ticksYWeight,ticksXStyle,ticksYStyle'.split(','))
    items.extend('ticksXAngle,ticksYAngle,ticksMinorRelativeLength'.split(','))
    items.extend('ticksXAlignment,ticksYAlignment,ticksXAlignmentVertical,ticksYAlignmentVertical,ticksXPad,ticksYPad,ticksXPad2,ticksYPad2'.split(','))
    items.extend('gridVisible,gridWidth,gridStyle,gridDashStyle,gridColor,gridOrder,padSize,frameWidth,frameColor,frameStyle,frameDashStyle,frameDraw'.split(','))
    items.extend('canvasGradientStyle,canvasGradientColor1,canvasGradientColor2,canvasGradientAngle,canvasGradientWidth,canvasGradientCenter'.split(','))
    for entry in items:
      self.__dict__[entry+'_resid'] = deepcopy(self.__dict__[entry])

    if('bmh' in matplotlib.style.available):
      self.stylemodel = 'bmh'
    else:
      self.stylemodel = matplotlib.style.available[0]
      
    # pick event handling
    self.lastPickEvent = None
            
  def buildRessource(self):
    # set up matplotlib and canvas
    self.hLayout = QtWidgets.QHBoxLayout(self)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    # controls for y-axis
    self.yControlBox = QWidgetMac(self)
    self.yControlBox.setGeometry(QtCore.QRect(0, 0, scaledDPI(60), scaledDPI(500)))
    self.yControlBox.setMaximumSize(QtCore.QSize(scaledDPI(60), 16777215))
    self.yControlBox.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(200)))

    self.hLayout.addWidget(self.yControlBox)
    self.vLayout = QtWidgets.QVBoxLayout(self.yControlBox)
    self.vLayout.setContentsMargins(0, 0, 0, 0)

    self.SpacerBox0 = QWidgetMac(self)
    self.SpacerBox0.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.SpacerBox0.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.vLayout.addWidget(self.SpacerBox0)
    
    # controls for main plot
    self.yControlsPlotContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.yControlsPlotContainer, stretch=4)
    self.LayoutYControlsPlotContainer = QtWidgets.QVBoxLayout(self.yControlsPlotContainer)
    self.LayoutYControlsPlotContainer.setContentsMargins(0, 0, 0, 0)
    
    self.autoScaleBoxY = QWidgetMac(self)
    self.autoScaleBoxY.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.autoScaleBoxY.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.Layout_ScaleBoxY = QtWidgets.QHBoxLayout(self.autoScaleBoxY)
    self.Layout_ScaleBoxY.setContentsMargins(0, 0, 0, 0)
    self.Layout_ScaleBoxY.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.autoScaleButtonY = QPushButtonMac()
    self.autoScaleButtonY.setText('Auto')
    self.autoScaleButtonY.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonY.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonY.clicked.connect(partial(self.doAutoScale, 'y'))
    self.Layout_ScaleBoxY.addWidget(self.autoScaleButtonY)
    self.autoScaleCheckY = QPushButtonCheckable()
    self.autoScaleCheckY.setCheckMe(True)
    self.autoScaleCheckY.setChecked(self.autoScaleY)
    self.autoScaleCheckY.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.autoScaleCheckY.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.autoScaleCheckY.clicked.connect(partial(self.setAutoScale, 'y'))
    self.Layout_ScaleBoxY.addWidget(self.autoScaleCheckY)
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.autoScaleBoxY)
    
    self.upperLimity = QLineEditClick()
    self.upperLimity.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.upperLimity.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.upperLimity.setValidator(self.validFloat)
    self.upperLimity.setText(str(self.parent.formatNumber(self.maxY)))
    self.upperLimity.editingFinished.connect(partial(self.changeAxisLimits, 'y', 'plot', True))
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.upperLimity)

    self.modeSelectory = QComboBoxMac()
    self.modeSelectory.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.modeSelectory.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.modeSelectory)
    self.modeSelectory.addItem('linear')
    self.modeSelectory.addItem('log')
    self.modeSelectory.currentIndexChanged.connect(partial(self.changeAxisMode, 'y', True))
    
    self.lowerLimity = QLineEditClick()
    self.lowerLimity.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lowerLimity.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lowerLimity.setValidator(self.validFloat)
    self.lowerLimity.setText(str(self.parent.formatNumber(self.minY)))
    self.lowerLimity.editingFinished.connect(partial(self.changeAxisLimits, 'y', 'plot', True))
    self.LayoutYControlsPlotContainer.addStretch()
    self.LayoutYControlsPlotContainer.addWidget(self.lowerLimity)
    self.LayoutYControlsPlotContainer.addStretch()
    blah = self.HLine()
    self.LayoutYControlsPlotContainer.addWidget(blah)
    
    # controls for resid plot
    self.yControlsResidContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.yControlsResidContainer, stretch=1)
    self.LayoutYControlsResidContainer = QtWidgets.QVBoxLayout(self.yControlsResidContainer)
    self.LayoutYControlsResidContainer.setContentsMargins(0, 0, 0, 0)
    
    self.upperLimitResidy = QLineEditClick()
    self.upperLimitResidy.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.upperLimitResidy.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.upperLimitResidy.setValidator(self.validFloat)
    self.upperLimitResidy.setText(str(self.parent.formatNumber(self.maxResidY)))
    self.upperLimitResidy.editingFinished.connect(partial(self.changeAxisLimits, 'y', 'resid', True))
    self.LayoutYControlsResidContainer.addWidget(self.upperLimitResidy)

    self.lowerLimitResidy = QLineEditClick()
    self.lowerLimitResidy.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lowerLimitResidy.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lowerLimitResidy.setValidator(self.validFloat)
    self.lowerLimitResidy.setText(str(self.parent.formatNumber(self.minResidY)))
    self.lowerLimitResidy.editingFinished.connect(partial(self.changeAxisLimits, 'y', 'resid', True))
    self.LayoutYControlsResidContainer.addWidget(self.lowerLimitResidy)

    # little spacer boxes to align to plots
    self.SpacerBox = QWidgetMac(self)
    self.SpacerBox.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(25)))
    self.SpacerBox.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(25)))
    self.vLayout.addWidget(self.SpacerBox)

    self.SpacerBox_div = QWidgetMac(self)
    self.SpacerBox_div.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.SpacerBox_div.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.vLayout.addWidget(self.SpacerBox_div)

    # define the plot for the residuals
    plt.rcParams.update({'svg.fonttype': 'none'})
    self.residplot = plt.figure()

    # middle box
    self.middleBox = QWidgetMac(self)
    self.hLayout.addWidget(self.middleBox)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout2 = QtWidgets.QVBoxLayout(self.middleBox)
    self.vLayout2.setContentsMargins(0, 0, 0, 0)
    
    # horizontal ruler
    self.horizontalRulerBox = QWidgetMac(self)
    self.horizontalRulerBox.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.horizontalRulerBox.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.vLayout2.addWidget(self.horizontalRulerBox)
    self.LayoutHorizontalRulerBox = QtWidgets.QHBoxLayout(self.horizontalRulerBox)
    self.LayoutHorizontalRulerBox.setContentsMargins(0, 0, 0, 0)
    
    self.horizontalRuler = Ruler(parent=self, mode=0)
    self.horizontalRuler.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.horizontalRuler.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.LayoutHorizontalRulerBox.addWidget(self.horizontalRuler)

    self.SpacerBox2 = QWidgetMac(self)
    self.SpacerBox2.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
    self.SpacerBox2.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
    self.LayoutHorizontalRulerBox.addWidget(self.SpacerBox2)

    # container for plot and residuals
    self.plotContainer = QWidgetMac()
    self.LayoutPlotContainer = QtWidgets.QVBoxLayout(self.plotContainer)
    self.LayoutPlotContainer.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.addWidget(self.plotContainer)
    
    # the actual matplotlib canvas
    self.dataContainer = ShrinkoWidget(notify=self)
    self.LayoutPlotContainer.addWidget(self.dataContainer, stretch=4)
    self.LayoutDataContainer = QtWidgets.QHBoxLayout(self.dataContainer)
    self.LayoutDataContainer.setContentsMargins(0, 0, 0, 0)
    self.matplot = plt.figure()
    self.originalPlotDPI = self.matplot.get_dpi()
    zoomDifference = [abs(scaledDPI(self.originalPlotDPI) - i) for i in self.parent.zoomLevels]
    zoomIndex = zoomDifference.index(min(zoomDifference))
    self.matplot.set_dpi(self.parent.zoomLevels[zoomIndex])
    self.dataplotwidget = MyFigureCanvas(self.matplot, self, 'plot')
    self.LayoutDataContainer.addWidget(self.dataplotwidget)
    self.residplot.set_dpi(self.parent.zoomLevels[zoomIndex])

    # vertical ruler
    self.verticalRuler = Ruler(parent=self, mode=1)
    self.verticalRuler.setMinimumWidth(scaledDPI(BASE_SIZE))
    self.verticalRuler.setMaximumWidth(scaledDPI(BASE_SIZE))
    self.LayoutDataContainer.addWidget(self.verticalRuler)
 
    # set up canvas for the residuals
    self.residContainer = ShrinkoWidget(notify=self, notifyResid=True)
    self.LayoutPlotContainer.addWidget(self.residContainer, stretch=1)
    self.LayoutResidContainer = QtWidgets.QHBoxLayout(self.residContainer)
    self.LayoutResidContainer.setContentsMargins(0, 0, 0, 0)
    self.residplotwidget = MyFigureCanvas(self.residplot, self, 'resid')
    self.LayoutResidContainer.addWidget(self.residplotwidget)
    
    # vertical ruler resid
    self.verticalRulerResid = Ruler(parent=self, mode=1, resid=1, numTicks=2)
    self.verticalRulerResid.setMinimumWidth(scaledDPI(BASE_SIZE))
    self.verticalRulerResid.setMaximumWidth(scaledDPI(BASE_SIZE))
    self.LayoutResidContainer.addWidget(self.verticalRulerResid)
    
    # controls for x-axis
    self.xControlBox = QWidgetMac(self)
    self.xControlBox.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(BASE_SIZE)))
    self.xControlBox.setMaximumSize(QtCore.QSize(16777215, scaledDPI(BASE_SIZE)))
    self.xControlBox.setMinimumSize(QtCore.QSize(scaledDPI(200), scaledDPI(BASE_SIZE)))
    self.xControlBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.addWidget(self.xControlBox)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.xControlBox)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.addStretch()

    self.autoScaleBoxX = QWidgetMac(self)
    self.autoScaleBoxX.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.autoScaleBoxX.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.autoScaleBoxX)
    self.Layout_ScaleBoxX = QtWidgets.QHBoxLayout(self.autoScaleBoxX)
    self.Layout_ScaleBoxX.setContentsMargins(0, 0, 0, 0)
    self.Layout_ScaleBoxX.setAlignment(QtCore.Qt.AlignLeft)
    self.autoScaleButtonX = QPushButtonMac()
    self.autoScaleButtonX.setText('Auto')
    self.autoScaleButtonX.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonX.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.autoScaleButtonX.clicked.connect(partial(self.doAutoScale, 'x'))
    self.Layout_ScaleBoxX.addWidget(self.autoScaleButtonX)
    self.autoScaleCheckX = QPushButtonCheckable()
    self.autoScaleCheckX.setCheckMe(True)
    self.autoScaleCheckX.setChecked(self.autoScaleX)
    self.autoScaleCheckX.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.autoScaleCheckX.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.autoScaleCheckX.clicked.connect(partial(self.setAutoScale, 'x'))
    self.Layout_ScaleBoxX.addWidget(self.autoScaleCheckX)

    self.lowerLimitx = QLineEditClick()
    self.lowerLimitx.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lowerLimitx.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.lowerLimitx.setValidator(self.validFloat)
    self.lowerLimitx.setText(str(self.parent.formatNumber(self.minX)))
    self.lowerLimitx.editingFinished.connect(partial(self.changeAxisLimits, 'x', 'plot', True))
    self.hLayout2.addWidget(self.lowerLimitx)

    self.modeSelectorx = QComboBoxMac()
    self.modeSelectorx.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.modeSelectorx.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.modeSelectorx)
    self.modeSelectorx.addItem('linear')
    self.modeSelectorx.addItem('log')
    self.modeSelectorx.currentIndexChanged.connect(partial(self.changeAxisMode, 'x', True))
    
    self.upperLimitx = QLineEditClick()
    self.upperLimitx.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.upperLimitx.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.upperLimitx.setValidator(self.validFloat)
    self.upperLimitx.setText(str(self.parent.formatNumber(self.maxX)))
    self.upperLimitx.editingFinished.connect(partial(self.changeAxisLimits, 'x', 'plot', True))
    self.hLayout2.addWidget(self.upperLimitx)
    
    self.firstSplitBox = QWidgetMac()
    self.firstSplitBox.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.firstSplitBox.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.firstSplitBox)
    self.LayoutFirstSplitBox = QtWidgets.QHBoxLayout(self.firstSplitBox)
    self.LayoutFirstSplitBox.setContentsMargins(0, 0, 0, 0)

    self.splitAxisButton = QPushButtonCheckable()
    self.splitAxisButton.setText('split')
    self.splitAxisButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.splitAxisButton.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.splitAxisButton.setChecked(self.splitShow)
    self.LayoutFirstSplitBox.addWidget(self.splitAxisButton)
    self.splitAxisButton.clicked.connect(partial(self.toggleSplit, True))
    
    # controls for split x-axis
    self.xSplitControlBox = QWidgetMac(self)
    self.xSplitControlBox.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(BASE_SIZE)))
    self.xSplitControlBox.setMaximumSize(QtCore.QSize(16777215, scaledDPI(BASE_SIZE)))
    self.xSplitControlBox.setMinimumSize(QtCore.QSize(scaledDPI(200), scaledDPI(BASE_SIZE)))
    self.xSplitControlBox.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.addWidget(self.xSplitControlBox)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.xSplitControlBox)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.addStretch()
    
    self.xSplitLabel = QtWidgets.QLabel('split x')
    self.hLayout3.addWidget(self.xSplitLabel)
    
    self.xSplitAutoScaleBoxX = QWidgetMac(self)
    self.xSplitAutoScaleBoxX.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.xSplitAutoScaleBoxX.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.xSplitAutoScaleBoxX)
    self.Layout_xSplitScaleBoxX = QtWidgets.QHBoxLayout(self.xSplitAutoScaleBoxX)
    self.Layout_xSplitScaleBoxX.setContentsMargins(0, 0, 0, 0)
    self.Layout_xSplitScaleBoxX.setAlignment(QtCore.Qt.AlignLeft)
    self.xSplitAutoScaleButtonX = QPushButtonMac()
    self.xSplitAutoScaleButtonX.setText('Auto')
    self.xSplitAutoScaleButtonX.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.xSplitAutoScaleButtonX.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.xSplitAutoScaleButtonX.clicked.connect(partial(self.doAutoScale, 'x2'))
    self.Layout_xSplitScaleBoxX.addWidget(self.xSplitAutoScaleButtonX)
    self.xSplitAutoScaleCheckX = QPushButtonCheckable()
    self.xSplitAutoScaleCheckX.setCheckMe(True)
    self.xSplitAutoScaleCheckX.setChecked(self.autoScaleX_div)
    self.xSplitAutoScaleCheckX.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.xSplitAutoScaleCheckX.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.xSplitAutoScaleCheckX.clicked.connect(partial(self.setAutoScale, 'x2'))
    self.Layout_xSplitScaleBoxX.addWidget(self.xSplitAutoScaleCheckX)

    self.xSplitLowerLimitx = QLineEditClick()
    self.xSplitLowerLimitx.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.xSplitLowerLimitx.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.xSplitLowerLimitx.setValidator(self.validFloat)
    self.xSplitLowerLimitx.setText(str(self.parent.formatNumber(self.minX_div)))
    self.xSplitLowerLimitx.editingFinished.connect(partial(self.changeAxisLimits, 'x2', 'plot', True))
    self.hLayout3.addWidget(self.xSplitLowerLimitx)

    self.xSplitModeSelectorx = QComboBoxMac()
    self.xSplitModeSelectorx.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.xSplitModeSelectorx.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.xSplitModeSelectorx)
    self.xSplitModeSelectorx.addItem('linear')
    self.xSplitModeSelectorx.addItem('log')
    self.xSplitModeSelectorx.currentIndexChanged.connect(partial(self.changeAxisMode, 'x2', True))
    
    self.xSplitUpperLimitx = QLineEditClick()
    self.xSplitUpperLimitx.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.xSplitUpperLimitx.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.xSplitUpperLimitx.setValidator(self.validFloat)
    self.xSplitUpperLimitx.setText(str(self.parent.formatNumber(self.maxX_div)))
    self.xSplitUpperLimitx.editingFinished.connect(partial(self.changeAxisLimits, 'x2', 'plot', True))
    self.hLayout3.addWidget(self.xSplitUpperLimitx)

    self.altSplitBox = QWidgetMac()
    self.altSplitBox.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.altSplitBox.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.altSplitBox)
    self.LayoutAltSplitBox = QtWidgets.QHBoxLayout(self.altSplitBox)
    self.LayoutAltSplitBox.setContentsMargins(0, 0, 0, 0)

    # controls for secondAxes
    self.secondAxesContainer = QWidgetMac(self)
    self.secondAxesContainer.setGeometry(QtCore.QRect(0, 0, scaledDPI(61), scaledDPI(500)))
    self.secondAxesContainer.setMaximumSize(QtCore.QSize(scaledDPI(61), 16777215))
    self.secondAxesContainer.setMinimumSize(QtCore.QSize(scaledDPI(61), scaledDPI(200)))
    self.hLayout.addWidget(self.secondAxesContainer)
    self.LayoutSecondAxesContainer = QtWidgets.QVBoxLayout(self.secondAxesContainer)
    self.LayoutSecondAxesContainer.setContentsMargins(0, scaledDPI(1), 0, 0)

    self.SpacerBox3 = QWidgetMac(self)
    self.SpacerBox3.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.SpacerBox3.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.LayoutSecondAxesContainer.addWidget(self.SpacerBox3)
    
    self.secondAxesControlContainer = QWidgetMac(self)
    self.LayoutSecondAxesContainer.addWidget(self.secondAxesControlContainer, stretch=4)
    self.LayoutSecondAxesControlContainer = QtWidgets.QVBoxLayout(self.secondAxesControlContainer)
    self.LayoutSecondAxesControlContainer.setContentsMargins(0, 0, 0, 0)
    
    self.LayoutSecondAxesControlContainer.addStretch()
    self.secondAutoScaleBoxY = QWidgetMac(self)
    self.secondAutoScaleBoxY.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.secondAutoScaleBoxY.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.Layout_secondScaleBoxY = QtWidgets.QHBoxLayout(self.secondAutoScaleBoxY)
    self.Layout_secondScaleBoxY.setContentsMargins(0, 0, 0, 0)
    self.Layout_secondScaleBoxY.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.secondAutoScaleButtonY = QPushButtonMac()
    self.secondAutoScaleButtonY.setText('Auto')
    self.secondAutoScaleButtonY.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.secondAutoScaleButtonY.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.secondAutoScaleButtonY.clicked.connect(partial(self.doAutoScale, 'y2'))
    self.Layout_secondScaleBoxY.addWidget(self.secondAutoScaleButtonY)
    self.secondAutoScaleCheckY = QPushButtonCheckable()
    self.secondAutoScaleCheckY.setCheckMe(True)
    self.secondAutoScaleCheckY.setChecked(self.autoScaleY2)
    self.secondAutoScaleCheckY.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.secondAutoScaleCheckY.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.secondAutoScaleCheckY.clicked.connect(partial(self.setAutoScale, 'y2'))
    self.Layout_secondScaleBoxY.addWidget(self.secondAutoScaleCheckY)
    self.LayoutSecondAxesControlContainer.addWidget(self.secondAutoScaleBoxY)

    self.secondUpperLimit = QLineEditClick()
    self.secondUpperLimit.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.secondUpperLimit.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.secondUpperLimit.setValidator(self.validFloat)
    self.secondUpperLimit.setText(str(self.parent.formatNumber(self.maxY2)))
    self.secondUpperLimit.editingFinished.connect(partial(self.changeAxisLimits, 'y2', 'plot', True))
    self.LayoutSecondAxesControlContainer.addStretch()
    self.LayoutSecondAxesControlContainer.addWidget(self.secondUpperLimit)

    self.secondModeSelector = QComboBoxMac()
    self.secondModeSelector.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.secondModeSelector.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.LayoutSecondAxesControlContainer.addStretch()
    self.LayoutSecondAxesControlContainer.addWidget(self.secondModeSelector)
    self.secondModeSelector.addItem('linear')
    self.secondModeSelector.addItem('log')
    self.secondModeSelector.currentIndexChanged.connect(partial(self.changeAxisMode, 'y2', True))
    
    self.secondLowerLimit = QLineEditClick()
    self.secondLowerLimit.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.secondLowerLimit.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.secondLowerLimit.setValidator(self.validFloat)
    self.secondLowerLimit.setText(str(self.parent.formatNumber(self.minY2)))
    self.secondLowerLimit.editingFinished.connect(partial(self.changeAxisLimits, 'y2', 'plot', True))
    self.LayoutSecondAxesControlContainer.addStretch()
    self.LayoutSecondAxesControlContainer.addWidget(self.secondLowerLimit)
    self.LayoutSecondAxesControlContainer.addStretch()
    blah = self.HLine()
    self.LayoutSecondAxesControlContainer.addWidget(blah)    
    
    self.pseudoContainer = QWidgetMac(self)
    self.LayoutSecondAxesContainer.addWidget(self.pseudoContainer, stretch=1)

    self.SpacerBox5 = QWidgetMac(self)
    self.SpacerBox5.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(25)))
    self.SpacerBox5.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(25)))
    self.LayoutSecondAxesContainer.addWidget(self.SpacerBox5)

    # initially turn off the second axes controls
    self.toggleSecondAxes(state=False)

  def toggleSecondAxes(self, state=False):
    # toggles visibility of control elements for second axes
    ###if(state):
    if(True):
      self.secondAxesContainer.setVisible(state)
      if((hasattr(self.parent, 'tabWidget')) and (hasattr(self.parent, 'tab_7'))):
        if(state):
          if(self.parent.tabWidget.indexOf(self.parent.tab_7) < 0):
            self.parent.tabWidget.addTab(self.parent.tab_7, "2nd Axes")
        else:
          if(self.parent.tabWidget.indexOf(self.parent.tab_7) > -1):
            self.parent.tabWidget.removeTab(self.parent.tabWidget.indexOf(self.parent.tab_7))
      # toggle visibility of plot elements
      if(hasattr(self.parent, 'plotArea')):
        self.toggleSecondAxesItems(state=state)
    # need to solve inner situation -- but check whether plot object is already instantiated
    if(hasattr(self, 'ax')):
      self.updateInnerSituation()
      
  def toggleSecondAxesItems(self, state=False):
    # turns on/off all relevant plot elements of self.ax2
    self.ax2.spines['left'].set_visible(state and self.axisVisible['left2'])
    self.ax2.spines['right'].set_visible(state and self.axisVisible['right2'])
    self.ax2.yaxis.set_visible(state)

    self.ax2_div.spines['left'].set_visible(state and self.axisVisible['left2'])
    self.ax2_div.spines['right'].set_visible(state and self.axisVisible['right2'])
    self.ax2_div.yaxis.set_visible(state)
    
    # delete all grid lines on the second axes
    if(state):
      if(self.gridVisible['y2']):
        self.drawAxisGrid(axis='y2', redraw=False, target='plot')
    else:
      for line in self.gridLinesStore['y2'] :
        line.remove()
      self.gridLinesStore['y2'] = []
    
  def isSecondAxesActive(self):
    # checks whether any items are on second axis
    onSecondItems = [1 if (i.onSecondAxes) else 0 for i in (self.parent.data + self.parent.fit + self.parent.extras)]
    if(sum(onSecondItems)):
      return True
    else:
      return False

  def toggleSplit(self, redraw=True):
    # toggles on/off split x axis
    state = self.splitAxisButton.isChecked()
    self.splitShow = state
    self.ax_div.set_visible(state)
    self.ax2_div.set_visible(state)
    self.ax_resid_div.set_visible(state)
    if(state):
      if(hasattr(self.parent, 'graphicsarea')):
        self.parent.graphicsarea.innerDividerLine.show()
        self.parent.graphicsarea.configInnerBox.show()
        self.parent.graphicsarea.configInnerTickXBox.show()
        self.parent.graphicsarea.configGridBox['x2'].show()
        # check whether advanced graphics enabled
        if(self.parent.graphicsarea.advancedExport['advancedGraphics']):
          if(hasattr(self.parent.graphicsarea, 'configInnerBox2')):
            self.parent.graphicsarea.configInnerBox2.show()
          if(hasattr(self.parent.graphicsarea, 'configInnerBox3')):
            self.parent.graphicsarea.configInnerBox3.show()
        if(self.parent.graphicsarea.advancedExport['advancedGraphics']):
          if(hasattr(self.parent.graphicsarea, 'configInnerMinorTickBox')):
            self.parent.graphicsarea.configInnerMinorTickBox.show()
      
      self.divider_ax2.set_horizontal((Size.AxesX(self.ax2), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax2))))
      self.divider_resid.set_horizontal((Size.AxesX(self.ax_resid), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax_resid))))
      self.divider_ax.set_horizontal((Size.AxesX(self.ax), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax))))

      # if called further up, the following command produces a warning under Linux
      # b/c the underlying call to axis._get_pixel_distance_along_axis() fails
      # => work around: move it here
      self.xSplitControlBox.show()
      self.SpacerBox_div.show()
      self.LayoutAltSplitBox.addWidget(self.splitAxisButton)
      
      # set visibility of inner items correctly
      self.updateInnerSituation()
      
      # need to update tick formatting if split axis is turned on
      for target in ['plot', 'resid']:
        self.setTickOne4All(axis='x', redraw=False, target=target)
    else:
      self.xSplitControlBox.hide()
      self.SpacerBox_div.hide()
      self.LayoutFirstSplitBox.addWidget(self.splitAxisButton)
      if(hasattr(self.parent, 'graphicsarea')):
        self.parent.graphicsarea.innerDividerLine.hide()
        self.parent.graphicsarea.configInnerBox.hide()
        self.parent.graphicsarea.configInnerTickXBox.hide()
        self.parent.graphicsarea.configGridBox['x2'].hide()
        if(hasattr(self.parent.graphicsarea, 'configInnerBox2')):
          self.parent.graphicsarea.configInnerBox2.hide()
        if(hasattr(self.parent.graphicsarea, 'configInnerBox3')):
          self.parent.graphicsarea.configInnerBox3.hide()
        if(hasattr(self.parent.graphicsarea, 'configInnerMinorTickBox')):
          self.parent.graphicsarea.configInnerMinorTickBox.hide()
      
      self.divider_ax2.set_horizontal((Size.AxesX(self.ax2), Size.Fixed(0), Size.Fixed(0)))
      self.divider_resid.set_horizontal((Size.AxesX(self.ax_resid), Size.Fixed(0), Size.Fixed(0)))
      self.divider_ax.set_horizontal((Size.AxesX(self.ax), Size.Fixed(0), Size.Fixed(0)))

      # clean up the mess that may have been caused by toggling visibility of inner items
      self.setAxisVisibility(value=self.axisVisible['right'], axis='right', redraw=False, target='plot')
      self.setAxisVisibility(value=self.axisVisible['left2'], axis='left2', redraw=False, target='plot')
      self.setAxisVisibility(value=self.axisVisible_resid['right'], axis='right', redraw=False, target='resid')

      self.setTickMarkVisibility(value=self.ticksVisible['right'], axis='right', redraw=False, target='plot')
      self.setTickMarkVisibility(value=self.ticksVisible['left2'], axis='left2', redraw=False, target='plot')
      self.setTickMarkVisibility(value=self.ticksVisible_resid['right'], axis='right', redraw=False, target='resid')
      
    # refresh plots
    if(redraw):
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()

      # finally we have to take care of the crosshair cursor b/c as of matplotlib 3.1.2 we can only initialize
      # it upon first display of div plot --- bummer!
      if(state and (self.cursor != None) and (self.cursor_div == None)):
        self.cursor_div = MyCursor(self.ax_div, useblit=True, color='black', linewidth=1)
        self.cursor_div.setParent(self)
        self.cursor_div.setAx2(self.ax2_div)
        
        # link cursors
        self.cursor.setTwin(self.cursor_div)
        self.cursor_div.setTwin(self.cursor)
        
        # toggle visibility
        self.cursor_div.toggleVisibility(self.cursorVisible, None)

  def changeSplitFraction(self, value=1.0, redraw=True):
    # update parameters
    if (value == self.splitFraction):
      redraw = False
    self.splitFraction = value
    # call toggleSplit fxn
    self.toggleSplit(redraw=redraw)

  def changeSplitPad(self, value=0.02, redraw=True):
    # update parameters
    if (value == self.splitPad):
      redraw = False
    self.splitPad = value
    # call toggleSplit fxn
    self.toggleSplit(redraw=redraw)

  def reportState(self):
    # returns current settings for save state function
    reportItems = ['minX', 'maxX', 'minY', 'maxY', 'minResidY', 'maxResidY', 'modeX', 'modeY', 'autoScaleX', 'autoScaleY']
    reportItems.extend(['minY2', 'maxY2', 'modeY2', 'autoScaleY2'])
    reportItems.extend(['splitShow', 'splitFraction', 'splitPad', 'minX_div', 'maxX_div', 'modeX_div', 'autoScaleX_div'])
    reportItems.extend(['innerAxes', 'innerTicks'])
    retv = {}
    
    for entry in reportItems:
      if(hasattr(self, entry)):
        value = getattr(self, entry)
        retv[entry] = value
        
    # also add current zoom level (which, however, belongs to parent object)
    currZoomIndex = self.parent.zoomSelector.currentIndex()
    retv['zoomLevel'] = self.parent.zoomLevels[::-1][currZoomIndex]
    
    return retv
  
  def restoreState(self, settings, updateTicks=True):
    # restores settings from load state function
    for entry in settings:
      if(hasattr(self, entry)):
        self.__dict__[entry] = settings[entry]

    # remember desired axes limits
    orig_minX, orig_maxX = self.minX, self.maxX
    orig_minY, orig_maxY = self.minY, self.maxY
    orig_minResidY, orig_maxResidY = self.minResidY, self.maxResidY
    orig_minY2, orig_maxY2 = self.minY2, self.maxY2
    orig_minX_div, orig_maxX_div = self.minX_div, self.maxX_div
    
    # apply these settings
    # autoscale
    self.autoScaleCheckX.setChecked(self.autoScaleX)
    self.autoScaleCheckY.setChecked(self.autoScaleY)
    self.xSplitAutoScaleCheckX.setChecked(self.autoScaleX_div)

    # axes modes
    index = self.modeSelectorx.findText(self.modeX)
    if((index + 1) and (index != self.modeSelectorx.currentIndex())):
      self.modeSelectorx.blockSignals(True)
      self.modeSelectorx.setCurrentIndex(index)
      self.modeSelectorx.blockSignals(False)
      self.changeAxisMode('x', redraw=False)
    index = self.modeSelectory.findText(self.modeY)
    if((index + 1) and (index != self.modeSelectory.currentIndex())):
      self.modeSelectory.blockSignals(True)
      self.modeSelectory.setCurrentIndex(index)
      self.modeSelectory.blockSignals(False)
      self.changeAxisMode('y', redraw=False)
    index = self.secondModeSelector.findText(self.modeY2)
    if((index + 1) and (index != self.secondModeSelector.currentIndex())):
      self.secondModeSelector.blockSignals(True)
      self.secondModeSelector.setCurrentIndex(index)
      self.secondModeSelector.blockSignals(False)
      self.changeAxisMode('y2', redraw=False)
    index = self.xSplitModeSelectorx.findText(self.modeX_div)
    if((index + 1) and (index != self.xSplitModeSelectorx.currentIndex())):
      self.xSplitModeSelectorx.blockSignals(True)
      self.xSplitModeSelectorx.setCurrentIndex(index)
      self.xSplitModeSelectorx.blockSignals(False)
      self.changeAxisMode('x2', redraw=False)
    
    # need to counteract resetting of axis ticks when adjusting axis mode
    minX, maxX = self.minX, self.maxX
    minY, maxY = self.minY, self.maxY
    minResidY, maxResidY = self.minResidY, self.maxResidY
    minY2, maxY2 = self.minY2, self.maxY2
    minX_div, maxX_div = self.minX_div, self.maxX_div
    
    # apply tick formatting
    if(self.ticksXAuto):
      self.setAutoTicks(axis='x', redraw=False, target='plot')
      self.setAutoTicks(axis='x', redraw=False, target='resid')
    else:
      ticksXLabel = self.ticksXLabel
      self.setAxisTicks(value=self.ticksX, axis='x', redraw=False, target='plot')
      self.setAxisTicks(value=self.ticksX, axis='x', redraw=False, target='resid')
      # apply axis labels?
      self.ticksXLabel = ticksXLabel
      if(len(self.ticksXLabel)):
        for axisobject in [self.ax, self.ax_resid]:
          axisobject.xaxis.set_ticklabels(self.ticksXLabel)
    if(self.ticksXAuto_div):
      self.setAutoTicks(axis='x2', redraw=False, target='plot')
      self.setAutoTicks(axis='x2', redraw=False, target='resid')
    else:
      ticksXLabel = self.ticksXLabel_div
      self.setAxisTicks(value=self.ticksX_div, axis='x2', redraw=False, target='plot')
      self.setAxisTicks(value=self.ticksX_div, axis='x2', redraw=False, target='resid')
      # apply axis labels?
      self.ticksXLabel_div = ticksXLabel
      if(len(self.ticksXLabel_div)):
        for axisobject in [self.ax2_div, self.ax_resid_div]:
          axisobject.xaxis.set_ticklabels(self.ticksXLabel_div)
      
    if(self.ticksYAuto):
      self.setAutoTicks(axis='y', redraw=False, target='plot')
    else:
      self.setAxisTicks(value=self.ticksY, axis='y', redraw=False, target='plot')
      
    if(self.ticksYAuto):
      self.setAutoTicks(axis='resid', redraw=False, target='resid')
    else:
      self.setAxisTicks(value=self.ticksResidY, axis='resid', redraw=False, target='resid')

    if(self.ticksY2Auto):
      self.setAutoTicks(axis='y2', redraw=False, target='plot')
    else:
      self.setAxisTicks(value=self.ticksY2, axis='y2', redraw=False, target='plot')

    # retrieve settings
    self.minX, self.maxX = minX, maxX
    self.minY, self.maxY = minY, maxY
    self.minResidY, self.maxResidY = minResidY, maxResidY
    self.minY2, self.maxY2 = minY2, maxY2
    self.minX_div, self.maxX_div = minX_div, maxX_div
    
    # check wether we can go to original values specified in state
    if(self.modeX == 'linear'):
      self.minX, self.maxX = orig_minX, orig_maxX
    else:
      self.minX, self.maxX = [i if (i > 0) else j for i, j in zip([orig_minX, orig_maxX], [self.minX, self.maxX])]
    if(self.modeY == 'linear'):
      self.minY, self.maxY = orig_minY, orig_maxY
    else:
      self.minY, self.maxY = [i if (i > 0) else j for i, j in zip([orig_minY, orig_maxY], [self.minY, self.maxY])]
    if(self.modeY2 == 'linear'):
      self.minY2, self.maxY2 = orig_minY2, orig_maxY2
    else:
      self.minY2, self.maxY2 = [i if (i > 0) else j for i, j in zip([orig_minY2, orig_maxY2], [self.minY2, self.maxY2])]
    self.minResidY, self.maxResidY = orig_minResidY, orig_maxResidY
    if(self.modeX_div == 'linear'):
      self.minX_div, self.maxX_div = orig_minX_div, orig_maxX_div
    else:
      self.minX_div, self.maxX_div = [i if (i > 0) else j for i, j in zip([orig_minX_div, orig_maxX_div], [self.minX_div, self.maxX_div])]
    
    # adjust zoom level if specified
    if('zoomLevel' in settings):
      # set actual zoom level
      self.setZoomLevel(settings['zoomLevel'], redraw=False)
      # adjust selection dialog
      zoomDifference = [abs(settings['zoomLevel'] - i) for i in self.parent.zoomLevels[::-1]]
      zoomIndex = zoomDifference.index(min(zoomDifference))
      self.parent.zoomSelector.blockSignals(True)
      self.parent.zoomSelector.setCurrentIndex(zoomIndex)
      self.parent.zoomSelector.blockSignals(False)
      
    # toggle split axis
    if(self.splitAxisButton.isChecked() != self.splitShow):
      self.splitAxisButton.setChecked(self.splitShow)
      self.toggleSplit(redraw=False)
      
    # axes limits
    self.setAxisLimits(lower=self.minX, upper=self.maxX, axis='x', updateLabel=True, target='plot', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minY2, upper=self.maxY2, axis='y2', updateLabel=True, target='plot', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minY, upper=self.maxY, axis='y', updateLabel=True, target='plot', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minX, upper=self.maxX, axis='x', updateLabel=True, target='resid', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minResidY, upper=self.maxResidY, axis='y', updateLabel=True, target='resid', redraw=False, updateTicks=updateTicks, updateGrid=True)

    self.setAxisLimits(lower=self.minX_div, upper=self.maxX_div, axis='x2', updateLabel=True, target='plot', redraw=False, updateTicks=updateTicks, updateGrid=True)
    self.setAxisLimits(lower=self.minX_div, upper=self.maxX_div, axis='x2', updateLabel=True, target='resid', redraw=False, updateTicks=updateTicks, updateGrid=True)

  def incZoomLevel(self, increment=1):
    # used by mouse wheel to adjust zoom level
    currZoomIndex = self.parent.zoomSelector.currentIndex()
    # alter zoom level but restrain in bounds
    nuZoomIndex = currZoomIndex + increment
    nuZoomIndex = max(0, nuZoomIndex)
    nuZoomIndex = min(len(self.parent.zoomLevels) -1, nuZoomIndex)
    # do we need to change anything?
    if(currZoomIndex != nuZoomIndex):
      self.parent.zoomSelector.setCurrentIndex(nuZoomIndex)

  def setZoomLevel(self, zoomLevel=100, redraw=True):
    # sets zoom level of plots
    if(self.matplot.get_dpi() != zoomLevel):
      # get current size and scale factor
      scaleFactor = self.matplot.get_dpi() / zoomLevel
      currSize = self.matplot.get_size_inches()
      # change canvas DPI
      self.matplot.set_dpi(zoomLevel)
      # adjust size accordingly
      nuSize = [i * scaleFactor for i in currSize]
      self.matplot.set_size_inches(nuSize)
      self.horizontalRuler.updateRuler()
      self.verticalRuler.updateRuler()
      # issue plot refresh
      if(redraw):
        self.dataplotwidget.myRefresh()
    
    if(self.residplot.get_dpi() != zoomLevel):
      # get current size and scale factor
      scaleFactor = self.residplot.get_dpi() / zoomLevel
      currSize = self.residplot.get_size_inches()
      # change canvas DPI
      self.residplot.set_dpi(zoomLevel)
      # adjust size accordingly
      nuSize = [i * scaleFactor for i in currSize]
      self.residplot.set_size_inches(nuSize)
      self.verticalRulerResid.updateRuler()
      # issue plot refresh
      if(redraw):
        self.residplotwidget.myRefresh()

  def setTickFormatHelper(self, axis='x', redraw=True):
    # accessory function to format tick labels
    if(redraw and (axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2'])):
      if(axis in ['x', 'residx']):
        useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useFallback =\
          self.ax2, self.ticksXFormat, self.ticksXFormatPrecision, self.ticksXFormatTrailZero, self.ticksXFormatSeparator, self.fallback_ticksXFormat
        usePrefix, usePostfix = self.ticksXFormatPrefix, self.ticksXFormatPostfix
        if(axis == 'residx'):
          useAxisobject, item = self.ax_resid, 'resid'
        else:
          item = 'plot'
      elif(axis in ['x2', 'residx2']):
        useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useFallback =\
          self.ax2_div, self.ticksXFormat_div, self.ticksXFormatPrecision_div, self.ticksXFormatTrailZero_div, self.ticksXFormatSeparator_div, self.fallback_ticksXFormat_div
        usePrefix, usePostfix = self.ticksXFormatPrefix_div, self.ticksXFormatPostfix_div
        if(axis == 'residx2'):
          useAxisobject, item = self.ax_resid_div, 'resid'
        else:
          item = 'plot'
      elif(axis == 'y'):
        useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useFallback =\
          self.ax, self.ticksYFormat, self.ticksYFormatPrecision, self.ticksYFormatTrailZero, self.ticksYFormatSeparator, self.fallback_ticksYFormat
        usePrefix, usePostfix = self.ticksYFormatPrefix, self.ticksYFormatPostfix
        item = 'plot'
      elif(axis == 'y2'):
        useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useFallback =\
          self.ax2, self.ticksY2Format, self.ticksY2FormatPrecision, self.ticksY2FormatTrailZero, self.ticksY2FormatSeparator, self.fallback_ticksY2Format
        usePrefix, usePostfix = self.ticksY2FormatPrefix, self.ticksY2FormatPostfix
        item = 'plot'
      elif(axis == 'resid'):
        useAxisobject, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, useFallback =\
          self.ax_resid, self.ticksResidYFormat, self.ticksResidYFormatPrecision, self.ticksResidYFormatTrailZero, self.ticksResidYFormatSeparator, self.fallback_ticksResidYFormat
        usePrefix, usePostfix = self.ticksResidYFormatPrefix, self.ticksResidYFormatPostfix
        item = 'resid'
      else:
        useTicksFormat = 'tilt'
        item = 'none'
      
      if(item in ['plot', 'resid']):
        # now apply the altered tick formatting
        # this should be easy as long as we turn on custom formatting
        if(useTicksFormat != 'default'):
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, useTicksFormat, useTicksFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, usePrefix, usePostfix))
        elif(useFallback != None):
          autolabels = useFallback
        else:
          # scalar formatter should be safe (except when using data ticks but then fallback should exist)
          autolabels = matplotlib.ticker.ScalarFormatter()
        if(axis in ['x', 'x2', 'residx', 'residx2']):
          useAxisobject.xaxis.set_major_formatter(autolabels)
        else:
          useAxisobject.yaxis.set_major_formatter(autolabels)
        
        # issue plot redraw
        if(item == 'plot'):
          self.dataplotwidget.myRefresh()
        else:
          self.residplotwidget.myRefresh()    

  def setTickFormatPrecision(self, axis='x', value=2, redraw=True):
    # changes precision in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormatPrecision) or (axis == 'residx')):
          self.ticksXFormatPrecision, useTicksFormat = value, self.ticksXFormat
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormatPrecision_div) or (axis == 'residx2')):
          self.ticksXFormatPrecision_div, useTicksFormat = value, self.ticksXFormat_div
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormatPrecision):
          self.ticksYFormatPrecision, useTicksFormat = value, self.ticksYFormat
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2FormatPrecision):
          self.ticksY2FormatPrecision, useTicksFormat = value, self.ticksY2Format
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormatPrecision):
          self.ticksResidYFormatPrecision, useTicksFormat = value, self.ticksResidYFormat
        else:
          redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat == 'default'):
        redraw = False

      if(redraw):
        self.setTickFormatHelper(axis=axis, redraw=redraw)
          
  def setTickFormat(self, axis='x', value='float', redraw=True):
    # changes type of custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormat) or (axis == 'residx')):
          self.ticksXFormat = value
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormat_div) or (axis == 'residx2')):
          self.ticksXFormat_div = value
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormat):
          self.ticksYFormat = value
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2Format):
          self.ticksY2Format = value
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormat):
          self.ticksResidYFormat = value
        else:
          redraw = False
      else:
        redraw = False

      if(redraw):
        self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setFormatTrailZero(self, axis='x', value=True, redraw=True):
    # set trailing zeros of tick labels in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormatTrailZero) or (axis == 'residx')):
          self.ticksXFormatTrailZero, useTicksFormat = value, self.ticksXFormat
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormatTrailZero_div) or (axis == 'residx2')):
          self.ticksXFormatTrailZero_div, useTicksFormat = value, self.ticksXFormat_div
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormatTrailZero):
          self.ticksYFormatTrailZero, useTicksFormat = value, self.ticksYFormat
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2FormatTrailZero):
          self.ticksY2FormatTrailZero, useTicksFormat = value, self.ticksY2Format
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormatTrailZero):
          self.ticksResidYFormatTrailZero, useTicksFormat = value, self.ticksResidYFormat
        else:
          redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat == 'default'):
        redraw = False

      if(redraw):
        self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setFormatSeparator(self, axis='x', value=True, redraw=True):
    # set separate 1000s of tick labels in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if((value != self.ticksXFormatSeparator) or (axis == 'residx')):
          self.ticksXFormatSeparator, useTicksFormat = value, self.ticksXFormat
        else:
          redraw = False
      elif(axis in ['x2', 'residx2']):
        if((value != self.ticksXFormatSeparator_div) or (axis == 'residx2')):
          self.ticksXFormatSeparator_div, useTicksFormat = value, self.ticksXFormat_div
        else:
          redraw = False
      elif(axis == 'y'):
        if(value != self.ticksYFormatSeparator):
          self.ticksYFormatSeparator, useTicksFormat = value, self.ticksYFormat
        else:
          redraw = False
      elif(axis == 'y2'):
        if(value != self.ticksY2FormatSeparator):
          self.ticksY2FormatSeparator, useTicksFormat = value, self.ticksY2Format
        else:
          redraw = False
      elif(axis == 'resid'):
        if(value != self.ticksResidYFormatSeparator):
          self.ticksResidYFormatSeparator, useTicksFormat = value, self.ticksResidYFormat
        else:
          redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat != 'float'):
        redraw = False

      if(redraw):
        self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setFormatFix(self, axis='x', value=True, redraw=True, prefix=True):
    # sets pre/postfix of tick labels in custom tick label formatting
    if(axis in ['x', 'y', 'y2', 'resid', 'x2', 'residx', 'residx2']):
      useTicksFormat = 'default'
      if(axis in ['x', 'residx']):
        # always update and redraw for resid plot unless you implement a better check
        if(prefix):
          if((value != self.ticksXFormatPrefix) or (axis == 'residx')):
            self.ticksXFormatPrefix, useTicksFormat = value, self.ticksXFormat
          else:
            redraw = False
        else:
          if((value != self.ticksXFormatPostfix) or (axis == 'residx')):
            self.ticksXFormatPostfix, useTicksFormat = value, self.ticksXFormat
          else:
            redraw = False
      elif(axis in ['x2', 'residx2']):
        if(prefix):
          if((value != self.ticksXFormatPrefix_div) or (axis == 'residx2')):
            self.ticksXFormatPrefix_div, useTicksFormat = value, self.ticksXFormat_div
          else:
            redraw = False
        else:
          if((value != self.ticksXFormatPostfix_div) or (axis == 'residx2')):
            self.ticksXFormatPostfix_div, useTicksFormat = value, self.ticksXFormat_div
          else:
            redraw = False
      elif(axis == 'y'):
        if(prefix):
          if(value != self.ticksYFormatPrefix):
            self.ticksYFormatPrefix, useTicksFormat = value, self.ticksYFormat
          else:
            redraw = False
        else:
          if(value != self.ticksYFormatPostfix):
            self.ticksYFormatPostfix, useTicksFormat = value, self.ticksYFormat
          else:
            redraw = False
      elif(axis == 'y2'):
        if(prefix):
          if(value != self.ticksY2FormatPrefix):
            self.ticksY2FormatPrefix, useTicksFormat = value, self.ticksY2Format
          else:
            redraw = False
        else:
          if(value != self.ticksY2FormatPostfix):
            self.ticksY2FormatPostfix, useTicksFormat = value, self.ticksY2Format
          else:
            redraw = False
      elif(axis == 'resid'):
        if(prefix):
          if(value != self.ticksResidYFormatPrefix):
            self.ticksResidYFormatPrefix, useTicksFormat = value, self.ticksResidYFormat
          else:
            redraw = False
        else:
          if(value != self.ticksResidYFormatPostfix):
            self.ticksResidYFormatPostfix, useTicksFormat = value, self.ticksResidYFormat
          else:
            redraw = False
      else:
        redraw = False

      # don't redraw when in default mode as changes won't be visible anyhow
      if(useTicksFormat == 'default'):
        redraw = False

      if(redraw):
        self.setTickFormatHelper(axis=axis, redraw=redraw)

  def setInnerParameter(self, param='axes', state=True, redraw=True):
    # changes parameters for display of items at split axis interface
    if(param in ['axes', 'ticks']):
      if(param == 'axes'):
        self.innerAxes = state
      else:
        self.innerTicks = state
        
      # apply these settings
      self.updateInnerSituation()

      # issue plot refreshs
      if(redraw):
        self.dataplotwidget.myRefresh()
        self.residplotwidget.myRefresh()

  def updateInnerSituation(self):
    # updates graphic items at interface between split axes
    # do this only when split is activated as otherwise right axis and tick marks will be messed up
    if(self.splitShow):
      secondAxes = self.isSecondAxesActive()
      if(self.innerAxes):
        self.ax.spines['right'].set_visible(self.innerAxes and self.axisVisible['right'])
        self.ax_div.spines['left'].set_visible(self.innerAxes and self.axisVisible['left'])
        self.ax_resid.spines['right'].set_visible(self.innerAxes and self.axisVisible['right'])
        self.ax_resid_div.spines['left'].set_visible(self.innerAxes and self.axisVisible['left'])
        if(secondAxes):
          self.ax2.spines['right'].set_visible(self.innerAxes and self.axisVisible['right2'])
          self.ax2_div.spines['left'].set_visible(self.innerAxes and self.axisVisible['left2'])
      else:
        self.ax.spines['right'].set_visible(False)
        self.ax_div.spines['left'].set_visible(False)
        self.ax_resid.spines['right'].set_visible(False)
        self.ax_resid_div.spines['left'].set_visible(False)
        if(secondAxes):
          self.ax2.spines['right'].set_visible(False)
          self.ax2_div.spines['left'].set_visible(False)
      
      # now deal with ticks
      if(self.ticksVisible['right']):
        if(self.ticksVisible['left']):
          if(self.innerTicks):
            where = 'both'
            where2 = 'both'
            #where2 = 'left'
          else:
            where = 'left'
            where2 = 'right'
            #where2 = 'none'
        else:
          if(self.innerTicks):
            where = 'right'
          else:
            where = 'none'
          where2 = 'right'
          #where2 = 'none'
      else:
        if(self.ticksVisible['left']):
          where = 'left'
          if(self.innerTicks):
            where2 = 'left'
          else:
            where2 = 'none'
        else:
          where = 'none'
          where2 = 'none'
  
      # apply this
      if(where == 'none'):
        self.ax.yaxis.set_ticks_position('left')
        self.ax_div.yaxis.set_ticks_position('left')
        self.ax_resid.yaxis.set_ticks_position('left')
        self.ax_resid_div.yaxis.set_ticks_position('left')
      self.ax.yaxis.set_ticks_position(where)
      self.ax_div.yaxis.set_ticks_position(where2)
      self.ax_resid.yaxis.set_ticks_position(where)
      self.ax_resid_div.yaxis.set_ticks_position(where2)
  
      # ensure that no tick labels displayed on self.ax_div nor on self.ax_resid_div
      tickLabels = self.ax_div.get_yticklabels(which='both')
      tickLabels.append(self.ax_div.yaxis.get_offset_text())
      tickLabels.extend(self.ax_resid_div.get_yticklabels(which='both'))
      tickLabels.append(self.ax_resid_div.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_visible(False)    
  
      # now do the same for second axes
      if(secondAxes):
        if(self.ticksVisible['right2']):
          if(self.ticksVisible['left2']):
            if(self.innerTicks):
              where = 'both'
              where2 = 'both'
              #where2 = 'left'
            else:
              where = 'left'
              where2 = 'right'
              #where2 = 'none'
          else:
            if(self.innerTicks):
              where = 'right'
            else:
              where = 'none'
            where2 = 'right'
            #where2 = 'none'
        else:
          if(self.ticksVisible['left2']):
            where = 'left'
            if(self.innerTicks):
              where2 = 'left'
            else:
              where2 = 'none'
          else:
            where = 'none'
            where2 = 'none'
    
        # apply this
        if(where == 'none'):
          self.ax2.yaxis.set_ticks_position('right')
          self.ax2_div.yaxis.set_ticks_position('right')
        self.ax2.yaxis.set_ticks_position(where)
        self.ax2_div.yaxis.set_ticks_position(where2)
    
        # ensure that no tick labels displayed on self.ax2_div
        tickLabels = self.ax2_div.get_yticklabels(which='both')
        tickLabels.append(self.ax2_div.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_visible(False)    

  def setZOrderResidLine(self, zorder=0, redraw=True):
    # updates z order of residuals
    if(self.zorderResidLine != zorder):
      self.zorderResidLine = zorder
      # update plot if necessary
      plotUpdate = False
      if(self.handleResidZero != None):
        self.handleResidZero.set_zorder(self.zorderResidLine + self.parent.zOffset)
        plotUpdate = True
        self.rememberSettingResidLine['zorder'] = 'set_zorder(' + repr(self.zorderResidLine + self.parent.zOffset) + ')'
      if(self.handleResidZero_div != None):
        self.handleResidZero_div.set_zorder(self.zorderResidLine + self.parent.zOffset)
        plotUpdate = True

      # update plot
      if(redraw and plotUpdate):
        self.residplotwidget.myRefresh()

  def setVisibilityResidLine(self, state=True, redraw=True):
    # toggles visibility of residual zero line
    if(self.visibilityResidLine != state):
      self.visibilityResidLine = state
      # update plot if necessary
      plotUpdate = False
      if(self.handleResidZero != None):
        self.handleResidZero.set_visible(state)
        plotUpdate = True
        self.rememberSettingResidLine['visibility'] = 'set_visible(' + repr(state) + ')'
      if(self.handleResidZero_div != None):
        self.handleResidZero_div.set_visible(state)
        plotUpdate = True

      # update plot
      if(redraw and plotUpdate):
        self.residplotwidget.myRefresh()

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def legendHelper(self, axisobject=None):
    # helper function called by legend formatters
    if(axisobject == None):
      axisobject = self.ax
    
    # build axis legend objects
    items = []
    for entry in self.parent.data:
      if((entry.handleData != None) and (entry.visibility)):
        # manually process escape characters
        name = entry.name.replace('\n', '\\n')
        name = name.replace('\t', '\\t')
        name = '\n'.join([i for i in name.split('\\n') if (len(i.strip()))])
        name = '\t'.join([i for i in name.split('\\t') if (len(i.strip()))])
        # test for potential Mathttext errors by creating a dummy text label
        tempText = axisobject.text(1, 1, name)
        try:
          tempText._get_layout(self.matplot.canvas.renderer)
        except:
          # some kind of problem with item label
          self.parent.statusbar.showMessage('Problems with data set label ' + name, self.parent.STATUS_TIME)
          name = name.replace('$', '')
        tempText.remove()
        if(not name.startswith('_')):
          if((entry.handleData != None) and ((not entry.style['marker'] in ['None', None, '', ' ']) or (entry.style['linestyle'] != 'None'))):
            useHandle = entry.handleData
          elif((entry.handleBar != None) and entry.Barstyle['showBar']):
            useHandle = entry.handleBar
          elif((entry.handleStack != None) and entry.Stackstyle['showStack']):
            useHandle = entry.handleStack
          else:
            useHandle = entry.handleData
          items.append([useHandle, name, entry.zorder])
    for entry in self.parent.fit:
      if((entry.handlePlot != None) and (entry.visibility)):
        # manually process escape characters
        name = entry.name.replace('\n', '\\n')
        name = name.replace('\t', '\\t')
        name = '\n'.join([i for i in name.split('\\n') if (len(i.strip()))])
        name = '\t'.join([i for i in name.split('\\t') if (len(i.strip()))])
        # test for potential Mathttext errors by creating a dummy text label
        tempText = axisobject.text(1, 1, name)
        try:
          tempText._get_layout(self.matplot.canvas.renderer)
        except:
          # some kind of problem with item label
          self.parent.statusbar.showMessage('Problems with curve label ' + name, self.parent.STATUS_TIME)
          name = name.replace('$', '')
        tempText.remove()
        if(not name.startswith('_')):
          items.append([entry.handlePlot, name, entry.zorder])
    # order according to zorder
    items = sorted(items, key=lambda k: k[2])
    handles = [i[0] for i in items]
    labels = [i[1] for i in items]
    
    # have to discriminate for Linux and Mac b/c markerfirst is unknown
    if(platform in ['linux', 'darwin']):
      self.legendHandle = axisobject.legend(handles, labels, loc=self.legendPlacement, shadow=self.legendShadow,\
        numpoints=self.legendNumPoints, ncol=self.legendNumCol, markerscale=self.legendMarkerScale,\
        borderpad=self.legendBorderPad, labelspacing=self.legendLabelSpacing, columnspacing=self.legendColumnSpacing,\
        handlelength=2.0 * self.legendMarkerScale)
    else:
      self.legendHandle = axisobject.legend(handles, labels, loc=self.legendPlacement, shadow=self.legendShadow,\
        numpoints=self.legendNumPoints, markerfirst=self.legendMarkerFirst, ncol=self.legendNumCol, markerscale=self.legendMarkerScale,\
        borderpad=self.legendBorderPad, labelspacing=self.legendLabelSpacing, columnspacing=self.legendColumnSpacing,\
        handlelength=2.0 * self.legendMarkerScale)
    
    if(self.legendHandle != None):
      # go via frame properties for enhanced controls
      frame = self.legendHandle.get_frame()
      if(frame != None):
        frame.set_linewidth(self.legendEdgeWidth)
        frame.set_edgecolor(self.legendColor['edge'])
        if(self.legendFill):
          frame.set_facecolor(self.legendColor['face'])
        else:
          frame.set_facecolor('none')
        frame.set_alpha(self.legendColor['face'][-1])
      
      # set text properties
      texts = self.legendHandle.texts
      for entry in texts:
        entry.set_color(self.legendLabelColor)
        entry.set_fontsize(self.legendLabelSize)
        entry.set_fontweight(self.legendLabelWeight)
        entry.set_fontstyle(self.legendLabelStyle)
        entry.set_fontname(self.legendLabelFont)
        
      # set z-order to display in front (note that aboutLogo is at 1000)
      self.legendHandle.set_zorder(999)
      
      # and now remember all this
      axisname = 'ax'
      if(self.isSecondAxesActive()):
        self.rememberSetting['legend'] = 'collateHandles = [i[\'handle\'] for i in (dataset + curves)]\n'
        self.rememberSetting['legend'] += 'collateLabels = [i[\'handle\'].get_label() for i in (dataset + curves)]\n'
        self.rememberSetting['legend'] += 'handleLegend = ' + axisname + '.legend(collateHandles, collateLabels, loc=' + repr(self.legendPlacement) + ', shadow=' + repr(self.legendShadow)
      else:
        self.rememberSetting['legend'] = 'handleLegend = ' + axisname + '.legend(loc=' + repr(self.legendPlacement) + ', shadow=' + repr(self.legendShadow)
      if(platform in ['linux', 'darwin']):
        self.rememberSetting['legend'] += ', numpoints=' + repr(self.legendNumPoints)
      else:
        self.rememberSetting['legend'] += ', numpoints=' + repr(self.legendNumPoints) + ', markerfirst=' + repr(self.legendMarkerFirst)
      self.rememberSetting['legend'] += ', ncol=' + repr(self.legendNumCol) + ', markerscale=' + repr(self.legendMarkerScale)  + ', borderpad=' + repr(self.legendBorderPad)
      self.rememberSetting['legend'] +=  ', labelspacing=' + repr(self.legendLabelSpacing) + ', columnspacing=' + repr(self.legendColumnSpacing) + ')\n'
      self.rememberSetting['legend'] += 'if(handleLegend != None):\n'
      self.rememberSetting['legend'] += '\tframe = handleLegend.get_frame()\n'
      self.rememberSetting['legend'] += '\tif(frame != None):\n'
      self.rememberSetting['legend'] += '\t\tframe.set_linewidth(' + repr(self.legendEdgeWidth) + ')\n'
      self.rememberSetting['legend'] += '\t\tframe.set_edgecolor(' + repr(self.legendColor['edge']) + ')\n'
      self.rememberSetting['legend'] += '\t\tframe.set_facecolor(' + repr(self.legendColor['face']) + ')\n'
      self.rememberSetting['legend'] += '\t\tframe.set_alpha(' + repr(self.legendColor['face'][-1]) + ')\n'
      self.rememberSetting['legend'] += '\ttexts = handleLegend.texts\n'
      self.rememberSetting['legend'] += '\tfor entry in texts:\n'
      self.rememberSetting['legend'] += '\t\tentry.set_color(' + repr(self.legendLabelColor) + ')\n'
      self.rememberSetting['legend'] += '\t\tentry.set_fontsize(' + repr(self.legendLabelSize) + ')\n'
      self.rememberSetting['legend'] += '\t\tentry.set_fontweight(' + repr(self.legendLabelWeight) + ')\n'
      self.rememberSetting['legend'] += '\t\tentry.set_fontstyle(' + repr(self.legendLabelStyle) + ')\n'
      self.rememberSetting['legend'] += '\t\tentry.set_fontname(' + repr(self.legendLabelFont) + ')\n'
      self.rememberSetting['legend'] += '\thandleLegend.set_zorder(' + repr(999) + ')\n'

  def toggleLegendFill(self, value=True, redraw=True, target='plot'):
    # toggles whether legend is filled or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      # sets canvas color
      if(self.legendFill == value):
        redraw = False

      self.legendFill = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendMarkerFirst(self, value=True, redraw=True, target='plot'):
    # sets marker location in legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendMarkerFirst == value):
        redraw = False
        
      self.legendMarkerFirst= value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendMarkerScale(self, value=1.0, redraw=True, target='plot'):
    # sets marker scale in legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendMarkerScale == value):
        redraw = False
        
      self.legendMarkerScale = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendNCol(self, value=1, redraw=True, target='plot'):
    # sets number of columns in legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendNumCol == value):
        redraw = False
        
      self.legendNumCol = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendMarkerNumPoints(self, value=1, redraw=True, target='plot'):
    # sets number of marker points in legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendNumPoints == value):
        redraw = False
        
      self.legendNumPoints = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()
          
  def setLegendPlacement(self, value='best', redraw=True, target='plot'):
    # sets placement of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendPlacement == value):
        redraw = False
        
      self.legendPlacement = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendShadow(self, value=False, redraw=True, target='plot'):
    # sets placement of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      if(self.legendShadow == value):
        redraw = False
        
      self.legendShadow = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegend(self, value=True, redraw=True, target='plot'):
    # sets legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
      
      self.legendVisible = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
      else:
        legend = axisobject.legend()
        if(legend != None):
          legend.remove()
        if('legend' in self.rememberSetting):
          del self.rememberSetting['legend']
      
      if(redraw):
        plotobject.myRefresh()

  def setLegendColor(self, value=[0.5, 0.5, 0.5, 0.5], prop='face', redraw=True, target='plot'):
    # sets color of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
    else:
      prop = 'abort'

    # update color
    if(prop in ['face', 'edge']):
      if(self.legendColor[prop] == value):
        redraw=False
      if((prop == 'face') and (not self.legendFill)):
        redraw = False
        
      self.legendColor[prop] = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelColor(self, value=[0.5, 0.5, 0.5, 0.5], redraw=True, target='plot'):
    # sets color of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # update color
      if(self.legendLabelColor == value):
        redraw = False
        
      self.legendLabelColor = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelBold(self, value='normal', redraw=True, target='plot'):
    # sets formatting of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # update color
      if(self.legendLabelWeight == value):
        redraw = False
        
      self.legendLabelWeight = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelItalic(self, value='normal', redraw=True, target='plot'):
    # sets formatting of legend
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # update color
      if(self.legendLabelStyle == value):
        redraw = False
        
      self.legendLabelStyle = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendEdgeWidth(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendEdgeWidth == value):
        redraw = False
        
      self.legendEdgeWidth = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendPadBorder(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendBorderPad == value):
        redraw = False
        
      self.legendBorderPad = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendPadRow(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendLabelSpacing == value):
        redraw = False
        
      self.legendLabelSpacing = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendPadCol(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendColumnSpacing == value):
        redraw = False
        
      self.legendColumnSpacing = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelSize(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      if(self.legendLabelSize == value):
        redraw = False
        
      self.legendLabelSize = value
      if(self.legendVisible):
        self.legendHelper(axisobject)
        if(redraw):
          plotobject.myRefresh()

  def setLegendLabelFont(self, value='DejaVu Sans', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid

      # sets legend edge width
      prevFont = self.legendLabelFont
      if(self.legendLabelFont == value):
        redraw = False
        
      self.legendLabelFont = value
      self.legendHelper(axisobject)
      
      # have to capture errors in case a strange font is set
      try:
        if(redraw):
          plotobject.myRefresh()
      except:
        self.parent.statusbar.showMessage('Experiencing problems setting font ' + self.legendLabelFont + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)

        self.legendLabelFont = prevFont
        self.legendHelper(axisobject)
        # also capture errors with previous font (can happen if selecting two bad fonts in a row)
        try:
          if(redraw):
            plotobject.myRefresh()
        except:
          safeFont = 'DejaVu Sans'
          self.parent.statusbar.showMessage('Also experiencing problems setting font ' + self.legendLabelFont + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.legendLabelFont = safeFont
          self.legendHelper(axisobject)

  def setDataAxisTicks(self, dataSet=0, redraw=True, target='plot', splitX=False):
    # set x ticks to label values
    useData, roles = self.parent.data[dataSet].getData_n_Fit()
    if('x' in roles):
      xcol = roles.index('x')
      xval = list(useData[:, xcol])
      labels = list(self.parent.data[self.parent.activeData].getLabels())
      minLength = np.min((len(xval), len(labels)))
      if(minLength):
        # we have some labels to place
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(splitX):
            axisobject, useModeX, useMinX, useMaxX, useTicksXMinor = self.ax2_div, self.modeX_div, self.minX_div, self.maxX_div, self.ticksXMinor_div
          else:
            axisobject, useModeX, useMinX, useMaxX, useTicksXMinor = self.ax2, self.modeX, self.minX, self.maxX, self.ticksXMinor
        else:
          plotobject = self.residplotwidget
          if(splitX):
            axisobject, useModeX, useMinX, useMaxX, useTicksXMinor = self.ax_resid_div, self.modeX_div, self.minX_div, self.maxX_div, self.ticksXMinor_div
          else:
            axisobject, useModeX, useMinX, useMaxX, useTicksXMinor = self.ax_resid, self.modeX, self.minX, self.maxX, self.ticksXMinor

        flag = False
        labels = labels[:minLength]; xval = xval[:minLength]

        # manually process labels for escape characters
        for index, entry in enumerate(labels):
          name = entry.replace('\n', '\\n')
          name = name.replace('\t', '\\t')
          name = '\n'.join([i for i in name.split('\\n') if (len(i.strip()))])
          name = '\t'.join([i for i in name.split('\\t') if (len(i.strip()))])
          labels[index] = name
        
        # first set new ticks
        axisobject.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(xval))
        ###if(useModeX == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          axisobject.xaxis.set_minor_locator(minorAutoticks)
          axisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        lower, upper = useMinX, useMaxX
        if(len(xval)):
          # check for empty list
          if(np.min(xval)<np.min((useMinX, useMaxX))):
            flag = True
            lower = np.min(xval)
          if(np.max(xval)>np.max((useMinX, useMaxX))):
            flag = True
            upper = np.max(xval)
          # special treatment for resid plot
          if(target == 'resid'):
            flag = True
            
        # now set new tick labels
        axisobject.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(labels))
        
        # store settings
        if(splitX):
          self.ticksX_div, self.ticksXLabel_div, self.ticksXAuto_div = xval, labels, False
        else:
          self.ticksX, self.ticksXLabel, self.ticksXAuto = xval, labels, False
          self.rememberSetting['ax_tickX'] = 'ax2.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(xval)) + '))\n'
          self.rememberSetting['ax_tickX'] += 'ax2.xaxis.set_major_formatter(matplotlib.ticker.FixedFormatter(' + repr(list(labels)) + '))\n'

        # check whether the new ticks necessitate axis rescaling
        if(flag):
          if(splitX):
            self.setAxisLimits(lower=lower, upper=upper, axis='x2', updateLabel=True, target=target, redraw=False, updateGrid=True)
            if(target == 'plot'):
              # and we should redraw the fit function to cover new x-range
              self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
                fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
                redraw=redraw, splitX=splitX)
            else:
              # and we should update the resid plot (as x-axis will most likely have rescaled)
              self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero_div, redraw=redraw, splitX=splitX)
          else:
            self.setAxisLimits(lower=lower, upper=upper, axis='x', updateLabel=True, target=target, redraw=False, updateGrid=True)
            if(target == 'plot'):
              # and we should redraw the fit function to cover new x-range
              self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
                fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
                redraw=redraw)
            else:
              # and we should update the resid plot (as x-axis will most likely have rescaled)
              self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero, redraw=redraw)
        else:
          # update axis grid lines
          if(self.gridVisible['x']):
            self.drawAxisGrid(axis='x', redraw=False, target=target)
        
          if(redraw):
            plotobject.myRefresh()
      else:
        self.parent.statusbar.showMessage('Data set ' + str(dataSet) + ' contains no labels!', self.parent.STATUS_TIME)
    else:
      self.parent.statusbar.showMessage('Current data set ' + str(dataSet) + ' is empty!', self.parent.STATUS_TIME)

  def myFormatterFunction(self, mode='float', precision=2, trailZero=True, separator=True, prefix='', postfix='', x=0, pos=None):
    # a custom formatter function
    prefix, postfix = prefix.replace('\\', '\\\\'), postfix.replace('\\', '\\\\')
    prefix, postfix = prefix.replace('$', '\$'), postfix.replace('$', '\$')
    if(mode == 'float'):
      # for float formatting consider separator for 1000s (by contrast, not relevant for scientific/mathdefault)
      if(separator):
        formatstr = '{:,.' + str(precision) + 'f}'
      else:
        formatstr = '{:.' + str(precision) + 'f}'
      formatstr = formatstr.format(x)
      # test at level of output string, as is_integer() runs into problems with precision of floats
      if((not trailZero) and ('.' in formatstr)):
        while(formatstr.endswith('0')):
          formatstr = formatstr[:-1]
        if(formatstr.endswith('.')):
          formatstr = formatstr[:-1]
      formatstr = '$\\mathdefault{' + formatstr + '}$'
      return prefix + formatstr + postfix
    elif(mode == 'scientific'):
      formatstr = '{:.' + str(precision) + 'e}'
      formatstr = formatstr.format(x)
      if(not trailZero):
        if('e' in formatstr.lower()):
          eString = formatstr[formatstr.lower().find('e')]
          preString, exponentString = formatstr.split(eString)
          while(preString.endswith('0')):
            preString = preString[:-1]
          if(preString.endswith('.')):
            preString = preString[:-1]
          formatstr = preString + eString + exponentString
      formatstr = '$\\mathdefault{' + formatstr + '}$'
      return prefix + formatstr + postfix
    elif(mode == 'mathtext'):
      # calculate exponent
      if(x != 0.0):
        try:
          exponent = int(np.floor(np.log10(np.abs(x))))
        except:
          exponent = 0
        # calculate preexponent
        try:
          pre = x / (10 ** exponent)
        except:
          pre, exponent = x, 0
      # assemble string
      if(x == 0.0):
        retstr = '{:.' + str(precision) + 'f}'
        retstr = retstr.format(0.0)
        if(not trailZero):
          retstr = '0'
        retstr = '$\\mathdefault{' + retstr + '}$' 
      elif(np.isclose(pre, 1.0)):
        retstr = '$\\mathdefault{10^{' + str(exponent) + '}}$'
      elif(np.isclose(pre, -1.0)):
        retstr = '$\\mathdefault{-10^{' + str(exponent) + '}}$'
      else:
        retstr = '{:.' + str(precision) + 'f}'
        retstr = retstr.format(pre)
        # testing with is_integer() struggles with float precision - test directly at level of string
        #if((not trailZero) and pre.is_integer()):
        if((not trailZero) and precision):
          front, trail = retstr.split('.')
          if(trail == ('0' * precision)):
            retstr = front
        # should not use \times here as some fonts don't possess this symbol
        retstr = '$\\mathdefault{' + retstr + '\ x\ 10^{' + str(exponent) + '}}$' 
      # return value
      return prefix + retstr + postfix
    else:
      return str(x)

  def setAutoTicks(self, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
    else:
      axis = 'abort'
    # automatically sets axis ticks
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis in ['x', 'x2']):
        if(axis == 'x'):
          useModeX, useAxisobject, useTicksXFormat, useTicksXFormatPrecision, useTicksXMinor, useTicksFormatTrailZero, useTicksFormatSeparator =\
            self.modeX, axisobject, self.ticksXFormat, self.ticksXFormatPrecision, self.ticksXMinor, self.ticksXFormatTrailZero, self.ticksXFormatSeparator
          usePrefix, usePostfix = self.ticksXFormatPrefix, self.ticksXFormatPostfix
        else:
          useModeX, useAxisobject, useTicksXFormat, useTicksXFormatPrecision, useTicksXMinor, useTicksFormatTrailZero, useTicksFormatSeparator =\
            self.modeX_div, axisobject2, self.ticksXFormat_div, self.ticksXFormatPrecision_div, self.ticksXMinor_div, self.ticksXFormatTrailZero_div, self.ticksXFormatSeparator_div
          usePrefix, usePostfix = self.ticksXFormatPrefix_div, self.ticksXFormatPostfix_div

        if(useModeX == 'linear'):
          autoticks = matplotlib.ticker.AutoLocator()
          autolabels = matplotlib.ticker.ScalarFormatter()
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          useAxisobject.xaxis.set_minor_locator(minorAutoticks)
          useAxisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        else:
          autoticks = matplotlib.ticker.LogLocator()
          if(platform in ['linux', 'darwin']):
            autolabels = matplotlib.ticker.ScalarFormatter()
          else:
            autolabels = matplotlib.ticker.LogFormatterSciNotation()
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          useAxisobject.xaxis.set_minor_locator(minorAutoticks)
          useAxisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # apply custom formatting?
        if(useTicksXFormat != 'default'):
          # store fallback
          if(axis == 'x'):
            self.fallback_ticksXFormat = autolabels
          else:
            self.fallback_ticksXFormat_div = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, useTicksXFormat, useTicksXFormatPrecision, useTicksFormatTrailZero, useTicksFormatSeparator, usePrefix, usePostfix))
        useAxisobject.xaxis.set_major_locator(autoticks)
        useAxisobject.xaxis.set_major_formatter(autolabels)

        # store information
        if(axis == 'x'):
          self.ticksX = self.getAxisTicks(axis)
          nuticks = self.ticksX
          # clear labels
          self.ticksXLabel, self.ticksXAuto = [], True
        else:
          self.ticksX_div = self.getAxisTicks(axis)
          nuticks = self.ticksX_div
          # clear labels
          self.ticksXLabel_div, self.ticksXAuto_div = [], True
      elif(axis == 'y'):
        axisobject = self.ax; axisobject2 = self.ax_div
        for useAxisobject in [axisobject, axisobject2]:
          if(self.modeY == 'linear'):
            autoticks = matplotlib.ticker.AutoLocator()
            autolabels = matplotlib.ticker.ScalarFormatter()
            minorAutoticks = MyAutoMinorLocator(self.ticksYMinor)
            useAxisobject.yaxis.set_minor_locator(minorAutoticks)
            useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          else:
            autoticks = matplotlib.ticker.LogLocator()
            if(platform in ['linux', 'darwin']):
              autolabels = matplotlib.ticker.ScalarFormatter()
            else:
              autolabels = matplotlib.ticker.LogFormatterSciNotation()
            minorAutoticks = MyAutoMinorLocator(self.ticksYMinor)
            useAxisobject.yaxis.set_minor_locator(minorAutoticks)
            useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          # apply custom formatting?
          if(self.ticksYFormat != 'default'):
            # store fallback
            self.fallback_ticksYFormat = autolabels
            autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksYFormat, self.ticksYFormatPrecision, self.ticksYFormatTrailZero, self.ticksYFormatSeparator, self.ticksYFormatPrefix, self.ticksYFormatPostfix))
          useAxisobject.yaxis.set_major_locator(autoticks)
          useAxisobject.yaxis.set_major_formatter(autolabels)
        # store information
        self.ticksY = self.getAxisTicks(axis)
        nuticks = self.ticksY
        self.ticksYAuto = True
      elif(axis == 'y2'):
        for useAxisobject in [axisobject, axisobject2]:
          if(self.modeY2 == 'linear'):
            autoticks = matplotlib.ticker.AutoLocator()
            autolabels = matplotlib.ticker.ScalarFormatter()
            minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor)
            useAxisobject.yaxis.set_minor_locator(minorAutoticks)
            useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          else:
            autoticks = matplotlib.ticker.LogLocator()
            if(platform in ['linux', 'darwin']):
              autolabels = matplotlib.ticker.ScalarFormatter()
            else:
              autolabels = matplotlib.ticker.LogFormatterSciNotation()
            minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor)
            useAxisobject.yaxis.set_minor_locator(minorAutoticks)
            useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          # apply custom formatting?
          if(self.ticksY2Format != 'default'):
            # store fallback
            self.fallback_ticksY2Format = autolabels
            autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksY2Format, self.ticksY2FormatPrecision, self.ticksY2FormatTrailZero, self.ticksY2FormatSeparator, self.ticksY2FormatPrefix, self.ticksY2FormatPostfix))
          useAxisobject.yaxis.set_major_locator(autoticks)
          useAxisobject.yaxis.set_major_formatter(autolabels)
        # store information
        self.ticksY2 = self.getAxisTicks(axis)
        nuticks = self.ticksY2
        self.ticksY2Auto = True
      else:
        for useAxisobject in [axisobject, axisobject2]:
          autoticks = matplotlib.ticker.AutoLocator()
          autolabels = matplotlib.ticker.ScalarFormatter()
          # apply custom formatting?
          if(self.ticksResidYFormat != 'default'):
            # store fallback
            self.fallback_ticksResidYFormat = autolabels
            autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksResidYFormat, self.ticksResidYFormatPrecision, self.ticksResidYFormatTrailZero, self.ticksResidYFormatSeparator, self.ticksResidYFormatPrefix, self.ticksResidYFormatPostfix))
          minorAutoticks = MyAutoMinorLocator(self.ticksResidYMinor)
          useAxisobject.yaxis.set_major_locator(autoticks)
          useAxisobject.yaxis.set_minor_locator(minorAutoticks)
          useAxisobject.yaxis.set_major_formatter(autolabels)
          useAxisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store information
        self.ticksResidY = self.getAxisTicks(axis)
        nuticks = self.ticksResidY
        self.ticksResidYAuto = True

      # update axis grid lines
      if(axis == 'resid'):
        item = 'y'
      else:
        item = axis
      if(self.gridVisible[item]):
        if((item != 'y2') or self.isSecondAxesActive()):
          self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      if(redraw):
        plotobject.myRefresh()
      return nuticks

  def setAxisTicks(self, value=np.array([]), axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisname = 'ax2'; useTicksXMinor = self.ticksXMinor
        if(axis == 'x2'):
          axisobject, useTicksXMinor = self.ax2_div, self.ticksXMinor_div
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisname = 'ax_resid'; useTicksXMinor = self.ticksXMinor
        if(axis == 'x2'):
          axisobject, useTicksXMinor = self.ax_resid_div, self.ticksXMinor_div
    else:
      axis='abort'
    # sets axis ticks
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      flag = False
      if(axis == 'x'):
        if(self.modeX == 'linear'):
          autolabels = matplotlib.ticker.ScalarFormatter()
          formatterName = 'matplotlib.ticker.ScalarFormatter()'
        else:
          autolabels = matplotlib.ticker.LogFormatterSciNotation()
          if(platform in ['linux', 'darwin']):
            formatterName = 'matplotlib.ticker.ScalarFormatter()'
          else:
            formatterName = 'matplotlib.ticker.LogFormatterSciNotation()'
        # apply custom formatting?
        if(self.ticksXFormat != 'default'):
          # store fallback
          self.fallback_ticksXFormat = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksXFormat, self.ticksXFormatPrecision, self.ticksXFormatTrailZero, self.ticksXFormatSeparator, self.ticksXFormatPrefix, self.ticksXFormatPostfix))
        axisobject.xaxis.set_major_formatter(autolabels)
        axisobject.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        ###if(self.modeX == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          axisobject.xaxis.set_minor_locator(minorAutoticks)
          axisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store settings
        self.ticksX = value
        self.rememberSetting[axisname + '_tickX'] = axisname + '.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(value)) + '))\n'
        self.rememberSetting[axisname + '_tickX'] += axisname + '.xaxis.set_major_formatter(' + formatterName + ')\n'
        lower, upper = self.minX, self.maxX
        if(len(value)):
          # check for empty list
          if(np.min(value)<np.min((self.minX, self.maxX))):
            flag = True
            lower = np.min(value)
          if(np.max(value)>np.max((self.minX, self.maxX))):
            flag = True
            upper = np.max(value)
          # special treatment for resid plot
          if(target == 'resid'):
            flag = True
        # clear labels
        self.ticksXLabel = []
        self.ticksXAuto = False
      elif(axis == 'x2'):
        if(self.modeX_div == 'linear'):
          autolabels = matplotlib.ticker.ScalarFormatter()
        else:
          autolabels = matplotlib.ticker.LogFormatterSciNotation()
        # apply custom formatting?
        if(self.ticksXFormat_div != 'default'):
          # store fallback
          self.fallback_ticksXFormat_div = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksXFormat_div, self.ticksXFormatPrecision_div, self.ticksXFormatTrailZero_div, self.ticksXFormatSeparator_div, self.ticksXFormatPrefix_div, self.ticksXFormatPostfix_div))
        axisobject.xaxis.set_major_formatter(autolabels)
        axisobject.xaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        ###if(self.modeX_div == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(useTicksXMinor)
          axisobject.xaxis.set_minor_locator(minorAutoticks)
          axisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store settings
        self.ticksX_div = value
        lower, upper = self.minX_div, self.maxX_div
        if(len(value)):
          # check for empty list
          if(np.min(value)<np.min((self.minX_div, self.maxX_div))):
            flag = True
            lower = np.min(value)
          if(np.max(value)>np.max((self.minX_div, self.maxX_div))):
            flag = True
            upper = np.max(value)
          # special treatment for resid plot
          if(target == 'resid'):
            flag = True
        # clear labels
        self.ticksXLabel_div = []
        self.ticksXAuto_div = False
      elif(axis == 'y'):
        axisobject = self.ax; axisname = 'ax'
        if(self.modeY == 'linear'):
          autolabels = matplotlib.ticker.ScalarFormatter()
          formatterName = 'matplotlib.ticker.ScalarFormatter()'
        else:
          autolabels = matplotlib.ticker.LogFormatterSciNotation()
          if(platform in ['linux', 'darwin']):
            formatterName = 'matplotlib.ticker.ScalarFormatter()'
          else:
            formatterName = 'matplotlib.ticker.LogFormatterSciNotation()'
        # apply custom formatting?
        if(self.ticksYFormat != 'default'):
          # store fallback
          self.fallback_ticksYFormat = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksYFormat, self.ticksYFormatPrecision, self.ticksYFormatTrailZero, self.ticksYFormatSeparator, self.ticksYFormatPrefix, self.ticksYFormatPostfix))
        axisobject.yaxis.set_major_formatter(autolabels)
        axisobject.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        ###if(self.modeY == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(self.ticksYMinor)
          axisobject.yaxis.set_minor_locator(minorAutoticks)
          axisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store settings
        self.ticksY = value
        self.rememberSetting[axisname + '_tickY'] = axisname + '.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(value)) + '))\n'
        self.rememberSetting[axisname + '_tickY'] += axisname + '.yaxis.set_major_formatter(' + formatterName + ')\n'
        lower, upper = self.minY, self.maxY
        if(len(value)):
          # check for empty list
          if(np.min(value) < np.min((self.minY, self.maxY))):
            flag = True
            lower = np.min(value)
          if(np.max(value) > np.max((self.minY, self.maxY))):
            flag = True
            upper = np.max(value)
        self.ticksYAuto = False
      elif(axis == 'y2'):
        if(self.modeY2 == 'linear'):
          autolabels = matplotlib.ticker.ScalarFormatter()
          formatterName = 'matplotlib.ticker.ScalarFormatter()'
        else:
          autolabels = matplotlib.ticker.LogFormatterSciNotation()
          if(platform in ['linux', 'darwin']):
            formatterName = 'matplotlib.ticker.ScalarFormatter()'
          else:
            formatterName = 'matplotlib.ticker.LogFormatterSciNotation()'
        # apply custom formatting?
        if(self.ticksY2Format != 'default'):
          # store fallback
          self.fallback_ticksY2Format = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksY2Format, self.ticksY2FormatPrecision, self.ticksY2FormatTrailZero, self.ticksY2FormatSeparator, self.ticksY2FormatPrefix, self.ticksY2FormatPostfix))
        axisobject.yaxis.set_major_formatter(autolabels)
        axisobject.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        ###if(self.modeY2 == 'linear'):
        if(1):
          minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor)
          axisobject.yaxis.set_minor_locator(minorAutoticks)
          axisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        # store settings
        self.ticksY2 = value
        self.rememberSetting[axisname + '_tickY'] = axisname + '.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(value)) + '))\n'
        self.rememberSetting[axisname + '_tickY'] += axisname + '.yaxis.set_major_formatter(' + formatterName + ')\n'
        lower, upper = self.minY2, self.maxY2
        if(len(value)):
          # check for empty list
          if(np.min(value) < np.min((self.minY2, self.maxY2))):
            flag = True
            lower = np.min(value)
          if(np.max(value) > np.max((self.minY2, self.maxY2))):
            flag = True
            upper = np.max(value)
        self.ticksY2Auto = False
      else:
        axisobject.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(value))
        autolabels = matplotlib.ticker.ScalarFormatter()
        # apply custom formatting?
        if(self.ticksResidYFormat != 'default'):
          # store fallback
          self.fallback_ticksResidYFormat = autolabels
          autolabels = matplotlib.ticker.FuncFormatter(partial(self.myFormatterFunction, self.ticksResidYFormat, self.ticksResidYFormatPrecision, self.ticksResidYFormatTrailZero, self.ticksResidYFormatSeparator, self.ticksResidYFormatPrefix, self.ticksResidYFormatPostfix))
        minorAutoticks = MyAutoMinorLocator(self.ticksResidYMinor)
        axisobject.yaxis.set_minor_locator(minorAutoticks)
        axisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        formatterName = 'matplotlib.ticker.ScalarFormatter()'
        axisobject.yaxis.set_major_formatter(autolabels)
        self.rememberSetting[axisname + '_tickY'] = axisname + '.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(' + repr(list(value)) + '))\n'
        self.rememberSetting[axisname + '_tickY'] += axisname + '.yaxis.set_major_formatter(' + formatterName + ')\n'
        lower, upper = self.minResidY, self.maxResidY
        if(len(value)):
          # check for empty list
          if(np.min(value) < np.min((self.minResidY, self.maxResidY))):
            flag = True
            lower = np.min(value)
          if(np.max(value) > np.max((self.minResidY, self.maxResidY))):
            flag = True
            upper = np.max(value)
        self.ticksResidYAuto = False
        
      # check whether the new ticks necessitate axis rescaling
      if(flag):
        if((axis in ['y', 'y2']) or (axis == 'resid')):
          self.setAxisLimits(lower = lower, upper = upper, axis = axis, updateLabel = True, target=target, redraw=redraw, updateGrid=True)
        else:
          self.setAxisLimits(lower = lower, upper = upper, axis = axis, updateLabel = True, target=target, redraw=False, updateGrid=True)
          if(target == 'plot'):
            # and we should redraw the fit function to cover new x-range
            if(axis == 'x'):
              self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
                fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
                redraw=redraw)
            else:
              self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
                fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
                redraw=redraw, splitX=True)
          else:
            # and we should update the resid plot (as x-axis will most likely have rescaled)
            if(axis == 'x'):
              self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero, redraw=redraw)
            else:
              self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(self.parent.plotArea.handleResidZero_div, redraw=redraw, splitX=True)
      else:
        # update axis grid lines
        if(axis == 'resid'):
          item = 'y'
        else:
          item = axis
        if(self.gridVisible[item]):
          if((item != 'y2') or self.isSecondAxesActive()):
            self.drawAxisGrid(axis=item, redraw=False, target=target)
      
        if(redraw):
          plotobject.myRefresh()

  def getAxisTicks(self, axis='x'):
    # reports back axis ticks
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis == 'x'):
        ticks = self.ax.xaxis.get_ticklocs()
      elif(axis == 'x2'):
        ticks = self.ax_div.xaxis.get_ticklocs()
      elif(axis == 'y'):
        ticks = self.ax.yaxis.get_ticklocs()
      elif(axis == 'y2'):
        ticks = self.ax2.yaxis.get_ticklocs()
      else:
        ticks = self.ax_resid.yaxis.get_ticklocs()
      return ticks
    else:
      return []

  def setTickLabelPad2(self, value=0.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'; plotfig = self.matplot
          if((self.ticksXPad2 == value) or (not self.ticksXShow)):
            redraw = False
          self.ticksXPad2 = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'; plotfig = self.residplot
          if((self.ticksXPad2_resid == value) or (not self.ticksXShow_resid)):
            redraw = False
          self.ticksXPad2_resid = value
        #
        tickLabels = axisobject.get_xticklabels(which='both')
        tickLabels.extend(axisobject2.get_xticklabels(which='both'))
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'; plotfig = self.matplot
          if((self.ticksYPad2 == value) or (not self.ticksYShow)):
            redraw = False
          self.ticksYPad2 = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'; plotfig = self.residplot
          if((self.ticksYPad2_resid == value) or (not self.ticksYShow_resid)):
            redraw = False
          self.ticksYPad2_resid = value
        #
        tickLabels = axisobject.get_yticklabels(which='both')
        tickLabels.extend(axisobject2.get_yticklabels(which='both'))
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'; plotfig = self.matplot
        if((self.ticksY2Pad2 == value) or (not self.ticksY2Show)):
          redraw = False
        self.ticksY2Pad2 = value
        #
        tickLabels = axisobject.get_yticklabels(which='both')
        tickLabels.extend(axisobject2.get_yticklabels(which='both'))

      # set orthogonal padding using transforms
      if(axis == 'x'):
        offset = matplotlib.transforms.ScaledTranslation(value/72.0, 0, plotfig.dpi_scale_trans)
      else:
        offset = matplotlib.transforms.ScaledTranslation(0, value/72.0, plotfig.dpi_scale_trans)
      for entry in tickLabels:
        # strip transform down to inner CompositeGenericTransform
        transformA, transformB = entry.get_transform(), matplotlib.transforms.IdentityTransform()
        while(isinstance(transformA, matplotlib.transforms.CompositeGenericTransform)):
          transformA, transformB = transformA._a, transformA._b
        # compile new transform
        transAll = transformA + transformB + offset
        entry.set_transform(transAll)

      # take care of moved axes (otherwise padding set to zero)
      if(axis == 'x'):
        # adjust spine lines if needed
        for spine in ['top', 'bottom']:
          if(self.axisPosition[spine] in ['data', 'axes']):
            self.setAxisPositionHelper(axis=spine, plotobject=plotobject, axisobject=axisobject, target=target, secondAxes=False)
            self.setAxisPositionHelper(axis=spine, plotobject=plotobject, axisobject=axisobject2, target=target, secondAxes=False, splitX=True)
      elif(axis == 'y'):
        # adjust spine lines if needed
        for spine in ['left', 'right']:
          if(self.axisPosition[spine] in ['data', 'axes']):
            self.setAxisPositionHelper(axis=spine, plotobject=plotobject, axisobject=axisobject, target=target, secondAxes=False)
      elif(axis == 'y2'):
        for spine in ['left2', 'right2']:
          if(self.axisPosition[spine] in ['data', 'axes']):
            self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2, target='plot', secondAxes=True)

      # remember settings
      ### this will be hard to remember right -- not supported for time being

      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setTickLabelPad(self, value=4.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.ticksXPad == value) or (not self.ticksXShow)):
            redraw = False
          self.ticksXPad = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.ticksXPad_resid == value) or (not self.ticksXShow_resid)):
            redraw = False
          self.ticksXPad_resid = value
        #
        ticks = axisobject.xaxis.get_major_ticks()
        ticks.extend(axisobject.xaxis.get_minor_ticks())
        ticks.extend(axisobject2.xaxis.get_major_ticks())
        ticks.extend(axisobject2.xaxis.get_minor_ticks())
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.ticksYPad == value) or (not self.ticksYShow)):
            redraw = False
          self.ticksYPad = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.ticksYPad_resid == value) or (not self.ticksYShow_resid)):
            redraw = False
          self.ticksYPad_resid = value
        #
        ticks = axisobject.yaxis.get_major_ticks()
        ticks.extend(axisobject.yaxis.get_minor_ticks())
        ticks.extend(axisobject2.yaxis.get_major_ticks())
        ticks.extend(axisobject2.yaxis.get_minor_ticks())
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.ticksY2Pad == value) or (not self.ticksY2Show)):
          redraw = False
        self.ticksY2Pad = value
        #
        ticks = axisobject.yaxis.get_major_ticks()
        ticks.extend(axisobject.yaxis.get_minor_ticks())
        ticks.extend(axisobject2.yaxis.get_major_ticks())
        ticks.extend(axisobject2.yaxis.get_minor_ticks())

      # set padding
      for entry in ticks:
        entry.set_pad(value)
        
      # remember settings
      tempRememberSetting = 'ticks = ' + axisname + '.' + axis[:1] + 'axis.get_major_ticks()\n'
      tempRememberSetting += 'ticks.extend(' + axisname + '.' + axis[:1] + 'axis.get_minor_ticks())\n'
      tempRememberSetting += 'for entry in ticks:\n\tentry.set_pad(' + repr(value) + ')\n'
      self.rememberSetting[axisname + '_tickPad' + axis] = tempRememberSetting

      # now we should call setTickLabelPad2 to prevent undoing of perpendicular shift (kind of ugly thing to do)
      # maybe in the future use a single handler function
      if(axis == 'x'):
        self.setTickLabelPad2(value=self.ticksXPad2, axis=axis, redraw=False, target=target)
      elif(axis == 'y'):
        if(target == 'plot'):
          self.setTickLabelPad2(value=self.ticksYPad2, axis=axis, redraw=False, target=target)
        else:
          self.setTickLabelPad2(value=self.ticksYPad2_resid, axis=axis, redraw=False, target=target)
      elif(axis == 'y2'):
        self.setTickLabelPad2(value=self.ticksY2Pad2, axis=axis, redraw=False, target=target)

      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setTickLabelBold(self, value='normal', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXWeight == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXWeight = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYWeight == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYWeight = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif((axis == 'y2') or (not self.ticksY2Show)):
            if(self.ticksY2Weight == value):
              redraw = False
            self.ticksY2Weight = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXWeight_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXWeight_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYWeight_resid == value) or (not self.ticksYShow_resid)):
              redraw = False
            self.ticksYWeight_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_fontweight(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_fontweight(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickWeight' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()
      
  def setTickLabelItalic(self, value='normal', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXStyle == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXStyle = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYStyle == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYStyle = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Style == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Style = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXStyle_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXStyle_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYStyle_resid == value) or (not self.ticksYShow_resid)):
              redraw = False
            self.ticksYStyle_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_fontstyle(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_fontstyle(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickStyle' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickLabelAngle(self, value=12.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXAngle == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXAngle = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYAngle == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYAngle = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Angle == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Angle = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXAngle_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXAngle_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYAngle_resid == value) or (not self.ticksYShow_resid)):
              redraw = False
            self.ticksYAngle_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_rotation(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_rotation(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickAngle' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickLabelAlignment(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXAlignment == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXAlignment = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYAlignment == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYAlignment = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Alignment == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Alignment = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXAlignment_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXAlignment_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYAlignment_resid == value) or (not self.ticksYShow_resid)):
              redraw = False
            self.ticksYAlignment_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_horizontalalignment(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_horizontalalignment(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickAlignment' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickLabelAlignmentVertical(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXAlignmentVertical == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXAlignmentVertical = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYAlignmentVertical == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYAlignmentVertical = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2AlignmentVertical == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2AlignmentVertical = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(axis == 'x'):
            if((self.ticksXAlignmentVertical_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXAlignmentVertical_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYAlignmentVertical_resid == value) or (not self.ticksYShow_resid)):
              redraw = False
            self.ticksYAlignmentVertical_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_verticalalignment(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_verticalalignment(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickAlignmentVertical' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickLabelSize(self, value=12.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXSize == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXSize = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYSize == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYSize = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Size == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Size = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          # sets tick label size
          if(axis == 'x'):
            if((self.ticksXSize_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXSize_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            if((self.ticksYSize_resid == value) or (not self.ticksYShow_resid)):
              redraw = False
            self.ticksYSize_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_fontsize(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_fontsize(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickFontSize' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def toggleTicksLabel(self, value=True, axis='x', redraw=True, target='plot'):
    # toggles visibility of tick labels
    # somehow Matplotlib 3.1.2 fucks up with turning tick visibility on again
    # rather go via set_tick_params
    if((target in ['plot', 'resid']) and (axis in ['x', 'x2', 'y', 'y2'])):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div 
        if(axis == 'y'):
          axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
        
      if(axis == 'x'):
        if(target == 'plot'):
          if(self.ticksXShow == value):
            redraw = False
          self.ticksXShow = value
        else:
          if(self.ticksXShow_resid == value):
            redraw = False
          self.ticksXShow_resid = value
        offsetLabel = axisobject.xaxis.get_offset_text()
      elif(axis == 'x2'):
        if(target == 'plot'):
          if(self.ticksXShow_div == value):
            redraw = False
          self.ticksXShow_div = value
        else:
          if(self.ticksXShow_resid_div == value):
            redraw = False
          self.ticksXShow_resid_div = value
        offsetLabel = axisobject2.xaxis.get_offset_text()
      elif(axis == 'y'):
        if(target == 'plot'):
          if(self.ticksYShow == value):
            redraw = False
          self.ticksYShow = value
        else:
          if(self.ticksYShow_resid == value):
            redraw = False
          self.ticksYShow_resid = value
        offsetLabel = axisobject.yaxis.get_offset_text()
      elif(axis == 'y2'):
        if(self.ticksY2Show == value):
          redraw = False
        self.ticksY2Show = value
        offsetLabel = axisobject.yaxis.get_offset_text()
      else:
        redraw = False
        offsetLabel = None

      # set visibility of tick labels
      if(axis in ['x', 'x2']):
        if(axis == 'x'):
          useAxisobject = axisobject
        else:
          useAxisobject = axisobject2

        if(value):
          # check current location of tick marks
          if(useAxisobject.xaxis.get_ticks_position() in ['default', 'bottom', 'both', 'unknown']):
            useAxisobject.xaxis.set_tick_params(which='both', labelbottom=True, labeltop=False)
          else:
            useAxisobject.xaxis.set_tick_params(which='both', labelbottom=False, labeltop=True)
        else:
          useAxisobject.xaxis.set_tick_params(which='both', labelbottom=False, labeltop=False)
      elif(axis in ['y', 'y2']):
        if(value):
          # check current location of tick marks
          if(axis == 'y'):
            value1, value2 = True, False
          else:
            value1, value2 = False, True
          if(axisobject.yaxis.get_ticks_position() in ['default', 'left', 'both', 'unknown']):
            axisobject.yaxis.set_tick_params(which='both', labelleft=value1, labelright=value2)
          else:
            axisobject.yaxis.set_tick_params(which='both', labelleft=value2, labelright=value1)
        else:
          axisobject.yaxis.set_tick_params(which='both', labelleft=False, labelright=False)
        
      # need to update tick formatting if labels are displayed again
      if(value):
        self.setTickOne4All(axis=axis, redraw=False, target=target)
        
      # offset label
      if(offsetLabel != None):
        offsetLabel.set_visible(value)
        
      #print(tickLabels)
      
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def toggleAxisLabel(self, value=True, axis='x', redraw=True, target='plot'):
    # toggles visibility of axis label
    if((target in ['plot', 'resid']) and (axis in ['x', 'y', 'y2'])):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2
        if(axis == 'y'):
          axisobject = self.ax
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
        
      if(axis == 'x'):
        if(target == 'plot'):
          if(self.labelXShow == value):
            redraw = False
          self.labelXShow = value
        else:
          if(self.labelXShow_resid == value):
            redraw = False
          self.labelXShow_resid = value
        axisobject.xaxis.label.set_visible(value) 
      elif(axis == 'y'):
        if(target == 'plot'):
          if(self.labelYShow == value):
            redraw = False
          self.labelYShow = value
        else:
          if(self.labelYShow_resid == value):
            redraw = False
          self.labelYShow_resid = value
        axisobject.yaxis.label.set_visible(value) 
      elif(axis == 'y2'):
        if(self.labelY2Show == value):
          redraw = False
        self.labelY2Show = value
        axisobject.yaxis.label.set_visible(value) 
      else:
        redraw = False
      
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelSize(self, value=12.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXSize == value) or (not self.labelXShow)):
            redraw = False
          self.labelXSize = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXSize_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXSize_resid = value

        handleAxis = axisobject.xaxis.label
        handleAxis.set_size(value)
        handleAxis = axisobject2.xaxis.label
        handleAxis.set_size(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYSize == value) or (not self.labelYShow)):
            redraw = False
          self.labelYSize = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYSize_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYSize_resid = value

        handleAxis = axisobject.yaxis.label
        handleAxis.set_size(value)
        handleAxis = axisobject2.yaxis.label
        handleAxis.set_size(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Size == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Size = value
        handleAxis = axisobject.yaxis.label
        handleAxis.set_size(value)
        handleAxis = axisobject2.yaxis.label
        handleAxis.set_size(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelSize' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_size(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelPad(self, value=12.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXPad == value) or (not self.labelXShow)):
            redraw = False
          self.labelXPad = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid; axisname = 'ax_resid'
          if((self.labelXPad_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXPad_resid = value

        axisobject.xaxis.labelpad = value
        axisobject2.xaxis.labelpad = value
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYPad == value) or (not self.labelYShow)):
            redraw = False
          self.labelYPad = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYPad_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYPad_resid = value

        axisobject.yaxis.labelpad = value
        axisobject2.yaxis.labelpad = value
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Pad == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Pad = value
        axisobject.yaxis.labelpad = value
        axisobject2.yaxis.labelpad = value
      # remember settings
      self.rememberSetting[axisname + '_axisLabelPad' + axis] = axisname + '.' + axis[:1] + 'axis.labelpad = ' + repr(value) + '\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelPos(self, value=0.5, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXPos == value) or (not self.labelXShow)):
            redraw = False
          self.labelXPos = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXPos_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXPos_resid = value

        axisobject.xaxis.label.set_x(value)
        axisobject2.xaxis.label.set_x(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYPos == value) or (not self.labelYShow)):
            redraw = False
          self.labelYPos = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYPos_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYPos_resid = value

        axisobject.yaxis.label.set_y(value)
        axisobject2.yaxis.label.set_y(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Pos == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Pos = value
        axisobject.yaxis.label.set_y(value)
        axisobject2.yaxis.label.set_y(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelPos' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_' + axis[:1] + '(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelAngle(self, value=0.0, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXAngle == value) or (not self.labelXShow)):
            redraw = False
          self.labelXAngle = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXAngle_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXAngle_resid = value

        axisobject.xaxis.label.set_rotation(value)
        axisobject2.xaxis.label.set_rotation(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYAngle == value) or (not self.labelYShow)):
            redraw = False
          self.labelYAngle = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYAngle_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYAngle_resid = value

        axisobject.yaxis.label.set_rotation(value)
        axisobject2.yaxis.label.set_rotation(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Angle == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Angle = value
        axisobject.yaxis.label.set_rotation(value)
        axisobject2.yaxis.label.set_rotation(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelAngle' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_rotation(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelBold(self, value='normal', axis='x', redraw=True, target='plot'):
    # formats axis label bold
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXWeight == value) or (not self.labelXShow)):
            redraw = False
          self.labelXWeight = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXWeight_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXWeight_resid = value

        axisobject.xaxis.label.set_fontweight(value)
        axisobject2.xaxis.label.set_fontweight(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYWeight == value) or (not self.labelYShow)):
            redraw = False
          self.labelYWeight = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYWeight_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYWeight_resid = value

        axisobject.yaxis.label.set_fontweight(value)
        axisobject2.yaxis.label.set_fontweight(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Weight == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Weight = value
        axisobject.yaxis.label.set_fontweight(value)
        axisobject2.yaxis.label.set_fontweight(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelWeight' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_fontweight(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelItalic(self, value='normal', axis='x', redraw=True, target='plot'):
    # formats axis label italic
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXStyle == value) or (not self.labelXShow)):
            redraw = False
          self.labelXStyle = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXStyle_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXStyle_resid = value

        axisobject.xaxis.label.set_fontstyle(value)
        axisobject2.xaxis.label.set_fontstyle(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYStyle == value) or (not self.labelYShow)):
            redraw = False
          self.labelYStyle = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYStyle_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYStyle_resid = value

        axisobject.yaxis.label.set_fontstyle(value)
        axisobject2.yaxis.label.set_fontstyle(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Style == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Style = value
        axisobject.yaxis.label.set_fontstyle(value)
        axisobject2.yaxis.label.set_fontstyle(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelStyle' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_fontstyle(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisLabelVariant(self, value='normal', axis='x', redraw=True, target='plot'):
    # formats axis label small-caps
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXVariant == value) or (not self.labelXShow)):
            redraw = False
          self.labelXVariant = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXVariant_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXVariant_resid = value

        axisobject.xaxis.label.set_variant(value)
        axisobject2.xaxis.label.set_variant(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYVariant == value) or (not self.labelYShow)):
            redraw = False
          self.labelYVariant = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYVariant_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYVariant_resid = value

        axisobject.yaxis.label.set_variant(value)
        axisobject2.yaxis.label.set_variant(value)
      elif(axis == 'y2'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        if((self.labelY2Variant == value) or (not self.labelY2Show)):
          redraw = False
        self.labelY2Variant = value
        axisobject.yaxis.label.set_variant(value)
        axisobject2.yaxis.label.set_variant(value)
      # remember settings
      self.rememberSetting[axisname + '_axisLabelVariant' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_variant(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setAxisArrow(self, state=True, axis='x', redraw=True, target='plot'):
    # toggles drawing of arrow
    if((target in ['plot', 'resid']) and (axis in ['x', 'y'])):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; arrowhandle = self.handleArrow
      else:
        plotobject = self.residplotwidget; arrowhandle = self.handleArrowResid
      self.arrowVisible[axis] = state
      if(state):
        self.drawAxisArrow(axis=axis, redraw=redraw, target=target)
      elif(arrowhandle[axis] != None):
        arrowhandle[axis].remove()
        arrowhandle[axis] = None
        if(redraw):
          plotobject.myRefresh()        

  def setAxisArrowColor(self, value=[0.0, 0.0, 0.0, 1.0], axis='x', item='fill', redraw=True):
    # changes color axis arrow
    if((axis in ['x', 'y']) and (item in ['line', 'fill'])):
      if(item == 'line'):
        self.arrowColor[axis] = value
      else:
        self.arrowFill[axis] = value
        
      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowHeadWidth(self, value=0.1, axis='x', redraw=True):
    # changes width of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowHeadWidth[axis] == value):
        redraw = False
      self.arrowHeadWidth[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowHeadLength(self, value=0.1, axis='x', redraw=True):
    # changes width of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowHeadLength[axis] == value):
        redraw = False
      self.arrowHeadLength[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowOverhang(self, value=0.1, axis='x', redraw=True):
    # changes overhang of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowOverhang[axis] == value):
        redraw = False
      self.arrowOverhang[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def setAxisArrowOffset(self, value=0, axis='x', redraw=True):
    # changes offset of axis arrow
    if(axis in ['x', 'y']):
      if(self.arrowOffset[axis] == value):
        redraw = False
      self.arrowOffset[axis] = value

      if((redraw) and (self.arrowVisible[axis])):
        self.drawAxisArrow(axis=axis, redraw=redraw, target='plot')
        self.drawAxisArrow(axis=axis, redraw=redraw, target='resid')

  def drawAxisArrow(self, axis='x', redraw=True, target='plot'):
    # draws arrowhead along axis
    drawOnDiv = self.splitShow and (axis == 'x')
    if((target in ['plot', 'resid']) and (axis in ['x', 'y'])):
      # assign handles
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax; arrowhandle = self.handleArrow
        if(drawOnDiv):
          axisobject = self.ax_div
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; arrowhandle = self.handleArrowResid
        if(drawOnDiv):
          axisobject = self.ax_resid_div

      # assign values
      drawCol = self.arrowColor[axis]
      drawFill = self.arrowFill[axis]
      drawOverhang = self.arrowOverhang[axis]
      drawOffset = self.arrowOffset[axis]
      drawHeadWidth = self.arrowHeadWidth[axis]
      drawHeadLength = self.arrowHeadLength[axis]
      drawZ = axisobject.spines['bottom'].get_zorder() + 0.1
      
      # which axis to operate on?
      if(axis=='x'):
        # calculate drawWidth
        if(drawOnDiv):
          useModeX, useMinX, useMaxX = self.modeX_div, self.minX_div, self.maxX_div
        else:
          useModeX, useMinX, useMaxX = self.modeX, self.minX, self.maxX
          
        if(useModeX == 'linear'):
          drawWidth = np.abs(useMaxX - useMinX)
          logx = False
        else:
          drawWidth = np.abs(np.log(useMaxX) - np.log(useMinX))
          logx = True

        drawHeadLength *= drawWidth
  
        # calculate drawHeight
        if(target == 'plot'):
          if(self.modeY == 'linear'):
            drawHeight = np.abs(self.maxY - self.minY)
            logy = False
          else:
            drawHeight = np.abs(np.log(self.maxY) - np.log(self.minY))
            logy = True

          drawHeadWidth *= drawHeight
        else:
          drawHeight = np.abs(self.maxResidY - self.minResidY)
          # resid plot is always linear in y; account for difference in window size
          drawHeadWidth *= drawHeight * 4.0
          logy = False

        # assign line width and xy coordinates
        drawLw = self.axisWidth['bottom']
        drawCs = self.axisDashStyle['bottom']
        
        # apply offset
        if(useModeX == 'linear'):
          drawX = np.max((useMinX, useMaxX))
        else:
          drawX = np.max((np.log(useMinX), np.log(useMaxX)))
        drawX -= drawOffset * drawHeadLength
        
        # determine drawY
        if(target == 'plot'):
          if(self.modeY == 'linear'):
            drawY = np.min((self.minY, self.maxY))
          else:
            drawY = np.min((np.log(self.minY), np.log(self.maxY)))
        else:
          drawY = np.min((self.minResidY, self.maxResidY))
        
        # account for shifted axis
        if(target == 'plot'):
          if('bottom' in self.ax2.spines):
            try:
              axisPosition, axisPositionValue = self.ax2.spines['bottom'].get_position()
              if(axisPosition == 'data'):
                drawY = axisPositionValue
                if(self.modeY == 'log'):
                  # have to test for zero/negative entry
                  if(drawY > 0):
                    drawY = np.log(drawY)
                  else:
                    drawY = np.log(self.minY)
              elif(axisPosition == 'axes'):
                axis_to_data = axisobject.transAxes + axisobject.transData.inverted()
                transformedPoint = axis_to_data.transform((0, axisPositionValue))
                drawY = transformedPoint[1]
                if(self.modeY == 'log'):
                  drawY = np.log(drawY)
            except:
              pass
          
        elif('bottom' in axisobject.spines):
          try:
            axisPosition, axisPositionValue = axisobject.spines['bottom'].get_position()
            if(axisPosition == 'data'):
              drawY = axisPositionValue
            elif(axisPosition == 'axes'):
              # in resid 
              axis_to_data = axisobject.transAxes + axisobject.transData.inverted()
              transformedPoint = axis_to_data.transform((0, axisPositionValue))
              drawY = transformedPoint[1]
          except:
            pass
      else:
        # calculate drawWidth
        if(self.modeX == 'linear'):
          drawHeight = np.abs(self.maxX - self.minX)
          logx = False
        else:
          drawHeight = np.abs(np.log(self.maxX) - np.log(self.minX))
          logx = True

        drawHeadWidth *= drawHeight
  
        # calculate drawHeight
        if(target == 'plot'):
          if(self.modeY == 'linear'):
            drawWidth = np.abs(self.maxY - self.minY)
            logy = False
          else:
            drawWidth = np.abs(np.log(self.maxY) - np.log(self.minY))
            logy = True
          drawHeadLength *= drawWidth
        else:
          drawWidth = np.abs(self.maxResidY - self.minResidY)
          # resid plot is always linear in y; account for difference in window size
          drawHeadLength *= drawWidth * 4.0
          logy = False

        # assign line width and xy coordinates
        drawLw = self.axisWidth['left']
        drawCs = self.axisDashStyle['left']

        # apply offset
        if(target == 'resid'):
          drawY = np.max((self.minResidY, self.maxResidY))
        elif (self.modeY == 'linear'):
          drawY = np.max((self.minY, self.maxY))
        else:
          drawY = np.max((np.log(self.minY), np.log(self.maxY)))
        drawY -= drawOffset * drawHeadLength
        
        # determine drawX
        if(self.modeX == 'linear'):
          drawX = np.min((self.minX, self.maxX))
        else:
          drawX = np.min((np.log(self.minX), np.log(self.maxX)))

        
        # account for shifted axis
        if('left' in axisobject.spines):
          try:
            axisPosition, axisPositionValue = axisobject.spines['left'].get_position()
            if(axisPosition == 'data'):
              drawX = axisPositionValue
              if(self.modeX == 'log'):
                # have to test for zero/negative entry
                if(drawX > 0):
                  drawX = np.log(drawX)
                else:
                  drawX = np.log(self.minX)
            elif(axisPosition == 'axes'):
              axis_to_data = axisobject.transAxes + axisobject.transData.inverted()
              transformedPoint = axis_to_data.transform((axisPositionValue, self.minY))
              drawX = transformedPoint[0]
              if(self.modeX == 'log'):
                drawX = np.log(drawX)
          except:
            pass

      # draw customized arrow
      if(arrowhandle[axis] != None):
        arrowhandle[axis].remove()
      arrowhandle[axis] = self.drawMyArrow(axisobject=axisobject, x=drawX, y=drawY, axis=axis,\
        head_width=drawHeadWidth, head_length=drawHeadLength, overhang=drawOverhang, linewidth=drawLw,\
        linecolor=drawCol, fillcolor=drawFill, capstyle=drawCs, zorder=drawZ, logx=logx, logy=logy)
      arrowhandle[axis].set_clip_on(False)

      if(redraw):
        plotobject.myRefresh()

  def drawMyArrow(self, axisobject, x, y, axis, head_width, head_length, overhang, linewidth, linecolor, fillcolor, capstyle, zorder, logx=False, logy=False):
    # draw customized arrow
    # calculate coordinates
    coords = np.array(4 * [[x, y]])
    if(axis=='x'):
      coords[0, 0] += head_length * overhang
      coords[2, 0] += head_length
      coords[1, 1] += head_width/2.0
      coords[3, 1] -= head_width/2.0
    else:
      coords[1, 0] += head_width/2.0
      coords[3, 0] -= head_width/2.0
      coords[0, 1] += head_length * overhang
      coords[2, 1] += head_length

    # transform to log scale?
    if(logx):
      coords[:, 0] = np.exp(coords[:,0])
    if(logy):
      coords[:, 1] = np.exp(coords[:,1])

    if(axisobject is self.ax):
      axisname = 'ax'
    else:
      axisname = 'ax_resid'
      
    if(overhang < 1):
      polyPatch = matplotlib.patches.Polygon(coords, closed=True, facecolor=fillcolor, fill=True,\
        edgecolor=linecolor, linestyle='solid', linewidth=linewidth, zorder=zorder, capstyle=capstyle)
      retv = axisobject.add_patch(polyPatch)
      self.rememberSetting[axisname + '_arrow' + axis] = 'coords = np.array(' + repr(coords.tolist()) + ')\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'polyPatch = matplotlib.patches.Polygon(coords, closed=True, facecolor='\
        + repr(fillcolor) + ', fill=True, edgecolor=' + repr(linecolor) + ', linestyle=\'solid\', linewidth='\
        + repr(linewidth) + ', zorder=' + repr(zorder) + ', capstyle=' + repr(capstyle) + ')\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'patchHandle = ' + axisname + '.add_patch(polyPatch)\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'patchHandle.set_clip_on(False)\n'
    else:
      polyPatch = matplotlib.patches.Polygon(coords[1:,:], closed=False, fill=False,\
        edgecolor=linecolor, linestyle='solid', linewidth=linewidth, zorder=zorder, capstyle=capstyle)
      retv = axisobject.add_patch(polyPatch)
      self.rememberSetting[axisname + '_arrow' + axis] = 'coords = np.array(' + repr(coords[1:,:].tolist()) + ')\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'polyPatch = matplotlib.patches.Polygon(coords, closed=False'\
        + ', fill=False, edgecolor=' + repr(linecolor) + ', linestyle=\'solid\', linewidth='\
        + repr(linewidth) + ', zorder=' + repr(zorder) + ', capstyle=' + repr(capstyle) + ')\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'patchHandle = ' + axisname + '.add_patch(polyPatch)\n'
      self.rememberSetting[axisname + '_arrow' + axis] += 'patchHandle.set_clip_on(False)\n'

    return retv

  def setCanvasGradientStyle(self, value=0.0, redraw=True, target='plot'):
    # sets angle of canvas gradient
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        if(self.canvasGradientStyle == value):
          redraw = False
        else:
          self.canvasGradientStyle = value
      else:
        if(self.canvasGradientStyle_resid == value):
          redraw = False
        else:
          self.canvasGradientStyle_resid = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)

  def setCanvasGradientColor(self, value=0.0, redraw=True, target='plot', color=0):
    # sets angle of canvas gradient
    if((target in ['plot', 'resid']) and (color in [0, 1])):
      if(target == 'plot'):
        if(color):
          if(self.canvasGradientColor2 == value):
            redraw = False
          else:
            self.canvasGradientColor2 = value
        else:
          if(self.canvasGradientColor1 == value):
            redraw = False
          else:
            self.canvasGradientColor1 = value
      else:
        if(color):
          if(self.canvasGradientColor2_resid == value):
            redraw = False
          else:
            self.canvasGradientColor2_resid = value
        else:
          if(self.canvasGradientColor1_resid == value):
            redraw = False
          else:
            self.canvasGradientColor1_resid = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)

  def setCanvasGradientCenter(self, value=0.0, redraw=True, target='plot', axis='x'):
    # sets angle of canvas gradient
    if((target in ['plot', 'resid']) and (axis in ['x', 'y'])):
      if(axis == 'x'):
        index = 0
      else:
        index = 1
      if(target == 'plot'):
        if(self.canvasGradientCenter[index] == value):
          redraw = False
        else:
          self.canvasGradientCenter[index] = value
      else:
        if(self.canvasGradientCenter_resid[index] == value):
          redraw = False
        else:
          self.canvasGradientCenter_resid[index] = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible and (self.canvasGradientStyle == 'radial')):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)

  def setCanvasGradientWidth(self, value=0.0, redraw=True, target='plot'):
    # sets angle of canvas gradient
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        if(self.canvasGradientWidth == value):
          redraw = False
        else:
          self.canvasGradientWidth = value
      else:
        if(self.canvasGradientWidth_resid == value):
          redraw = False
        else:
          self.canvasGradientWidth_resid = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible and (self.canvasGradientStyle == 'radial')):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)

  def setCanvasGradientAngle(self, value=0.0, redraw=True, target='plot'):
    # sets angle of canvas gradient
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        if(self.canvasGradientAngle == value):
          redraw = False
        else:
          self.canvasGradientAngle = value
      else:
        if(self.canvasGradientAngle_resid == value):
          redraw = False
        else:
          self.canvasGradientAngle_resid = value
          
      # issue redraw if needed
      if(redraw and self.canvasGradientVisible and (self.canvasGradientStyle == 'linear')):
        self.setCanvasGradient(state=True, redraw=redraw, target=target)
  
  def setCanvasGradient(self, state=True, redraw=True, target='plot', steps=50):
    # draws a color gradient on axis background
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; planeobject = self.colorPlane; handleContour = self.colorBackground
        axisobject = self.ax2; axisobject2 = self.ax2_div
      else:
        plotobject = self.residplotwidget; planeobject = self.colorPlane_resid; handleContour = self.colorBackground_resid
        axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
      
      # remove previous gradient (if present)
      if(handleContour != None):
        for entry in handleContour.collections:
          entry.remove()
        handleContour = None
  
      self.canvasGradientVisible = state
      if(state):
        # define new gradient
        gradientDict = {}
        for index, component in enumerate(['red', 'green', 'blue', 'alpha']):
          gradientDictTemp = {component: ((0.0, self.canvasGradientColor1[index], self.canvasGradientColor1[index]),
                                          (1.0, self.canvasGradientColor2[index], self.canvasGradientColor2[index]))}
          gradientDict.update(gradientDictTemp)
        gradientMap = matplotlib.colors.LinearSegmentedColormap('MyMap', gradientDict)
        x, y = np.linspace(0, 1, steps), np.linspace(0, 1, steps)
        X, Y = np.meshgrid(x, y)
        if(self.canvasGradientStyle == 'linear'):
          angle = self.canvasGradientAngle / 360.0 * 2 * np.pi
          Z = X * np.cos(angle) + Y * np.sin(angle)
        else:
          width = self.canvasGradientWidth
          Z = np.exp(-(((X - self.canvasGradientCenter[0]) / width) ** 2) - (((Y - self.canvasGradientCenter[1]) / width) ** 2))
        handleContour = planeobject.contourf(X, Y, Z, 128, cmap=gradientMap, vmax=1.0, vmin=0.0)
        # hide canvas background of top plots
        axisobject.patch.set_facecolor([1.0] * 3 + [0.0])
        axisobject2.patch.set_facecolor([1.0] * 3 + [0.0])
      else:
        # restore canvas background of top plots
        if(self.canvasFill):
          axisobject.patch.set_facecolor(self.canvasColor)
          axisobject2.patch.set_facecolor(self.canvasColor)
        else:
          axisobject.patch.set_facecolor('none')
          axisobject2.patch.set_facecolor('none')
  
      if(redraw):
        plotobject.myRefresh()
  
      # assign handles
      if(target == 'plot'):
        self.colorBackground = handleContour
      else:
        self.colorBackground_resid = handleContour

  def setFigureColor(self, value=[0, 0, 0, 1], redraw=True, target='plot', silent=True):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; matobject = self.matplot; objectname = 'matplot'
      else:
        plotobject = self.residplotwidget; matobject = self.residplot; objectname = 'residplot'
      # sets figure background color
      if((self.figureColor == value) and (target == 'plot')):
        redraw = False
        
      self.figureColor = value
      # always change figure color on screen as we cannot assume which label and axis color etc. people are using
      if((not self.figureFill) and (not silent)):
        self.parent.statusbar.showMessage('Note that figure background of exported graphics is currently set to transparent.', self.parent.STATUS_TIME, color='blue')
      matobject.set_facecolor(self.figureColor)
      # remember settings
      self.rememberSetting[objectname + '_figureColor'] = objectname + '.set_facecolor(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def toggleFigureFill(self, value=True, redraw=True, target='plot', silent=True):
    # toggles whether figure background is filled or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget
      else:
        plotobject = self.residplotwidget

      # disable redraw and never change figure color on screen as we cannot assume which label and axis color etc. people are using
      redraw = False
      if((not value) and (not silent)):
        self.parent.statusbar.showMessage('Figure background of exported graphics set to transparent.', self.parent.STATUS_TIME, color='blue')
  
      self.figureFill = value
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def toggleFrameDraw(self, value=True, redraw=True, target='plot'):
    # toggles whether figure frame is drawn or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot
        if(self.frameDraw == value):
          redraw = False
        self.frameDraw = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot
        if(self.frameDraw_resid == value):
          redraw = False
        self.frameDraw_resid = value

      # adjust value
      if(value):
        if(target == 'plot'):
          value = self.frameColor
        else:
          value = self.frameColor_resid
      else:
        value = 'none'
      # sets frame color
      figobject.patch.set_edgecolor(value)
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def toggleCanvasFill(self, value=True, redraw=True, target='plot'):
    # toggles whether canvas is filled or not
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div
      # sets canvas color
      if((self.canvasFill == value) and (target == 'plot')):
        redraw = False

      self.canvasFill = value
      # adjust value
      if(value):
        value = self.canvasColor
      else:
        value = 'none'
      if(not self.canvasGradientVisible):
        axisobject.patch.set_facecolor(value)
        axisobject2.patch.set_facecolor(value)
      # redraw?
      if(redraw):
        plotobject.myRefresh()
        
  def setCanvasColor(self, value=[0, 0, 0, 1], redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
      # sets canvas color
      if((self.canvasColor == value) and (target == 'plot')):
        redraw = False

      self.canvasColor = value
      if(self.canvasFill):
        if(not self.canvasGradientVisible):
          axisobject.patch.set_facecolor(self.canvasColor)
          axisobject2.patch.set_facecolor(self.canvasColor)
        # remember settings
        self.rememberSetting[axisname + '_canvasColor'] = axisname + '.patch.set_facecolor(' + repr(value) + ')\n'
      else:
        redraw = False
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setFrameWidth(self, value=0.5, redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot; axisname = 'ax'; plotname = 'matplot'
        if(self.frameWidth == value):
          redraw = False
        self.frameWidth = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot; axisname = 'ax_resid'; plotname = 'residplot'
        if(self.frameWidth_resid == value):
          redraw = False
        self.frameWidth_resid = value

      # sets frame width
      figobject.patch.set_linewidth(value)
      
      # check whether frame is visible at all
      if(not self.frameDraw):
        redraw = False
      
      # remember settings
      self.rememberSetting[axisname + '_frameWidth'] = plotname + '.patch.set_linewidth(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setFrameStyle(self, value='solid', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot; axisname = 'ax'; plotname = 'matplot'
        if(self.frameStyle == value):
          redraw = False
        self.frameStyle = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot; axisname = 'ax_resid'; plotname = 'residplot'
        if(self.frameStyle_resid == value):
          redraw = False
        self.frameStyle_resid = value

      # sets frame line style
      figobject.patch.set_linestyle(value)

      # check whether frame is visible at all
      if(not self.frameDraw):
        redraw = False
      
      # remember settings
      self.rememberSetting[axisname + '_frameStyle'] = plotname + '.patch.set_linestyle(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setFrameDashStyle(self, value='solid', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot; axisname = 'ax'; plotname = 'matplot'
        if(self.frameDashStyle == value):
          redraw = False
        self.frameDashStyle = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot; axisname = 'ax_resid'; plotname = 'residplot'
        if(self.frameDashStyle_resid == value):
          redraw = False
        self.frameDashStyle_resid = value

      # sets grid line style
      figobject.patch.set_capstyle(value)

      # check whether frame is visible at all
      if(not self.frameDraw):
        redraw = False
      
      # remember settings
      self.rememberSetting[axisname + '_frameDashStyle'] = plotname + '.patch.set_capstyle(' + repr(value) + ')\n'
      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setFrameColor(self, value=[0, 0, 0, 1], redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; figobject = self.matplot; axisname = 'ax'; plotname = 'matplot'
        if(self.frameColor == value):
          redraw = False
        self.frameColor = value
      else:
        plotobject = self.residplotwidget; figobject = self.residplot; axisname = 'ax_resid'; plotname = 'residplot'
        if(self.frameColor_resid == value):
          redraw = False
        self.frameColor_resid = value

      # sets grid color
      if(self.frameDraw):
        figobject.patch.set_edgecolor(value)
      else:
        redraw = False

      # remember settings
      self.rememberSetting[axisname + '_frameColor'] = plotname + '.patch.set_edgecolor(' + repr(value) + ')\n'

      # redraw?
      if(redraw):
        plotobject.myRefresh()

  def setGridOrder(self, value='back', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridOrder[axis] == value):
            redraw = False
          self.gridOrder[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridOrder_resid[axis] == value):
            redraw = False
          self.gridOrder_resid[axis] = value
          
        if(value == 'back'):
          useZ = 1
        else:
          useZ = 500
        # so here is the deal: set_axisbelow() toggles axis zorder between 0.5 and 2.5
        # however, due to z offset, all our objects are at higher z values than 2.5
        # hence draw custom lines
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_zorder(useZ)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_zorder(useZ)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridStyle(self, value='solid', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridStyle[axis] == value):
            redraw = False
          self.gridStyle[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridStyle_resid[axis] == value):
            redraw = False
          self.gridStyle_resid[axis] = value

        # sets grid line style
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_linestyle(value)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_linestyle(value)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridDashStyle(self, value='butt', axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridDashStyle[axis] == value):
            redraw = False
          self.gridDashStyle[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridDashStyle_resid[axis] == value):
            redraw = False
          self.gridDashStyle_resid[axis] = value

        # sets grid line dash style
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_dash_capstyle(value)
            line.set_solid_capstyle(value)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_dash_capstyle(value)
            line.set_solid_capstyle(value)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridWidth(self, value=0.5, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridWidth[axis] == value):
            redraw = False
          self.gridWidth[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridWidth_resid[axis] == value):
            redraw = False
          self.gridWidth_resid[axis] = value

        # sets grid line width
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_linewidth(value)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_linewidth(value)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridColor(self, value=[0, 0, 0, 1], axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridColor[axis] == value):
            redraw = False
          self.gridColor[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridColor_resid[axis] == value):
            redraw = False
          self.gridColor_resid[axis] = value

        # sets grid line color
        if(target == 'plot'):
          for line in self.gridLinesStore[axis]:
            line.set_color(value)
        else:
          for line in self.gridLinesStore_resid[axis]:
            line.set_color(value)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setGridVisibility(self, value=True, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'x2', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
          if(self.gridVisible[axis] == value):
            redraw = False
          self.gridVisible[axis] = value
        else:
          plotobject = self.residplotwidget
          if(self.gridVisible_resid[axis] == value):
            redraw = False
          self.gridVisible_resid[axis] = value

        # sets visibility of grid lines
        self.drawAxisGrid(axis=axis, redraw=False, target=target)

        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setPadding(self, value=0.5, axis='bottom', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['bottom', 'top', 'left', 'right']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; matobject = self.matplot; objectname = 'matplot'
          if(matobject.subplotpars.__dict__[axis] == value):
            redraw = False
          self.padSize[axis] = value
        else:
          plotobject = self.residplotwidget; matobject = self.residplot; objectname = 'residplot'
          if(matobject.subplotpars.__dict__[axis] == value):
            redraw = False
          self.padSize_resid[axis] = value
        # sets padding
        matobject.subplots_adjust(left=self.padSize['left'], right=self.padSize['right'],\
          bottom=self.padSize['bottom'], top=self.padSize['top'])
        # remember settings
        self.rememberSetting[objectname + '_padding'] = objectname + '.subplots_adjust(left=' + repr(self.padSize['left'])
        self.rememberSetting[objectname + '_padding'] += ', right=' + repr(self.padSize['right']) + ', bottom=' + repr(self.padSize['bottom'])
        self.rememberSetting[objectname + '_padding'] += ', top=' + repr(self.padSize['top']) + ')\n'
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickOne4All(self, axis='x', redraw=True, target='plot'):
    # calls all tick label formatters successively to fix glitch when no. of tick labels change upon rescaling
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget
        else:
          plotobject = self.residplotwidget
        # which axis?  
        if(axis == 'x'):
          tickLabelColor, tickLabelSize, tickLabelWeight, tickLabelStyle, tickLabelFont = self.ticksXColor, self.ticksXSize, self.ticksXWeight, self.ticksXStyle, self.tickFont[axis]
          tickLabelAngle, tickLabelAlignment, tickLabelAlignmentVertical, tickLabelPad, tickLabelPad2 = self.ticksXAngle, self.ticksXAlignment, self.ticksXAlignmentVertical, self.ticksXPad, self.ticksXPad2
        elif(axis == 'y'):
          tickLabelColor, tickLabelSize, tickLabelWeight, tickLabelStyle, tickLabelFont = self.ticksYColor, self.ticksYSize, self.ticksYWeight, self.ticksYStyle, self.tickFont[axis]
          tickLabelAngle, tickLabelAlignment, tickLabelAlignmentVertical, tickLabelPad, tickLabelPad2 = self.ticksYAngle, self.ticksYAlignment, self.ticksYAlignmentVertical, self.ticksYPad, self.ticksYPad2
        else:
          tickLabelColor, tickLabelSize, tickLabelWeight, tickLabelStyle, tickLabelFont = self.ticksY2Color, self.ticksY2Size, self.ticksY2Weight, self.ticksY2Style, self.tickFont[axis]
          tickLabelAngle, tickLabelAlignment, tickLabelAlignmentVertical, tickLabelPad, tickLabelPad2 = self.ticksY2Angle, self.ticksY2Alignment, self.ticksY2AlignmentVertical, self.ticksY2Pad, self.ticksY2Pad2
        if((target == 'plot') or (axis != 'y2')):
          # call formatters
          self.setTickLabelColor(value=tickLabelColor, axis=axis, redraw=False, target=target)
          self.setTickLabelSize(value=tickLabelSize, axis=axis, redraw=False, target=target)
          self.setTickLabelBold(value=tickLabelWeight, axis=axis, redraw=False, target=target)
          self.setTickLabelItalic(value=tickLabelStyle, axis=axis, redraw=False, target=target)
          self.setTickFont(value=tickLabelFont, axis=axis, redraw=False, target=target)
          self.setTickLabelAngle(value=tickLabelAngle, axis=axis, redraw=False, target=target)
          self.setTickLabelAlignment(value=tickLabelAlignment, axis=axis, redraw=False, target=target)
          self.setTickLabelAlignmentVertical(value=tickLabelAlignmentVertical, axis=axis, redraw=False, target=target)
          self.setTickLabelPad(value=tickLabelPad, axis=axis, redraw=False, target=target)
          self.setTickLabelPad2(value=tickLabelPad2, axis=axis, redraw=False, target=target)
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setTickLabelColor(self, value=[0, 0, 0, 1], axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          # sets axis label color
          if(axis == 'x'):
            if((self.ticksXColor == value) or (not self.ticksXShow)):
              redraw = False
            self.ticksXColor = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.ticksYColor == value) or (not self.ticksYShow)):
              redraw = False
            self.ticksYColor = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if((self.ticksY2Color == value) or (not self.ticksY2Show)):
              redraw = False
            self.ticksY2Color = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          # sets axis label color
          if(axis == 'x'):
            if((self.ticksXColor_resid == value) or (not self.ticksXShow_resid)):
              redraw = False
            self.ticksXColor_resid = value
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          else:
            if((self.ticksYColor_resid == value) or (not self.ticksYShow_resid)):
              redraw = False
            self.ticksYColor_resid = value
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
        for entry in tickLabels:
          entry.set_color(value)
        # remember settings
        tempRememberSetting = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels(which=\'both\')\n'
        tempRememberSetting += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
        tempRememberSetting += 'for entry in tickLabels:\n\tentry.set_color(' + repr(value) + ')\n'
        self.rememberSetting[axisname + '_tickColor' + axis] = tempRememberSetting
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setTickMarkDirection(self, value='in', axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(self.ticksDirection[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            self.ticksDirection['left'] = value
            self.ticksDirection['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'y'
            self.ticksDirection['left2'] = value
            self.ticksDirection['right2'] = value
          else:
            axis = 'x'
            self.ticksDirection['top'] = value
            self.ticksDirection['bottom'] = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksDirection_resid[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'
            self.ticksDirection_resid['left'] = value
            self.ticksDirection_resid['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            axis = 'x'
            self.ticksDirection_resid['top'] = value
            self.ticksDirection_resid['bottom'] = value

        # sets tick mark position
        if(axis != 'abort'):
          axisobject.tick_params(axis=axis, direction=value, which='both')
          axisobject2.tick_params(axis=axis, direction=value, which='both')
          
          # remember settings
          self.rememberSetting[axisname + '_tickMarkDirection' + axis] = axisname + '.tick_params(axis=' + repr(axis) +', direction=' + repr(value) + ', which=\'both\')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()
          
  def setTickMarkVisibility(self, value=True, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(self.ticksVisible[axis] == value):
            redraw = False
          self.ticksVisible[axis] = value
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksVisible_resid[axis] == value):
            redraw = False
          self.ticksVisible_resid[axis] = value

        if(axis in ['left', 'right']):
          # modify ticks along y axes
          if(self.ticksVisible['left']):
            if(self.ticksVisible['right']):
              toshow = 'both'
            else:
              toshow = 'left'
            # first set labels to left side to return them there in case they have been removed previously
            axisobject.yaxis.set_ticks_position('left')
            axisobject.yaxis.set_ticks_position(toshow)
            axisobject2.yaxis.set_ticks_position('left')
            axisobject2.yaxis.set_ticks_position(toshow)
          else:
            if(self.ticksVisible['right']):
              toshow = 'right'
            else:
              toshow = 'none'
            axisobject.yaxis.set_ticks_position(toshow)
            axisobject2.yaxis.set_ticks_position(toshow)
        elif (axis in ['left2', 'right2']):
          if(self.ticksVisible['left2']):
            if(self.ticksVisible['right2']):
              toshow = 'both'
            else:
              toshow = 'left'
            # first set labels to right side to return them there in case they have been removed previously
            axisobject.yaxis.set_ticks_position('right')
            axisobject.yaxis.set_ticks_position(toshow)
            axisobject2.yaxis.set_ticks_position('right')
            axisobject2.yaxis.set_ticks_position(toshow)
          else:
            if(self.ticksVisible['right2']):
              toshow = 'right'
            else:
              toshow = 'none'
            axisobject.yaxis.set_ticks_position(toshow)
            axisobject2.yaxis.set_ticks_position(toshow)
        else:
          # modify ticks along x axes
          if(self.ticksVisible['bottom']):
            if(self.ticksVisible['top']):
              toshow = 'both'
            else:
              toshow = 'bottom'
            # first set labels to bottom to return them there in case they have been removed previously
            axisobject.xaxis.set_ticks_position('bottom')
            axisobject.xaxis.set_ticks_position(toshow)
            axisobject2.xaxis.set_ticks_position('bottom')
            axisobject2.xaxis.set_ticks_position(toshow)
          else:
            if(self.ticksVisible['top']):
              toshow = 'top'
            else:
              toshow = 'none'
            axisobject.xaxis.set_ticks_position(toshow)
            axisobject2.xaxis.set_ticks_position(toshow)
              
        # remember settings
        if(axis in ['left', 'right']):
          axis = 'y'
        elif(axis in ['left2', 'right2']):
          if(target == 'plot'):
            axis = 'y'
          else:
            axis = 'abort'
        else:
          axis = 'x'
        
        if(axis != 'abort'):
          self.rememberSetting[axisname + '_tickMarkVisibility' + axis] = axisname + '.' + axis + 'axis.set_ticks_position(' + repr(toshow) + ')\n'

          # need to solve inner situation
          self.updateInnerSituation()
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setTickMarkColor(self, value=[0, 0, 0, 1], axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(self.ticksColor[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            self.ticksColor['left'] = value
            self.ticksColor['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'y'
            self.ticksColor['left2'] = value
            self.ticksColor['right2'] = value
          else:
            axis = 'x'
            self.ticksColor['top'] = value
            self.ticksColor['bottom'] = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksColor_resid[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'
            self.ticksColor_resid['left'] = value
            self.ticksColor_resid['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            axis = 'x'
            self.ticksColor_resid['top'] = value
            self.ticksColor_resid['bottom'] = value

        # sets axis label color
        if(axis != 'abort'):
          axisobject.tick_params(axis=axis, color=value, which='both')
          axisobject2.tick_params(axis=axis, color=value, which='both')
    
          # remember settings
          self.rememberSetting[axisname + '_tickMarkColor' + axis] = axisname + '.tick_params(axis=' + repr(axis) +', color=' + repr(value) + ', which=\'both\')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setTickMarkWidth(self, value=1.0, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(self.ticksWidth[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            self.ticksWidth['left'] = value
            self.ticksWidth['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'y'
            self.ticksWidth['left2'] = value
            self.ticksWidth['right2'] = value
          else:
            axis = 'x'
            self.ticksWidth['top'] = value
            self.ticksWidth['bottom'] = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if(self.ticksWidth_resid[axis] == value):
            redraw = False
          self.ticksWidth_resid[axis] = value
          if (axis in ['left', 'right']):
            axis = 'y'
            self.ticksWidth_resid['left'] = value
            self.ticksWidth_resid['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            axis = 'x'
            self.ticksWidth_resid['top'] = value
            self.ticksWidth_resid['bottom'] = value

        if(axis != 'abort'):
          axisobject.tick_params(axis=axis, width=value, which='both')
          axisobject2.tick_params(axis=axis, width=value, which='both')
  
          # remember settings
          self.rememberSetting[axisname + '_tickMarkWidth' + axis] = axisname + '.tick_params(axis=' + repr(axis) +', width=' + repr(value) + ', which=\'both\')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setMinorTickRelativeLength(self, value, redraw=True, target='plot'):
    # changes relative length of ticks
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        if(self.ticksMinorRelativeLength == value):
          redraw = False
        else:
          self.ticksMinorRelativeLength = value
      else:
        if(self.ticksMinorRelativeLength_resid == value):
          redraw = False
        else:
          self.ticksMinorRelativeLength_resid = value
        
      if(target == 'plot'):
        for item in ['left', 'top', 'left2']:
          self.setTickMarkLength(value=self.ticksLength[item], axis=item, redraw=False, target='plot')
        if(redraw):
          self.dataplotwidget.myRefresh()
      else:
        for item in ['left', 'top']:
          self.setTickMarkLength(value=self.ticksLength[item], axis=item, redraw=False, target='resid')
        if(redraw):
          self.residplotwidget.myRefresh()
      
  def setTickMarkLength(self, value=1.0, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          ticksMinorRelativeLength = self.ticksMinorRelativeLength
          if(self.ticksLength[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            self.ticksLength['left'] = value
            self.ticksLength['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'y'
            self.ticksLength['left2'] = value
            self.ticksLength['right2'] = value
          else:
            axis = 'x'
            self.ticksLength['top'] = value
            self.ticksLength['bottom'] = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          ticksMinorRelativeLength = self.ticksMinorRelativeLength_resid
          if(self.ticksLength_resid[axis] == value):
            redraw = False
          # for time being, left/right and top/bottom are linked
          if (axis in ['left', 'right']):
            axis = 'y'
            self.ticksLength_resid['left'] = value
            self.ticksLength_resid['right'] = value
          elif (axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            axis = 'x'
            self.ticksLength_resid['top'] = value
            self.ticksLength_resid['bottom'] = value

        if(axis != 'abort'):
          axisobject.tick_params(axis=axis, length=value, which='major')
          axisobject.tick_params(axis=axis, length=value * ticksMinorRelativeLength, which='minor')
          axisobject2.tick_params(axis=axis, length=value, which='major')
          axisobject2.tick_params(axis=axis, length=value * ticksMinorRelativeLength, which='minor')
          # remember settings
          self.rememberSetting[axisname + '_tickMarkLength' + axis] = axisname + '.tick_params(axis=' + repr(axis) +', length=' + repr(value) + ', which=\'major\')\n'
          self.rememberSetting[axisname + '_tickMarkLength' + axis] += axisname + '.tick_params(axis=' + repr(axis) +', length=' + repr(value/2.0) + ', which=\'minor\')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisLabelColor(self, value=[0, 0, 0, 1], axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelXColor == value) or (not self.labelXShow)):
            redraw = False
          self.labelXColor = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelXColor_resid == value) or (not self.labelXShow_resid)):
            redraw = False
          self.labelXColor_resid = value

        handleAxis = axisobject.xaxis.label
        handleAxis.set_color(value)
        handleAxis = axisobject2.xaxis.label
        handleAxis.set_color(value)
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if((self.labelYColor == value) or (not self.labelYShow)):
            redraw = False
          self.labelYColor = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
          if((self.labelYColor_resid == value) or (not self.labelYShow_resid)):
            redraw = False
          self.labelYColor_resid = value

        handleAxis = axisobject.yaxis.label
        handleAxis.set_color(value)
        handleAxis = axisobject2.yaxis.label
        handleAxis.set_color(value)
      elif(axis == 'y2'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if((self.labelY2Color == value) or (not self.labelY2Show)):
            redraw = False
          self.labelY2Color = value
          handleAxis = axisobject.yaxis.label
          handleAxis.set_color(value)
          handleAxis = axisobject2.yaxis.label
          handleAxis.set_color(value)
        else:
          axis = 'abort'

      # remember settings
      if(axis != 'abort'):
        self.rememberSetting[axisname + '_axisLabelColor' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_color(' + repr(value) + ')\n'
        # redraw?
        if(redraw):
          plotobject.myRefresh()

  def setAxisLabel(self, labeltext=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      # updates axis label
      if(labeltext == None):
        labeltext = axis

      if(axis == 'x'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; figobject = self.matplot; axisname = 'ax2'
          if((self.labelX == labeltext) or (not self.labelXShow)):
            redraw = False
          self.labelX = labeltext
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; figobject = self.residplot; axisname = 'ax_resid'
          if((self.labelX_resid == labeltext) or (not self.labelXShow_resid)):
            redraw = False
          self.labelX_resid = labeltext
        # manually process escape characters
        labeltext = labeltext.replace('\n', '\\n')
        labeltext = labeltext.replace('\t', '\\t')
        labeltext = '\n'.join([i for i in labeltext.split('\\n') if (len(i.strip()))])
        labeltext = '\t'.join([i for i in labeltext.split('\\t') if (len(i.strip()))])
        # check for potential Mathtext errors
        prevLabel = axisobject.xaxis.get_label_text()
        axisobject.xaxis.set_label_text(labeltext)
        try:
          axisobject.xaxis.label._get_layout(figobject.canvas.renderer)
        except:
          # revert to previous label
          self.parent.statusbar.showMessage('Cannot set axis label to' + labeltext, self.parent.STATUS_TIME)
          
          axisobject.xaxis.set_label_text(prevLabel)
          labeltext = prevLabel
          redraw = False
      elif(axis == 'y'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax; figobject = self.matplot; axisname = 'ax'
          if((self.labelY == labeltext) or (not self.labelYShow)):
            redraw = False
          self.labelY = labeltext
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; figobject = self.residplot; axisname = 'ax_resid'
          if((self.labelY_resid == labeltext) or (not self.labelYShow_resid)):
            redraw = False
          self.labelY_resid = labeltext
        # manually process escape characters
        labeltext = labeltext.replace('\n', '\\n')
        labeltext = labeltext.replace('\t', '\\t')
        labeltext = '\n'.join([i for i in labeltext.split('\\n') if (len(i.strip()))])
        labeltext = '\t'.join([i for i in labeltext.split('\\t') if (len(i.strip()))])
        if((target == 'resid') and (labeltext != '')):
          labeltext = u'\N{GREEK CAPITAL LETTER DELTA}' + labeltext
        # check for potential Mathtext errors
        prevLabel = axisobject.yaxis.get_label_text()
        axisobject.yaxis.set_label_text(labeltext)
        try:
          axisobject.yaxis.label._get_layout(figobject.canvas.renderer)
        except:
          # revert to previous label
          self.parent.statusbar.showMessage('Cannot set axis label to' + labeltext, self.parent.STATUS_TIME)
          axisobject.yaxis.set_label_text(prevLabel)
          labeltext = prevLabel
          redraw = False
      elif(axis == 'y2'):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; figobject = self.matplot; axisname = 'ax2'
          if((self.labelY2 == labeltext) or (not self.labelY2Show)):
            redraw = False
          self.labelY2 = labeltext
          # manually process escape characters
          labeltext = labeltext.replace('\n', '\\n')
          labeltext = labeltext.replace('\t', '\\t')
          labeltext = '\n'.join([i for i in labeltext.split('\\n') if (len(i.strip()))])
          labeltext = '\t'.join([i for i in labeltext.split('\\t') if (len(i.strip()))])
          # check for potential Mathtext errors
          prevLabel = axisobject.yaxis.get_label_text()
          axisobject.yaxis.set_label_text(labeltext)
          try:
            axisobject.yaxis.label._get_layout(figobject.canvas.renderer)
          except:
            # revert to previous label
            self.parent.statusbar.showMessage('Cannot set axis label to' + labeltext, self.parent.STATUS_TIME)
            axisobject.yaxis.set_label_text(prevLabel)
            labeltext = prevLabel
            redraw = False
        else:
          axis = 'abort'
                        
      # remember settings
      if(axis != 'abort'):
        self.rememberSetting[axisname + '_axisLabel' + axis] = axisname + '.' + axis[:1] + 'axis.set_label_text(' + repr(labeltext) + ')\n'
  
        # capture errors with bad fonts (can occur when switching back from all-Mathtext label)
        try:
          if(redraw):
            plotobject.myRefresh()
        except:
          safeFont = 'DejaVu Sans'
          self.parent.statusbar.showMessage('Experiencing problems with font ' + self.axisFont[axis] + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.axisFont[axis] = safeFont
          if(axis == 'x'):
            axisobject.xaxis.label.set_fontname(safeFont)
          else:
            axisobject.yaxis.label.set_fontname(safeFont)
  
          # adjust remember settings 
          self.rememberSetting[axisname + '_axisFont' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_fontname(' + repr(safeFont) + ')\n'
  
          if(redraw):
            plotobject.myRefresh()

  def setAxisVisibility(self, value=True, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(self.axisVisible[axis] == value):
            redraw = False
          self.axisVisible[axis] = value
          if(axis in ['left', 'right']):
            axisname = 'ax'
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisVisible_resid[axis] == value):
              redraw = False
            self.axisVisible_resid[axis] = value

        # sets axis visibility
        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_visible(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_visible(value)
  
          # need to solve inner situation
          self.updateInnerSituation()

          # remember settings
          self.rememberSetting[axisname + '_axisVisibility' + axis] = axisname + '.spines[' + repr(axis) + '].set_visible(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisColor(self, value=True, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(self.axisColor[axis] == value):
            redraw = False
          self.axisColor[axis] = value
          if(axis in ['left', 'right']):
            axisname = 'ax'
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisColor_resid[axis] == value):
              redraw = False
            self.axisColor_resid[axis] = value

        # set axis color
        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_color(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_color(value)
          
          # remember settings
          self.rememberSetting[axisname + '_axisColor' + axis] = axisname + '.spines[' + repr(axis) + '].set_color(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisWidth(self, value=1.0, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(self.axisWidth[axis] == value):
            redraw = False
          self.axisWidth[axis] = value
          if(axis in ['left', 'right']):
            axisname = 'ax'
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisWidth_resid[axis] == value):
              redraw = False
            self.axisWidth_resid[axis] = value

        # updates axis width
        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_linewidth(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_linewidth(value)
  
          # remember settings
          self.rememberSetting[axisname + '_axisWidth' + axis] = axisname + '.spines[' + repr(axis) + '].set_linewidth(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisFont(self, value=None, axis='x', redraw=True, target='plot'):
    defaultFont = 'DejaVu Sans'
    # check whether font exists
    if(not (value in self.parent.fontNames)):
      value = defaultFont
    if(value in self.parent.fontNames):
      # check whether to operate on data or resid plot
      if(target in ['plot', 'resid']):
        if(axis in ['x', 'y', 'y2']):
          if(target == 'plot'):
            prevFont = self.axisFont[axis]
            plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
            if(axis == 'y'):
              axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if(self.axisFont[axis] == value):
              redraw = False
            self.axisFont[axis] = value
          else:
            if(axis == 'y2'):
              axis = 'abort'
            else:
              prevFont = self.axisFont_resid[axis]
              plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
              if(self.axisFont_resid[axis] == value):
                redraw = False
              self.axisFont_resid[axis] = value

          if(axis != 'abort'):
            if(axis == 'x'):
              axisobject.xaxis.label.set_fontname(value)
              axisobject2.xaxis.label.set_fontname(value)
            else:
              axisobject.yaxis.label.set_fontname(value)
              axisobject2.yaxis.label.set_fontname(value)
  
            # have to capture errors in case a strange font is set
            try:
              if(redraw):
                plotobject.myRefresh()
            except:
              self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)
              
              # revert to previous font
              value = prevFont
              if(target == 'plot'):
                self.axisFont[axis] = prevFont
              else:
                self.axisFont_resid[axis] = prevFont
  
              if(axis == 'x'):
                axisobject.xaxis.label.set_fontname(prevFont)
                axisobject2.xaxis.label.set_fontname(prevFont)
              else:
                axisobject.yaxis.label.set_fontname(prevFont)
                axisobject2.yaxis.label.set_fontname(prevFont)
  
              # also capture errors with previous font (can happen if selecting two bad fonts in a row)
              try:
                if(redraw):
                  plotobject.myRefresh()
              except:
                safeFont = 'DejaVu Sans'
                self.parent.statusbar.showMessage('Also experiencing problems setting font ' + self.axisFont[axis] + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
  
                # revert to previous font
                value = safeFont
                if(target == 'plot'):
                  self.axisFont[axis] = safeFont
                else:
                  self.axisFont_resid[axis] = safeFont
    
                if(axis == 'x'):
                  axisobject.xaxis.label.set_fontname(safeFont)
                  axisobject2.xaxis.label.set_fontname(safeFont)
                else:
                  axisobject.yaxis.label.set_fontname(safeFont)
                  axisobject2.yaxis.label.set_fontname(safeFont)
  
            # remember settings
            self.rememberSetting[axisname + '_axisFont' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_fontname(' + repr(value) + ')\n'

  def setAxisLabelAlignment(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'

        if(axis == 'x'):
          axisobject.xaxis.label.set_horizontalalignment(value)
          axisobject2.xaxis.label.set_horizontalalignment(value)
          direction = 'horizontal'
          if(target == 'plot'):
            if((self.labelXAlignment == value) or (not self.labelXShow)):
              redraw = False
            self.labelXAlignment = value
          else:
            if((self.labelXAlignment_resid == value) or (not self.labelXShow_resid)):
              redraw = False
            self.labelXAlignment_resid = value
        elif(axis == 'y'):
          if(target == 'plot'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.labelYAlignment == value) or (not self.labelYShow)):
              redraw = False
            self.labelYAlignment = value
          else:
            if((self.labelYAlignment_resid == value) or (not self.labelYShow_resid)):
              redraw = False
            self.labelYAlignment_resid = value
          axisobject.yaxis.label.set_horizontalalignment(value)
          axisobject2.yaxis.label.set_horizontalalignment(value)
          direction = 'horizontal'
        elif(axis == 'y2'):
          if(target == 'plot'):
            axisobject.yaxis.label.set_horizontalalignment(value)
            axisobject2.yaxis.label.set_horizontalalignment(value)
            direction = 'horizontal'
            if((self.labelY2Alignment == value) or (not self.labelYShow_resid)):
              redraw = False
            self.labelY2Alignment = value
          else:
            axis = 'abort'

        # remember settings
        if(axis != 'abort'):
          self.rememberSetting[axisname + '_axisAlignment' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_' + direction + 'alignment(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisLabelAlignmentVertical(self, value=None, axis='x', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'

        if(axis == 'x'):
          axisobject.xaxis.label.set_verticalalignment(value)
          axisobject2.xaxis.label.set_verticalalignment(value)
          direction = 'vertical'
          if(target == 'plot'):
            if((self.labelXAlignmentVertical == value) or (not self.labelXShow)):
              redraw = False
            self.labelXAlignmentVertical = value
          else:
            if((self.labelXAlignmentVertical_resid == value) or (not self.labelXShow_resid)):
              redraw = False
            self.labelXAlignmentVertical_resid = value
        elif(axis == 'y'):
          if(target == 'plot'):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
            if((self.labelYAlignmentVertical == value) or (not self.labelYShow)):
              redraw = False
            self.labelYAlignmentVertical = value
          else:
            if((self.labelYAlignmentVertical_resid == value) or (not self.labelYShow_resid)):
              redraw = False
            self.labelYAlignmentVertical_resid = value
          axisobject.yaxis.label.set_verticalalignment(value)
          axisobject2.yaxis.label.set_verticalalignment(value)
          direction = 'vertical'
        elif(axis == 'y2'):
          if(target == 'plot'):
            axisobject.yaxis.label.set_verticalalignment(value)
            axisobject2.yaxis.label.set_verticalalignment(value)
            direction = 'vertical'
            if((self.labelY2AlignmentVertical == value) or (not self.labelY2Show)):
              redraw = False
            self.labelY2AlignmentVertical = value
          else:
            axis = 'abort'

        # remember settings
        if(axis != 'abort'):
          self.rememberSetting[axisname + '_axisAlignmentVertical' + axis] = axisname + '.' + axis[:1] + 'axis.label.set_' + direction + 'alignment(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()
          
  def setTickFont(self, value=None, axis='x', redraw=True, target='plot'):
    defaultFont = 'DejaVu Sans'
    # check whether font exists
    if(not (value in self.parent.fontNames)):
      value = defaultFont
    if(value in self.parent.fontNames):
      # check whether to operate on data or resid plot
      if(target in ['plot', 'resid']):
        if(axis in ['x', 'y', 'y2']):
          if(target == 'plot'):
            prevFont = self.tickFont[axis]
            plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
            if(axis == 'y'):
              axisobject = self.ax; axisname = 'ax'
            if(self.tickFont[axis] == value):
              redraw = False
            self.tickFont[axis] = value
          else:
            prevFont = self.tickFont_resid[axis]
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.tickFont_resid[axis] == value):
              redraw = False
            self.tickFont_resid[axis] = value
        
          # updates tick font
          if(axis == 'x'):
            tickLabels = axisobject.get_xticklabels(which='both')
            tickLabels.append(axisobject.xaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_xticklabels(which='both'))
            tickLabels.append(axisobject2.xaxis.get_offset_text())
          elif(axis == 'y'):
            tickLabels = axisobject.get_yticklabels(which='both')
            tickLabels.append(axisobject.yaxis.get_offset_text())
            tickLabels.extend(axisobject2.get_yticklabels(which='both'))
            tickLabels.append(axisobject2.yaxis.get_offset_text())
          elif(axis == 'y2'):
            if(target == 'plot'):
              tickLabels = axisobject.get_yticklabels(which='both')
              tickLabels.append(axisobject.yaxis.get_offset_text())
              tickLabels.extend(axisobject2.get_yticklabels(which='both'))
              tickLabels.append(axisobject2.yaxis.get_offset_text())
            else:
              axis = 'abort'
          
          if(axis != 'abort'):
            for entry in tickLabels:
              entry.set_fontname(value)
  
            # have to capture errors in case a strange font is set
            try:
              if(redraw):
                plotobject.myRefresh()
            except:
              self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + prevFont, self.parent.STATUS_TIME)
              
              # revert to previous font
              value = prevFont
              if(target == 'plot'):
                self.tickFont[axis] = prevFont
              else:
                self.tickFont_resid[axis] = prevFont
                
              for entry in tickLabels:
                entry.set_fontname(prevFont)
  
              # also capture errors with previous font (can happen if selecting two bad fonts in a row)
              try:
                if(redraw):
                  plotobject.myRefresh()
              except:
                safeFont = 'DejaVu Sans'
                self.parent.statusbar.showMessage('Also experiencing problems setting font ' + self.legendLabelFont + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
  
                # revert to previous font
                value = safeFont
                if(target == 'plot'):
                  self.tickFont[axis] = safeFont
                else:
                  self.tickFont_resid[axis] = safeFont
  
                for entry in tickLabels:
                  entry.set_fontname(safeFont)
  
            # remember settings
            self.rememberSetting[axisname + '_axisTickFont' + axis] = 'tickLabels = ' + axisname + '.get_' + axis[:1] + 'ticklabels()\n'
            self.rememberSetting[axisname + '_axisTickFont' + axis] += 'tickLabels.append(' + axisname + '.' + axis[:1] + 'axis.get_offset_text())\n'
            self.rememberSetting[axisname + '_axisTickFont' + axis] += 'for entry in tickLabels:\n\tentry.set_fontname(' + repr(value) + ')\n'

  def setMinorTick(self, value=2, axis='x', redraw=True, target='plot'):
    # changes number of minor tick marks (on linear axes)
    if(target in ['plot', 'resid']):
      if(axis in ['x', 'y', 'y2', 'x2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisname = 'ax2'
          if(axis == 'x'):
            if(self.ticksXMinor == value):
              redraw = False
            self.ticksXMinor = value
          elif(axis == 'x2'):
            axisobject = self.ax2_div
            if(self.ticksXMinor_div == value):
              redraw = False
            self.ticksXMinor_div = value
          elif(axis == 'y'):
            axisobject = self.ax; axisname = 'ax'
            if(self.ticksYMinor == value):
              redraw = False
            self.ticksYMinor = value
          else:
            if(self.ticksY2Minor == value):
              redraw = False
            self.ticksY2Minor = value
        else:
          plotobject = self.residplotwidget; axisobject = self.ax_resid; axisname = 'ax_resid'
          if(axis == 'y'):
            if(self.ticksResidYMinor == value):
              redraw = False
            self.ticksResidYMinor = value
          elif(axis == 'x2'):
            axisobject = self.ax_resid_div

        # remember settings
        if(axis != 'abort'):
          minorAutoticks = MyAutoMinorLocator(value)
          if(axis in ['x', 'x2']):
            axisobject.xaxis.set_minor_locator(minorAutoticks)
            axisobject.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          else:
            axisobject.yaxis.set_minor_locator(minorAutoticks)
            axisobject.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
          if(axis != 'x2'):
            self.rememberSetting[axisname + '_minorTicks' + axis] = 'minorAutoticks = matplotlib.ticker.AutoMinorLocator(' + repr(value) + ')\n'
            self.rememberSetting[axisname + '_minorTicks' + axis] += axisname + '.' + axis[:1] + 'axis.set_minor_locator(minorAutoticks)\n'
        elif(axis != 'x2'):
          # undo setting if log axes
          self.rememberSetting[axisname + '_minorTicks' + axis] = ''

        # redraw?
        if(axis != 'abort') :
          if(redraw):
            plotobject.myRefresh()

  def setAxisStyle(self, value='solid', axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if(self.axisStyle[axis] == value):
            redraw = False
          self.axisStyle[axis] = value
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisStyle_resid[axis] == value):
              redraw = False
            self.axisStyle_resid[axis] = value

        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_linestyle(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_linestyle(value)
  
          # remember settings
          self.rememberSetting[axisname + '_axisStyle' + axis] = axisname + '.spines[' + repr(axis) + '].set_linestyle(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisDashStyle(self, value='solid', axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if(self.axisDashStyle[axis] == value):
            redraw = False
          self.axisDashStyle[axis] = value
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisDashStyle_resid[axis] == value):
              redraw = False
            self.axisDashStyle_resid[axis] = value

        if(axis != 'abort'):
          if(axis in axisobject.spines):
            axisobject.spines[axis].set_capstyle(value)
          if(axis in axisobject2.spines):
            axisobject2.spines[axis].set_capstyle(value)
  
          # remember settings
          self.rememberSetting[axisname + '_axisDashStyle' + axis] = axisname + '.spines[' + repr(axis) + '].set_capstyle(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def resetAxisPosition(self, axis='left'):
    # resets axis position to original values
    originalPosition = {'left':('axes', 0), 'right':('axes', 1.0), 'bottom':('axes', 0), 'top':('axes', 1.0), 'left2':('axes', 0), 'right2':('axes', 1.0)}
    if(axis in originalPosition):
      # check whether to do anything
      if((originalPosition[axis][0] != self.axisPosition[axis]) or (originalPosition[axis][1] != self.axisPositionValue[axis])):
        for target in ['plot', 'resid']:
          self.setAxisPosition(value=originalPosition[axis][0], axis=axis, redraw=False, target=target)
          self.setAxisPositionValue(value=originalPosition[axis][1], axis=axis, redraw=False, target=target)
        # refresh plots
        self.dataplotwidget.myRefresh()
        self.residplotwidget.myRefresh()

  def setAxisPosition(self, value='axes', axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        secondAxes = False
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div; axisname = 'ax'
          if(self.axisPosition[axis] == value):
            redraw = False
          self.axisPosition[axis] = value
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
            secondAxes = True
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisPosition_resid[axis] == value):
              redraw = False
            self.axisPosition_resid[axis] = value

        if(axis != 'abort'):
          if(axis in axisobject.spines):
            value = self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=axisobject, target=target, secondAxes=secondAxes)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=axisobject2, target=target, secondAxes=secondAxes, splitX=True)
            # remember settings
            self.rememberSetting[axisname + '_axisPosition' + axis] = axisname + '.spines[' + repr(axis) + '].set_position(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisPositionValue(self, value=1.0, axis='left', redraw=True, target='plot'):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      if(axis in ['left', 'right', 'bottom', 'top', 'left2', 'right2']):
        secondAxes = False
        if(target == 'plot'):
          plotobject = self.dataplotwidget; axisobject = self.ax2; axisobject2 = self.ax2_div; axisname = 'ax2'
          if(axis in ['left', 'right']):
            axisobject = self.ax; axisobject2 = self.ax_div
          if(self.axisPositionValue[axis] == value):
            redraw = False
          self.axisPositionValue[axis] = value
          if(axis in ['left', 'right']):
            axisname = 'ax'
          if(axis in ['left2', 'right2']):
            axis = axis[:-1]
            secondAxes = True
        else:
          if(axis in ['left2', 'right2']):
            axis = 'abort'
          else:
            plotobject = self.residplotwidget; axisobject = self.ax_resid; axisobject2 = self.ax_resid_div; axisname = 'ax_resid'
            if(self.axisPositionValue_resid[axis] == value):
              redraw = False
            self.axisPositionValue_resid[axis] = value

        # updates axis width
        if(axis != 'abort'):
          if(axis in axisobject.spines):
            value = self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=axisobject, target=target, secondAxes=secondAxes)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=axisobject2, target=target, secondAxes=secondAxes, splitX=True)
            # remember settings
            self.rememberSetting[axisname + '_axisPosition' + axis] = axisname + '.spines[' + repr(axis) + '].set_position(' + repr(value) + ')\n'
          # redraw?
          if(redraw):
            plotobject.myRefresh()

  def setAxisPositionHelper(self, axis, plotobject, axisobject, target, secondAxes=False, splitX=False):
    # called by setAxisPosition
    # duh, this is ugly!
    # the following call breaks the connection b/w spine and axis and thus disables detrimental updates to ticks and labels
    saveAxis = axisobject.spines[axis].axis
    axisobject.spines[axis].axis = None
    # assign useModeX and transAxisobject1/2
    if(splitX):
      useModeX, useMinX, transAxisobject1, transAxisobject2  = self.modeX_div, self.minX_div, self.ax_div, self.ax2_div
      ##useModeX, useMinX, transAxisobject1, transAxisobject2  = self.modeX_div, self.minX_div, self.ax, self.ax2
      transAxisobjectResid = self.ax_resid_div
    else:
      useModeX, useMinX, transAxisobject1, transAxisobject2 = self.modeX, self.minX, self.ax, self.ax2
      transAxisobjectResid = self.ax_resid
    #
    if(secondAxes):
      if((self.axisPosition[axis + '2'] == 'data') and (useModeX == 'log')):
        # matplotlib somehow screws up for log data (a bug I discovered!) => map to plot axes
        try:
          # have to do this b/c matplotlib.scale on Linux is buggy
          axis_to_data = transAxisobject1.transAxes + transAxisobject1.transData.inverted()
          point_on_data = (self.axisPositionValue[axis + '2'], self.minY)
          point_on_axes = axis_to_data.inverted().transform(point_on_data)
          assembledValue = ('axes', point_on_axes[0])
        except:
          assembledValue = ('outward', 0.0)
      else:
        assembledValue = (self.axisPosition[axis + '2'], self.axisPositionValue[axis + '2'])
    elif(target == 'plot'):
      if(axis in ['top', 'bottom']):
        # argh -- top and bottom are on self.ax2, meaning they are linked to the second axes
        # => we hence need to convert data values from one axis to the other
        if(self.axisPosition[axis] == 'data'):
          try:
            # have to do this b/c matplotlib.scale on Linux is buggy
            axis_to_data1 = transAxisobject1.transAxes + transAxisobject1.transData.inverted()
            axis_to_data2 = transAxisobject2.transAxes + transAxisobject2.transData.inverted()
            point_on_data1 = (useMinX, self.axisPositionValue[axis])
            # map to axes
            point_on_axes = axis_to_data1.inverted().transform(point_on_data1)
            # map to 2nd data -- do we really need this? (I mean we are updating this on every setAxisLimits anyhow)
            ###if(0):
            ###  print(splitX, point_on_data1, point_on_axes, inspect.stack()[1][3])
            if(0):
              point_on_data2 = axis_to_data2.transform(point_on_axes)
              assembledValue = (self.axisPosition[axis], point_on_data2[1])
            else:
              assembledValue = ('axes', point_on_axes[1])
          except:
            assembledValue = ('outward', 0.0)
        else:
          assembledValue = (self.axisPosition[axis], self.axisPositionValue[axis])
      else:
        if((self.axisPosition[axis] == 'data') and (useModeX == 'log')):
          # matplotlib somehow screws up for log data (a bug I discovered!) => map to plot axes
          try:
            # have to do this b/c matplotlib.scale on Linux is buggy
            axis_to_data2 = transAxisobject2.transAxes + transAxisobject2.transData.inverted()
            point_on_data2 = (self.axisPositionValue[axis], self.minY2)
            point_on_axes = axis_to_data2.inverted().transform(point_on_data2)
            assembledValue = ('axes', point_on_axes[0])
            ###if(0):
            ###  print(splitX, point_on_data2, point_on_axes, inspect.stack()[1][3])
          except:
            assembledValue = ('outward', 0.0)
        else:
          assembledValue = (self.axisPosition[axis], self.axisPositionValue[axis])
    else:
      # the resid plot
      if(axis in ['left', 'right']):
        if((self.axisPosition[axis] == 'data') and (useModeX == 'log')):
          # deal with matplotlib error => map to plot axes
          try:
            # have to do this b/c matplotlib.scale on Linux is buggy
            axis_to_data = transAxisobjectResid.transAxes + transAxisobjectResid.transData.inverted()
            point_on_data = (self.axisPositionValue[axis], self.minResidY)
            point_on_axes = axis_to_data.inverted().transform(point_on_data)
            assembledValue = ('axes', point_on_axes[0])
          except:
            assembledValue = ('outward', 0.0)
        else:
          assembledValue = (self.axisPosition[axis], self.axisPositionValue[axis])
      else:
        assembledValue = (self.axisPosition[axis], self.axisPositionValue[axis])
      
    # set the new axis mode and value
    axisobject.spines[axis].set_position(assembledValue)
    if(splitX):
      pass
      #print(assembledValue)

    # for good measure restore axis setting
    axisobject.spines[axis].axis = saveAxis
    
    # now we have to manually update the position of the tick labels and ticks
    if(axis in ['left', 'right']):
      ticks = axisobject.yaxis.get_major_ticks()
      ticks.extend(axisobject.yaxis.get_minor_ticks())
      if(axis == 'left'):
        useTransform = axisobject.get_yaxis_transform(which='tick1')
        tick1 = True
      else:
        useTransform = axisobject.get_yaxis_transform(which='tick2')
        tick1 = False
    else:
      ticks = axisobject.xaxis.get_major_ticks()
      ticks.extend(axisobject.xaxis.get_minor_ticks())
      if(axis == 'bottom'):
        useTransform = axisobject.get_xaxis_transform(which='tick1')
        tick1 = True
      else:
        useTransform = axisobject.get_xaxis_transform(which='tick2')
        tick1 = False

    horizontal = True        
    if(target == 'plot'):
      plotobject = self.matplot
      if(axis in ['left', 'right']):
        usePad = self.ticksYPad2
        horizontal = False
        if(secondAxes):
          usePad = self.ticksY2Pad2
      elif(axis in ['bottom', 'top']):
        usePad = self.ticksXPad2
    else:
      plotobject = self.residplot
      if(axis in ['left', 'right']):
        usePad = self.ticksYPad2_resid
        horizontal = False
      else:
        usePad = self.ticksXPad2_resid

    for entry in ticks:
      if(tick1):
        entry.tick1line.set_transform(useTransform)
        trans, vert, horiz = entry._get_text1_transform()
        # also have to apply pad2 padding - phew!
        if(horizontal):
          offset = matplotlib.transforms.ScaledTranslation(usePad / 72.0, 0.0, plotobject.dpi_scale_trans)
        else:
          offset = matplotlib.transforms.ScaledTranslation(0.0, usePad / 72.0, plotobject.dpi_scale_trans)
        trans += offset
        entry.label1.set_transform(trans)
      else:
        entry.tick2line.set_transform(useTransform)
        trans, vert, horiz = entry._get_text2_transform()
        # also have to apply pad2 padding - phew!
        if(horizontal):
          offset = matplotlib.transforms.ScaledTranslation(usePad / 72.0, 0, plotobject.dpi_scale_trans)
        else:
          offset = matplotlib.transforms.ScaledTranslation(0, usePad / 72.0, plotobject.dpi_scale_trans)
        trans += offset
        entry.label2.set_transform(trans)

    return repr(assembledValue)

  def setAutoScale(self, axis='x'):
    # updates autoscale options for axes
    if(axis in ['x', 'y', 'y2', 'x2']):
      if(axis == 'x'):
        state = self.autoScaleCheckX.isChecked()
        self.autoScaleX = state
      elif(axis == 'x2'):
        state = self.xSplitAutoScaleCheckX.isChecked()
        self.autoScaleX_div = state
      elif(axis == 'y'):
        state = self.autoScaleCheckY.isChecked()
        self.autoScaleY = state
      else:
        state = self.secondAutoScaleCheckY.isChecked()
        self.autoScaleY2 = state
        
      # rescale contents on setting auto to True
      if(state):
        self.doAutoScale(axis=axis)
        
  def doAutoScale(self, axis='x'):
    # performs autoscale on axis
    if(axis in ['x', 'y', 'y2', 'x2']):
      currData, currRoles = self.parent.data[self.parent.activeData].getData_n_Fit()
      # we have some data that we could zoom to
      if(axis in ['x', 'x2']):
        if(axis == 'x'):
          useModeX = self.modeX
        else:
          useModeX = self.modeX_div
        if(('x' in currRoles) and (len(list(currData[:, currRoles.index('x')])))):
          xval = list(currData[:, currRoles.index('x')])
          if('xerr' in currRoles):
            xerr = list(currData[:, currRoles.index('xerr')])
            temp_xmin = np.min([i-j for i, j in zip(xval, xerr)])
            temp_xmax = np.max([i+j for i, j in zip(xval, xerr)])
          else:
            temp_xmin = np.min(xval)
            temp_xmax = np.max(xval)
            
          # ensure minimum limit
          if(temp_xmax - temp_xmin < self.EPSILON):
            temp_xmax += self.EPSILON; temp_xmin -= self.EPSILON
          elif(self.data_spacer > 0):
            if(useModeX == 'linear'):
              difference = temp_xmax - temp_xmin
              temp_xmax += difference * self.data_spacer
              temp_xmin -= difference * self.data_spacer
            else:
              # log scale -- isolate positive data
              pos_x = np.array(xval)
              pos_x = pos_x[pos_x > 0]
              pos_x = np.array([i for i in pos_x if ((not np.isnan(i)) and (not np.isinf(i)))])
              if(len(pos_x > 1)):
                # recalc. xmin to address error when restoring state
                temp_xmin, temp_xmax = np.min(pos_x), np.max(pos_x)
                difference = np.log(pos_x[-1] / pos_x[0])
                temp_xmin = np.exp(np.log(temp_xmin) - self.data_spacer * difference)
                temp_xmax = np.exp(np.log(temp_xmax) + self.data_spacer * difference)
          
          if(axis == 'x'):
            self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x', updateLabel=True, target='resid', redraw=False, updateGrid=True)
            # plot current function over new x-range
            self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
              fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot,\
              redraw=True)
            # plot zeroResid line over new x-range
            self.parent.plotArea.handleResidZero = self.parent.plotArea.plotResidZero(\
              handleResidZero=self.parent.plotArea.handleResidZero, redraw=True)
          else:
            self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x2', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis='x2', updateLabel=True, target='resid', redraw=False, updateGrid=True)
            # plot current function over new x-range
            self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
              fitobject=self.parent.fit[self.parent.activeFit], x=[], handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,\
              redraw=True, splitX=True)
            # plot zeroResid line over new x-range
            self.parent.plotArea.handleResidZero_div = self.parent.plotArea.plotResidZero(\
              handleResidZero=self.parent.plotArea.handleResidZero_div, redraw=True, splitX=True)
      else:
        dataAxesFlag = self.parent.data[self.parent.activeData].onSecondAxes
        # only consider active function and data if on current y axis
        if(axis == 'y'):
          if(self.splitShow):
            funcY = np.hstack((self.y, self.y_div))
          else:
            funcY = self.y
          dataAxesFlag = not dataAxesFlag
        else:
          if(self.splitShow):
            funcY = np.hstack((self.y2, self.y2_div))
          else:
            funcY = self.y2
        # check whether curve is visible at all
        if(not self.parent.fit[self.parent.activeFit].visibility):
          funcY = []
        # consider data (and only if it is visible)
        if(('y' in currRoles) and (len(list(currData[:, currRoles.index('y')]))) and dataAxesFlag and self.parent.data[self.parent.activeData].visibility):
          yval = list(currData[:, currRoles.index('y')])
          if(len(yval)):
            if('yerr' in currRoles):
              yerr = list(currData[:, currRoles.index('yerr')])
              temp_y = np.array([i-j for i, j in zip(yval, yerr)])
              temp_y = np.hstack((temp_y, np.array([i+j for i, j in zip(yval, yerr)])))
            else:
              temp_y = yval
            temp_y = np.hstack((funcY, temp_y))
          else:
            temp_y = funcY
        else:
          temp_y = funcY
          
        temp_y = np.array([i for i in temp_y if ((not np.isnan(i)) and (not np.isinf(i)))])
        # ensure that temp_y is at least one element long
        if(temp_y.size):
          temp_ymin = np.min(temp_y)
          temp_ymax = np.max(temp_y)
  
          # ensure minimum limit
          if (temp_ymax - temp_ymin < self.EPSILON):
            temp_ymax += self.EPSILON; temp_ymin -= self.EPSILON
          elif(self.data_spacer > 0):
            if(axis == 'y'):
              useMode = self.modeY
            else:
              useMode = self.modeY2
            if(useMode == 'linear'):
              difference = temp_ymax - temp_ymin
              temp_ymax += difference * self.data_spacer
              temp_ymin -= difference * self.data_spacer
            else:
              # log scale -- isolate positive data
              pos_y = np.array(temp_y)
              pos_y = pos_y[pos_y > 0]
              if(len(pos_y > 1)):
                # recalc. xmin to address error when restoring state
                temp_ymin, temp_ymax = np.min(pos_y), np.max(pos_y)
                difference = np.log(temp_ymax / temp_ymin)
                temp_ymin = np.exp(np.log(temp_ymin) - self.data_spacer * difference)
                temp_ymax = np.exp(np.log(temp_ymax) + self.data_spacer * difference)
          
          self.setAxisLimits(lower = temp_ymin, upper = temp_ymax, axis = axis, updateLabel = True, target='plot', redraw=True, updateGrid=True)

  def rectSelectorCallback(self, event_click, event_release):
    # handles interactive zoom in plot
    MIN_SELECTION_BOX = 5
    flag = False
    # handle button reactions
    if(event_click.button == 1):
      # check wether selection box is at least minimum size
      if((np.abs(event_click.x - event_release.x) >= MIN_SELECTION_BOX) and (np.abs(event_click.y - event_release.y) >= MIN_SELECTION_BOX)):
        # left mouse button => zoom
        # only proceed if at least one coord changed since last click (this is to prevent rectangle selector from misbehainvg)
        if((event_click.x != self.previousClick[0]) or (event_click.y != self.previousClick[1]) or (event_release.x != self.previousClick[2]) or (event_release.y != self.previousClick[3])):
          x1, y1 = event_click.xdata, event_click.ydata
          x2, y2 = event_release.xdata, event_release.ydata
          xmin = np.min((x1, x2)); xmax = np.max((x1, x2))
          ymin = np.min((y1, y2)); ymax = np.max((y1, y2))
          
          # transform coordinates to second y axis
          secondY1 = self.ax2.transData.inverted().transform((event_click.x, event_click.y))
          secondY2 = self.ax2.transData.inverted().transform((event_release.x, event_release.y))
          secondYmin = np.min((secondY1[1], secondY2[1])); secondYmax = np.max((secondY1[1], secondY2[1]))
          
          # store current axis limits
          self.storeCoord.extend((self.minX, self.minY, self.maxX, self.maxY))
          self.storeCoord2.extend((self.minX, self.minY2, self.maxX, self.maxY2))
          flag = True
          
          # update self.previousClick
          self.previousClick = [event_click.x, event_click.y, event_release.x, event_release.y]
    elif(event_click.button == 3):
      # update self.previousClick
      self.previousClick = [event_click.x, event_click.y, event_release.x, event_release.y]
      # right mouse button => unzoom
      if(len(self.storeCoord) > 0):
        [xmin, ymin, xmax, ymax] = self.storeCoord[-4:]
        self.storeCoord = self.storeCoord[:-4]
        flag = True
      if(len(self.storeCoord2) > 0):
        [xmin, secondYmin, xmax, secondYmax] = self.storeCoord2[-4:]
        self.storeCoord2 = self.storeCoord2[:-4]
        flag = True
        
    # set axes limits if required
    if(flag):
      self.setAxisLimits(lower = xmin, upper = xmax, axis = 'x', updateLabel = True, target='plot', redraw=False, updateGrid=True)
      self.setAxisLimits(lower = xmin, upper = xmax, axis = 'x', updateLabel = False, target='resid', redraw=False, updateGrid=True)
      # trigger redrawing of fit function with new axis limits
      self.parent.fit[self.parent.activeFit].handlePlot = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                     handlePlot=self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
      self.handleResidZero = self.plotResidZero(self.handleResidZero, redraw=True)

      # hide rectangle selector prior to redraw
      self.rectSelector.eventpress = None
      self.rectSelector.eventrelease = None
      self.rectSelector.to_draw.set_visible(False)
 
      # reset y axis
      self.setAxisLimits(lower=secondYmin, upper=secondYmax, axis='y2', updateLabel=True, target='plot', redraw=False, updateGrid=True)
      self.setAxisLimits(lower=ymin, upper=ymax, axis='y', updateLabel=True, target='plot', redraw=True, updateGrid=True)

  def setPathStroke(self, state=True, redraw=True):
    # applies path stroke
    self.applyPathStroke = state
    self.setPathEffects(redraw=redraw)

  def setPathStrokeColor(self, value=4*[0.0], redraw=True):
    # changes color of path stroke
    self.pathStrokeColor = value
    # do the path setting draw?
    if((redraw) and (self.applyPathStroke)):
      self.setPathEffects(redraw=redraw)

  def setPathStrokeWidth(self, value=1.0, redraw=True):
    # changes witdth of path stroke
    self.pathStrokeWidth = value
    # do the path setting draw?
    if((redraw) and (self.applyPathStroke)):
      self.setPathEffects(redraw=redraw)

  def setPathShadow(self, state=True, redraw=True):
    # applies path shadow
    self.applyPathShadow = state
    self.setPathEffects(redraw=redraw)

  def setPathShadowColor(self, value=4*[0.0], redraw=True):
    # changes color of path shadow
    self.pathShadowColor = value
    self.pathShadowAlpha = value[-1]
    # do the path setting draw?
    if((redraw) and (self.applyPathShadow)):
      self.setPathEffects(redraw=redraw)

  def setPathShadowOffset(self, value=1.0, direction='x', redraw=True):
    # changes offset of path shadow
    if(direction in ['x', 'y']):
      if(direction == 'x'):
        self.pathShadowX = value
      else:
        self.pathShadowY = value
      # do the path setting draw?
      if((redraw) and (self.applyPathShadow)):
        self.setPathEffects(redraw=redraw)

  def setPathEffects(self, redraw=True):
    # applies path effects
    if(self.applyPathStroke):
      baseEffect = []
      tempRememberSetting = ''
    else:
      baseEffect = [PathEffects.Normal()]
      tempRememberSetting = 'PathEffects.Normal()'

    if(self.applyPathShadow):
      pathShadowX = self.pathShadowX
      pathShadowY = self.pathShadowY
      pathShadowColor = self.pathShadowColor
      pathShadowAlpha = self.pathShadowAlpha
      baseEffect = [PathEffects.SimpleLineShadow(offset=(pathShadowX, pathShadowY), shadow_color=pathShadowColor,\
        alpha=pathShadowAlpha)] + baseEffect
      tempRememberSetting2 = 'PathEffects.SimpleLineShadow(offset=(' + repr(pathShadowX) + ',' + repr(pathShadowY) + '), shadow_color=' +\
        repr(pathShadowColor) + ', alpha=' + repr(pathShadowAlpha) +')'
      baseEffectText = [PathEffects.SimplePatchShadow(offset=(pathShadowX, pathShadowY), shadow_rgbFace=pathShadowColor,\
        alpha=pathShadowAlpha)] + baseEffect

      if(len(tempRememberSetting)):
        tempRememberSetting += ',\n\t' + tempRememberSetting2
      else:
        tempRememberSetting = tempRememberSetting2
    else:
      baseEffectText = baseEffect
    
    # deal with existing objects
    if(self.applyPathStroke):
      pathStrokeWidth = self.pathStrokeWidth
      pathStrokeColor = self.pathStrokeColor

      # modify existing extras
      for entry in self.parent.extras:
        for handleExtra in [entry.handle, entry.handle_div]:
          if(handleExtra != None):
            if(hasattr(handleExtra, 'get_lw')):
              curr_linewidth = 2 * pathStrokeWidth + handleExtra.get_lw()
            else:
              curr_linewidth = 2 * pathStrokeWidth + 1
            # check whether we have a label here
            if(hasattr(handleExtra, 'get_text')):
              handleExtra.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            else:
              handleExtra.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            # set bbox if present
            if(hasattr(handleExtra, 'get_bbox_patch')):
              handle = handleExtra.get_bbox_patch()
              if(handle != None):
                curr_linewidth = 2 * pathStrokeWidth + handle.get_lw()
                handle.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            # set arrow patch if present
            if(hasattr(handleExtra, 'arrow_patch')):
              handle = handleExtra.arrow_patch
              if(handle != None):
                curr_linewidth = 2 * pathStrokeWidth + handle.get_lw()
                handle.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # modify existing curves
      for entry in self.parent.fit:
        for handlePlot in [entry.handlePlot, entry.handlePlot_div]:
          if(handlePlot != None):
            curr_linewidth = 2 * pathStrokeWidth + handlePlot.get_lw()
            handlePlot.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
  
      # modify existing data sets
      for entry in self.parent.data:
        for handleData in [entry.handleData, entry.handleData_div]:
          if(handleData != None):
            curr_linewidth = 2 * pathStrokeWidth + handleData.get_lw()
            handleData.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        for handleResid in [entry.handleResid, entry.handleResid_div]:
          if(handleResid != None):
            curr_linewidth = 2 * pathStrokeWidth + handleResid.get_lw()
            handleResid.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        for handleBar in [entry.handleBar, entry.handleBar_div]:
          if(handleBar != None):
            children = handleBar.get_children()
            for entry2 in children:
              curr_linewidth = 2 * pathStrokeWidth + entry2.get_lw()
              entry2.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        # don't apply to stack style, throws strange error
        #if(entry.handleStack != None):
          #entry.handleStack.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        for handleResidBar in [entry.handleResidBar, entry.handleResidBar_div]:
          if(handleResidBar != None):
            children = handleResidBar.get_children()
            for entry2 in children:
              curr_linewidth = 2 * pathStrokeWidth + entry2.get_lw()
              entry2.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        # don't apply to stack style, throws strange error
        #if(entry.handleStack != None):
          #entry.handleStack.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        for handleErr in [entry.handleErr, entry.handleErr_div]:
          if(handleErr != None):
            curr_linewidth = 2 * pathStrokeWidth + handleErr[0].get_lw()
            handleErr[0].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            for entry2 in handleErr[1]:
              # remember caps are drawn as markers not lines
              if(entry2.get_markeredgewidth() > 0):
                curr_linewidth = 2 * pathStrokeWidth + entry2.get_markeredgewidth()
                entry2.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
              else:
                # don't draw effects for zero width markers
                #entry2.set_path_effects(baseEffect)
                # in this case don't do anything since setting path effects would cause drawing of caps (w/ currently set path effects)
                pass
            for entry2 in handleErr[2]:
              # have to use get_linewidth() here as get_lw() not implemented?!
              curr_linewidth = 2 * pathStrokeWidth + entry2.get_linewidth()
              entry2.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        # now handle violin and box plots
        for handleViolin in [entry.handleViolin, entry.handleViolin_div]:
          if(handleViolin != None):
            # bodies throws a crash when applying path effects
            validItems = ['cmins', 'cmaxes', 'cmeans', 'cmedians', 'cbars', 'boxes', 'medians', 'whiskers', 'caps', 'fliers']
            for subtarget in [i for i in handleViolin if i in validItems]:
              if(type(handleViolin[subtarget]) == type([])):
                itemList = handleViolin[subtarget]
              else:
                itemList = [handleViolin[subtarget]]
              # cycle through all items
              for item in itemList:
                if(hasattr(item, 'get_linewidth')):
                  curr_linewidth = 2 * pathStrokeWidth + item.get_linewidth()
                else:
                  curr_linewidth = 2 * pathStrokeWidth + 1.0
                if(hasattr(item, 'set_path_effects')):
                  item.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        # now handle the text labels
        for handleText in [entry.handleText, entry.handleText_div]:
          if(handleText != None):
            for item in handleText:
              if(hasattr(item, 'get_linewidth')):
                curr_linewidth = 2 * pathStrokeWidth + item.get_linewidth()
              else:
                curr_linewidth = 2 * pathStrokeWidth + 1.0
              if(hasattr(item, 'set_path_effects')):
                item.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
       
      # modify axes
      for entry in self.ax.spines:
        if(entry in ['left', 'right']):
          curr_linewidth = 2 * pathStrokeWidth + self.ax.spines[entry].get_lw()
          self.ax.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax2.spines:
        curr_linewidth = 2 * pathStrokeWidth + self.ax2.spines[entry].get_lw()
        self.ax2.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax_resid.spines:
        curr_linewidth = 2 * pathStrokeWidth + self.ax_resid.spines[entry].get_lw()
        self.ax_resid.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax_div.spines:
        if(entry in ['left', 'right']):
          curr_linewidth = 2 * pathStrokeWidth + self.ax_div.spines[entry].get_lw()
          self.ax_div.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax2_div.spines:
        curr_linewidth = 2 * pathStrokeWidth + self.ax2_div.spines[entry].get_lw()
        self.ax2_div.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in self.ax_resid_div.spines:
        curr_linewidth = 2 * pathStrokeWidth + self.ax_resid_div.spines[entry].get_lw()
        self.ax_resid_div.spines[entry].set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # modify grid lines
      for key in self.gridLinesStore:
        if(self.gridVisible[key]):
          for entry in self.gridLinesStore[key]:
            curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
            entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        if(key in self.gridLinesStore_resid):
          for entry in self.gridLinesStore_resid[key]:
            curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
            entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            
      # modify tick lines
      #for entry in self.ax.xaxis.get_ticklines():
      #  curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
      #  entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax.yaxis.get_ticklines() + self.ax.yaxis.get_ticklines(minor=True) + self.ax_div.yaxis.get_ticklines() + self.ax_div.yaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax_resid.xaxis.get_ticklines() + self.ax_resid.xaxis.get_ticklines(minor=True) + self.ax_resid_div.xaxis.get_ticklines() + self.ax_resid_div.xaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax_resid.yaxis.get_ticklines() + self.ax_resid.yaxis.get_ticklines(minor=True) + self.ax_resid_div.yaxis.get_ticklines() + self.ax_resid_div.yaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax2.xaxis.get_ticklines() + self.ax2.xaxis.get_ticklines(minor=True) + self.ax2_div.xaxis.get_ticklines() + self.ax2_div.xaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      for entry in (self.ax2.yaxis.get_ticklines() + self.ax2.yaxis.get_ticklines(minor=True) + self.ax2_div.yaxis.get_ticklines() + self.ax2_div.yaxis.get_ticklines(minor=True)):
        curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
        entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
  
      # zero line
      for handleResidZero in [self.handleResidZero, self.handleResidZero_div]:
        if(handleResidZero != None):
          curr_linewidth = 2 * pathStrokeWidth + handleResidZero.get_lw()
          handleResidZero.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # and the cursor
      for cursor in [self.cursor, self.cursor_div]:
        if(cursor != None):
          handles = cursor.getHandles()
          for entry in handles:
            if(hasattr(entry, 'get_lw')):
              curr_linewidth = 2 * pathStrokeWidth + entry.get_lw()
            else:
              curr_linewidth = 2 * pathStrokeWidth + 1
            # check for text
            if(hasattr(entry, 'get_text')):
              entry.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
            else:
              entry.set_path_effects(baseEffect + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # and the axes labels
      curr_linewidth = 2 * pathStrokeWidth + 1
      for entry in [self.ax2, self.ax_resid, self.ax2_div, self.ax_resid_div]:
        entry.xaxis.label.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
        entry.yaxis.label.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      self.ax.yaxis.label.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])
      self.ax_div.yaxis.label.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # and the tick labels
      curr_linewidth = 2 * pathStrokeWidth + 1
      tickLabels = []
      for entry in [self.ax, self.ax_resid, self.ax2, self.ax_div, self.ax_resid_div, self.ax2_div]:
        tickLabels.extend(entry.get_xticklabels(which='both'))
        tickLabels.extend(entry.get_yticklabels(which='both'))
        tickLabels.append(entry.xaxis.get_offset_text())
        tickLabels.append(entry.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_path_effects(baseEffectText + [PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor)])

      # update baseEffect for new plot items
      curr_linewidth = 2 * pathStrokeWidth + 1.0
      baseEffect.append(PathEffects.withStroke(linewidth=curr_linewidth, foreground=pathStrokeColor))
      tempRememberSetting2 = 'PathEffects.withStroke(linewidth=' + repr(curr_linewidth) + ', foreground=' + repr(pathStrokeColor) +')'
      if(len(tempRememberSetting)):
        tempRememberSetting += ',\n\t' + tempRememberSetting2
      else:
        tempRememberSetting = tempRememberSetting2
    else:
      # check for complete turnoff of pathEffects for text labels
      if((not self.applyPathStroke) and (not self.applyPathShadow)):
        baseEffectText = []

      # modify existing extras
      for entry in self.parent.extras:
        for handleExtra in [entry.handle, entry.handle_div]:
          if(handleExtra != None):
            # check whether we have a label here
            if(hasattr(handleExtra, 'get_text')):
              handleExtra.set_path_effects(baseEffectText)
            else:
              handleExtra.set_path_effects(baseEffect)
            # set bbox if present
            if(hasattr(handleExtra, 'get_bbox_patch')):
              handle = handleExtra.get_bbox_patch()
              if(handle != None):
                handle.set_path_effects(baseEffect)
            # set arrow patch if present
            if(hasattr(handleExtra, 'arrow_patch')):
              handle = handleExtra.arrow_patch
              if(handle != None):
                handle.set_path_effects(baseEffect)

      # modify existing curves
      for entry in self.parent.fit:
        for handlePlot in [entry.handlePlot, entry.handlePlot_div]:
          if(handlePlot != None):
            handlePlot.set_path_effects(baseEffect)
  
      # modify existing data sets
      for entry in self.parent.data:
        for handleData in [entry.handleData, entry.handleData_div]:
          if(handleData != None):
            handleData.set_path_effects(baseEffect)
        for handleResid in [entry.handleResid, entry.handleResid_div]:
          if(handleResid != None):
            handleResid.set_path_effects(baseEffect)
        for handleBar in [entry.handleBar, entry.handleBar_div]:
          if(handleBar != None):
            children = handleBar.get_children()
            for entry2 in children:
              entry2.set_path_effects(baseEffect)
        # don't apply to stack style, throws strange error
        for handleResidBar in [entry.handleResidBar, entry.handleResidBar_div]:
          if(handleResidBar != None):
            children = handleResidBar.get_children()
            for entry2 in children:
              entry2.set_path_effects(baseEffect)
        # don't apply to stack style, throws strange error
        for handleErr in [entry.handleErr, entry.handleErr_div]:
          if(handleErr != None):
            handleErr[0].set_path_effects(baseEffect)
            for entry2 in handleErr[1]:
              entry2.set_path_effects(baseEffect)
            for entry2 in handleErr[2]:
              entry2.set_path_effects(baseEffect)
        # now handle violin and box plots
        for handleViolin in [entry.handleViolin, entry.handleViolin_div]:
          if(handleViolin != None):
            # bodies throws a crash when applying path effects
            validItems = ['cmins', 'cmaxes', 'cmeans', 'cmedians', 'cbars', 'boxes', 'medians', 'whiskers', 'caps', 'fliers']
            for subtarget in [i for i in handleViolin if i in validItems]:
              if(type(handleViolin[subtarget]) == type([])):
                itemList = handleViolin[subtarget]
              else:
                itemList = [handleViolin[subtarget]]
              # cycle through all items
              for item in itemList:
                if(hasattr(item, 'set_path_effects')):
                  item.set_path_effects(baseEffect)
        # now handle the text labels
        for handleText in [entry.handleText, entry.handleText_div]:
          if(handleText != None):
            for item in handleText:
              if(hasattr(item, 'set_path_effects')):
                item.set_path_effects(baseEffectText)
       
      # modify axes
      for entry in self.ax.spines:
        if(entry in ['left', 'right']):
          self.ax.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax2.spines:
        self.ax2.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax_resid.spines:
        self.ax_resid.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax_div.spines:
        if(entry in ['left', 'right']):
          self.ax_div.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax2_div.spines:
        self.ax2_div.spines[entry].set_path_effects(baseEffect)
      for entry in self.ax_resid_div.spines:
        self.ax_resid_div.spines[entry].set_path_effects(baseEffect)

      # modify grid lines
      for key in self.gridLinesStore:
        if(self.gridVisible[key]):
          for entry in self.gridLinesStore[key]:
            entry.set_path_effects(baseEffect)
        if(key in self.gridLinesStore_resid):
          for entry in self.gridLinesStore_resid[key]:
            entry.set_path_effects(baseEffect)

      # modify tick lines
      for entry in (self.ax.yaxis.get_ticklines() + self.ax.yaxis.get_ticklines(minor=True) + self.ax_div.yaxis.get_ticklines() + self.ax_div.yaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)
      for entry in (self.ax_resid.xaxis.get_ticklines() + self.ax_resid.xaxis.get_ticklines(minor=True) + self.ax_resid_div.xaxis.get_ticklines() + self.ax_resid_div.xaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)
      for entry in (self.ax_resid.yaxis.get_ticklines() + self.ax_resid.yaxis.get_ticklines(minor=True) + self.ax_resid_div.yaxis.get_ticklines() + self.ax_resid_div.yaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)
      for entry in (self.ax2.xaxis.get_ticklines() + self.ax2.xaxis.get_ticklines(minor=True) + self.ax2_div.xaxis.get_ticklines() + self.ax2_div.xaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)
      for entry in (self.ax2.yaxis.get_ticklines() + self.ax2.yaxis.get_ticklines(minor=True) + self.ax2_div.yaxis.get_ticklines() + self.ax2_div.yaxis.get_ticklines(minor=True)):
        entry.set_path_effects(baseEffect)

      # zero line
      for handleResidZero in [self.handleResidZero, self.handleResidZero_div]:
        if(handleResidZero != None):
          handleResidZero.set_path_effects(baseEffect)
        
      # and the axes labels
      for entry in [self.ax2, self.ax_resid, self.ax2_div, self.ax_resid_div]:
        entry.xaxis.label.set_path_effects(baseEffectText)
        entry.yaxis.label.set_path_effects(baseEffectText)
      self.ax.yaxis.label.set_path_effects(baseEffectText)
      self.ax_div.yaxis.label.set_path_effects(baseEffectText)

      # and the tick labels
      tickLabels = []
      for entry in [self.ax, self.ax_resid, self.ax2, self.ax_div, self.ax_resid_div, self.ax2_div]:
        tickLabels.extend(entry.get_xticklabels(which='both'))
        tickLabels.extend(entry.get_yticklabels(which='both'))
        tickLabels.append(entry.xaxis.get_offset_text())
        tickLabels.append(entry.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_path_effects(baseEffectText)

      # and the cursor
      for cursor in [self.cursor, self.cursor_div]:
        if(cursor != None):
          handles = cursor.getHandles()
          for entry in handles:
            # check for text
            if(hasattr(entry, 'get_text')):
              entry.set_path_effects(baseEffectText)
            else:
              entry.set_path_effects(baseEffect)

    # introduces path effects for new plot items
    tempDict = {}
    tempDict['path.effects'] = baseEffect
    matplotlib.rcParams.update(tempDict)

    self.rememberSetting['pathEffects'] = 'tempDict = {\'path.effects\': [' + tempRememberSetting + ']}\n'
    self.rememberSetting['pathEffects'] += 'matplotlib.rcParams.update(tempDict)\n'

    # update plot
    if(redraw):
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()
    
  def setXkcdSetting(self, value=1.0, item='scale', redraw=True):
    # update xckd setttings
    if(item in ['scale', 'length', 'random']):
      if(item == 'scale'):
        if(self.xkcdScale == value):
          redraw = False
        else:
          self.xkcdScale = value
      elif(item == 'length'):
        if(self.xkcdLength == value):
          redraw = False
        else:
          self.xkcdLength = value
      elif(item == 'random'):
        if(self.xkcdRandomness == value):
          redraw = False
        else:
          self.xkcdRandomness = value
          
      # do the xkcdify?
      if((redraw) and (self.xkcd)):
        self.xkcdify(state=self.xkcd, redraw=redraw)

  def xkcdify(self, state=True, redraw=True):
    # set xkcd-like parameters
    # store previous parameters
    if((not self.xkcd) and (state)):
      if ('font.sans-serif' in matplotlib.rcParams):
        self.xkcdStoreFonts = matplotlib.rcParams['font.sans-serif']
      else:
        self.xkcdStoreFonts = ['DejaVu Sans']
    
    # set new parameters
    self.xkcd = state
    tempDict = {}
    if(self.xkcd):
      xkcdScale = self.xkcdScale
      xkcdLength = self.xkcdLength
      xkcdRandomness = self.xkcdRandomness

      # check for presence of funny fonts
      addFonts = []
      fontCandidates = 'Humor Sans,Comic Sans MS'.split(',')
      for entry in fontCandidates:
        if entry in self.parent.fontNames:
          addFonts.append(entry)
          
      if(len(addFonts)):
        tempDict['font.sans-serif'] = addFonts
        tempDict['font.sans-serif'].extend(self.xkcdStoreFonts)
    else:
      xkcdScale = 0
      xkcdLength = 0
      xkcdRandomness = 0
      
      # restore original fonts
      tempDict['font.sans-serif'] = self.xkcdStoreFonts

    # introduces xkcd-type style for new plot items
    tempDict['path.sketch'] = (xkcdScale, xkcdLength, xkcdRandomness)
    matplotlib.rcParams.update(tempDict)
    self.rememberSetting['xkcd'] = 'tempDict = ' + repr(tempDict) + '\n'
    self.rememberSetting['xkcd'] += 'matplotlib.rcParams.update(tempDict)\n'
    
    # modify existing extras
    for entry in self.parent.extras:
      for handleExtra in [entry.handle, entry.handle_div]:
        if(handleExtra != None):
          # modify object directly (for line)
          if(hasattr(handleExtra, 'set_sketch_params')):
            handleExtra.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
          # set bbox if present
          if(hasattr(handleExtra, 'get_bbox_patch')):
            handle = handleExtra.get_bbox_patch()
            if(handle != None):
              handle.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
          # set arrow patch if present
          if(hasattr(handleExtra, 'arrow_patch')):
            handle = handleExtra.arrow_patch
            if(handle != None):
              handle.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    
    # modify existing curves
    for entry in self.parent.fit:
      for handlePlot in [entry.handlePlot, entry.handlePlot_div]:
        if(handlePlot != None):
          handlePlot.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    
    # modify existing data sets
    for entry in self.parent.data:
      for handleData in [entry.handleData, entry.handleData_div]:
        if(handleData != None):
          handleData.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleResid in [entry.handleResid, entry.handleResid_div]:
        if(handleResid != None):
          handleResid.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleBar in [entry.handleBar, entry.handleBar_div]:
        if(handleBar != None):
          children = handleBar.get_children()
          for entry2 in children:
            entry2.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleStack in [entry.handleStack, entry.handleStack_div]:
        if(handleStack != None):
          handleStack.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleStackNeg in [entry.handleStackNeg, entry.handleStackNeg_div]:
        if(handleStackNeg != None):
          handleStackNeg.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleResidBar in [entry.handleResidBar, entry.handleResidBar_div]:
        if(handleResidBar != None):
          children = handleResidBar.get_children()
          for entry2 in children:
            entry2.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleResidStack in [entry.handleResidStack, entry.handleResidStack_div]:
        if(handleResidStack != None):
          handleResidStack.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleResidStackNeg in [entry.handleResidStackNeg, entry.handleResidStackNeg_div]:
        if(handleResidStackNeg != None):
          handleResidStackNeg.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleErr in [entry.handleErr, entry.handleErr_div]:
        if(handleErr != None):
          handleErr[0].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
          for entry2 in handleErr[1]:
            entry2.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
          for entry2 in handleErr[2]:
            entry2.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      for handleViolin in [entry.handleViolin, entry.handleViolin_div]:
        if(handleViolin != None):
          for subtarget in handleViolin:
            if(type(handleViolin[subtarget]) == type([])):
              itemList = handleViolin[subtarget]
            else:
              itemList = [handleViolin[subtarget]]
            # cycle through all items
            for item in itemList:
              if(hasattr(item, 'set_sketch_params')):
                item.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # modify axes and background
    for entry in self.ax.spines:
      if(entry in ['left', 'right']):
        self.ax.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax_resid.spines:
      self.ax_resid.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax2.spines:
      self.ax2.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax2.patch.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax_resid.patch.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax_div.spines:
      if(entry in ['left', 'right']):
        self.ax_div.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax_resid_div.spines:
      self.ax_resid_div.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in self.ax2_div.spines:
      self.ax2_div.spines[entry].set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax2_div.patch.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax_resid_div.patch.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # modify grid lines
    for key in self.gridLinesStore:
      if(self.gridVisible[key]):
        for entry in self.gridLinesStore[key]:
          entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      if(key in self.gridLinesStore_resid):
        for entry in self.gridLinesStore_resid[key]:
          entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # modify tick lines (somehow not heeded by matplotlib?!)
    for entry in (self.ax.yaxis.get_ticklines() + self.ax.yaxis.get_ticklines(minor=True) + self.ax_div.yaxis.get_ticklines() + self.ax_div.yaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in (self.ax_resid.xaxis.get_ticklines() + self.ax_resid.xaxis.get_ticklines(minor=True) + self.ax_resid_div.xaxis.get_ticklines() + self.ax_resid_div.xaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in (self.ax_resid.yaxis.get_ticklines() + self.ax_resid.yaxis.get_ticklines(minor=True) + self.ax_resid_div.yaxis.get_ticklines() + self.ax_resid_div.yaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in (self.ax2.xaxis.get_ticklines() + self.ax2.xaxis.get_ticklines(minor=True) + self.ax2_div.xaxis.get_ticklines() + self.ax2_div.xaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    for entry in (self.ax2.yaxis.get_ticklines() + self.ax2.yaxis.get_ticklines(minor=True) + self.ax2_div.yaxis.get_ticklines() + self.ax2_div.yaxis.get_ticklines(minor=True)):
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # zero line
    for handleResidZero in [self.handleResidZero, self.handleResidZero_div]:
      if(handleResidZero != None):
        handleResidZero.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      
    # and the cursor
    for cursor in [self.cursor, self.cursor_div]:
      if(cursor != None):
        handles = cursor.getHandles()
        for entry in handles:
          entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # and the axes labels
    for entry in [self.ax2, self.ax_resid, self.ax2_div, self.ax_resid_div]:
      entry.xaxis.label.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
      entry.yaxis.label.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax.yaxis.label.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)
    self.ax_div.yaxis.label.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # and the tick labels
    tickLabels = []
    for entry in [self.ax, self.ax2, self.ax_resid, self.ax_div, self.ax2_div, self.ax_resid_div]:
      tickLabels.extend(entry.get_xticklabels(which='both'))
      tickLabels.extend(entry.get_yticklabels(which='both'))
    for entry in tickLabels:
      entry.set_sketch_params(xkcdScale, xkcdLength, xkcdRandomness)

    # update plot
    if(redraw):
      self.dataplotwidget.myRefresh()
      self.residplotwidget.myRefresh()
    
  def initPlot(self, initialize=True):
    if(initialize):
      plt.ioff()
      # initialize data plot
      self.ax2 = self.matplot.add_subplot(111)
      self.ax2.autoscale(enable=False, axis='both')
      self.ax2.xaxis.set_label_text('x')
      self.ax2.yaxis.set_label_text('y')
      self.ax2.yaxis.set_label_position('right')
      self.ax2.yaxis.set_ticks_position('right')
      self.ax2.grid(False, which='both')
      self.ax2.patch.set_facecolor('none')

      # now for some fun with make_axes_locatable
      self.divider_ax2 = make_axes_locatable(self.ax2)
      self.ax2_div = self.divider_ax2.append_axes('right', size='100%', pad=0.2, sharey=self.ax2)
      self.ax2_div.set_xscale(self.modeX_div)
      self.ax2_div.set_xlim((self.minX_div, self.maxX_div))
      # hide the extra axis
      self.divider_ax2.set_horizontal((Size.AxesX(self.ax2), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax2))))
      self.ax2_div.grid(False, which='both')
      self.ax2_div.set_visible(False)

      # we cannot set entire axis invisible as this also removes canvas etc.
      ###self.ax2.set_visible(False)
      self.toggleSecondAxesItems(state=False)
      
      # ax object should be twinned to ax2 (not vice versa), such that it ends on top
      self.ax = self.ax2.twinx()
      self.ax.autoscale(enable=False, axis='both')
      self.ax.xaxis.set_visible(False)
      self.ax.yaxis.set_label_position('left')
      self.ax.yaxis.set_ticks_position('left')
      self.ax.grid(False, which='both')
      # for good measure, reset ticks position on ax2
      self.ax2.yaxis.set_ticks_position('right')
      for entry in ['top', 'bottom']:
        self.ax.spines[entry].set_visible(False)
      self.matplot.patch.set_facecolor(self.canvasColor)

      # now for some fun with make_axes_locatable
      self.divider_ax = make_axes_locatable(self.ax)
      self.ax_div = self.divider_ax.append_axes('right', size='100%', pad=0.2, sharey=self.ax)
      self.ax_div.set_xscale(self.modeX_div)
      self.ax_div.set_xlim((self.minX_div, self.maxX_div))
      # hide diverse elements
      for entry in ['top', 'bottom', 'left', 'right']:
        self.ax_div.spines[entry].set_visible(False)
      self.ax_div.patch.set_facecolor('none')
      self.ax_div.grid(False, which='both')
      self.ax_div.xaxis.set_ticks_position('none')
      self.ax_div.yaxis.set_ticks_position('none')
      tickLabels = self.ax_div.get_xticklabels(which='both')
      tickLabels.append(self.ax_div.xaxis.get_offset_text())
      tickLabels.extend(self.ax_div.get_yticklabels(which='both'))
      tickLabels.append(self.ax_div.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_visible(False)
      # hide the extra axis
      self.divider_ax.set_horizontal((Size.AxesX(self.ax), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax))))
      self.ax_div.set_visible(False)

      # adjust z-order to make original axes appear in front (important for mouse cursor)
      self.ax.set_zorder(self.ax_div.get_zorder() + 1)
      self.ax2.set_zorder(self.ax2_div.get_zorder() + 1)
      self.dataplotwidget.myRefresh()
      
      # generate additional plot object for colored background
      self.colorPlane = self.matplot.add_subplot(111, label='tilt')
      self.colorPlane.autoscale(enable=False, axis='both')
      # hide essentially all elements of this new plot
      self.colorPlane.xaxis.set_visible(False)
      self.colorPlane.yaxis.set_ticks_position('none')
      for entry in ['top', 'bottom', 'left', 'right']:
        self.colorPlane.spines[entry].set_visible(False)
      self.colorPlane.xaxis.set_label_text('')
      self.colorPlane.yaxis.set_label_text('')
      self.colorPlane.xaxis.label.set_visible(False)
      self.colorPlane.yaxis.label.set_visible(False)
      self.colorPlane.set_xlim(0, 1)
      self.colorPlane.set_ylim(0, 1)
      self.colorPlane.set_xticks([])
      self.colorPlane.set_yticks([])
      self.colorPlane.patch.set_facecolor([0.0] * 4)
      self.colorPlane.grid(False, which='both')
      # initialize handle for colored background
      if(self.canvasGradientVisible):
        self.setCanvasGradient(redraw=False)
      else:
        self.colorBackground = None
      self.colorPlane.set_zorder(self.ax_div.get_zorder() - 1)
        
      # initalize some values
      self.handleData = None
      self.handlePlot = None
      self.handleErr = None
      self.handleErrShady = None
    
      # initialize resid plot
      self.ax_resid = self.residplot.add_subplot(111)
      self.ax_resid.autoscale(enable=False, axis='both')
      self.ax_resid.grid(False, which='both')
      self.residplot.patch.set_facecolor(self.canvasColor)
      
      # now for some fun with make_axes_locatable
      self.divider_resid = make_axes_locatable(self.ax_resid)
      self.ax_resid_div = self.divider_resid.append_axes('right', size='100%', pad=0.2, sharey=self.ax_resid)
      self.ax_resid_div.set_xscale(self.modeX_div)
      self.ax_resid_div.set_xlim((self.minX_div, self.maxX_div))
      self.ax_resid_div.grid(False, which='both')
      tickLabels = self.ax_resid_div.get_yticklabels(which='both')
      tickLabels.append(self.ax_resid_div.yaxis.get_offset_text())
      for entry in tickLabels:
        entry.set_visible(False)
      # hide the extra axis
      self.divider_resid.set_horizontal((Size.AxesX(self.ax_resid), Size.Fixed(self.splitPad), Size.Fraction(self.splitFraction, Size.AxesX(self.ax_resid))))
      self.ax_resid_div.set_visible(False)

      # adjust z-order to make original axes appear in front
      self.ax_resid.set_zorder(self.ax_resid_div.get_zorder() + 1)
      self.residplotwidget.myRefresh()

      # generate additional plot object for colored background
      self.colorPlane_resid = self.residplot.add_subplot(111, label='tilt_resid')
      self.colorPlane_resid.autoscale(enable=False, axis='both')
      # hide essentially all elements of this new plot
      self.colorPlane_resid.xaxis.set_visible(False)
      self.colorPlane_resid.yaxis.set_ticks_position('none')
      for entry in ['top', 'bottom', 'left', 'right']:
        self.colorPlane_resid.spines[entry].set_visible(False)
      self.colorPlane_resid.xaxis.set_label_text('')
      self.colorPlane_resid.yaxis.set_label_text('')
      self.colorPlane_resid.xaxis.label.set_visible(False)
      self.colorPlane_resid.yaxis.label.set_visible(False)
      self.colorPlane_resid.set_xlim(0, 1)
      self.colorPlane_resid.set_ylim(0, 1)
      self.colorPlane_resid.set_xticks([])
      self.colorPlane_resid.set_yticks([])
      self.colorPlane_resid.patch.set_facecolor([0.0] * 4)
      self.colorPlane_resid.grid(False, which='both')
      # initialize handle for colored background
      if(self.canvasGradientVisible):
        self.setCanvasGradient(redraw=False, target='resid')
      else:
        self.colorBackground_resid = None
      self.colorPlane_resid.set_zorder(self.ax_resid_div.get_zorder() - 1)

      # initalize some values
      self.handleResid = None
      self.handleResidZero = None
      self.handleResidZero_div = None
      self.handlesAbout = []
      
      # initialize the plot rectangle selector
      rectprops = dict(fill=True, linewidth=1, facecolor=[0,0,1,0.4], edgecolor='black', linestyle='solid')
      if(('linux' in platform) or (platform == 'darwin')):
        self.rectSelector = RectSel(self.ax, self.rectSelectorCallback, drawtype='box', useblit=True, rectprops=rectprops,\
                                  button=[1,3], minspanx=0, minspany=0, spancoords='pixels')#, interactive=False)
      else:
        self.rectSelector = RectSel(self.ax, self.rectSelectorCallback, drawtype='box', useblit=True, rectprops=rectprops,\
                                  button=[1,3], minspanx=0, minspany=0, spancoords='pixels', interactive=False)

      # fudge to prevent rectangle selector from firing same event twice
      self.previousClick = [0.0] * 4
      
      # set up cursor
      self.matplot.canvas.mpl_connect('button_press_event', self.toggleCrossHairEncore)
      self.matplot.canvas.mpl_connect('scroll_event', self.mouseScrolled)
      self.matplot.canvas.mpl_connect('motion_notify_event', self.moveHandler)
      self.matplot.canvas.mpl_connect('button_release_event', self.releaseHandler)
      
      # set up click handler in residplot
      self.residplot.canvas.mpl_connect('button_press_event', self.pickHandlerResid)

    for target in ['plot', 'resid']:
      # labels etc.
      self.toggleAxisLabel(self.labelXShow, axis='x', redraw=False, target=target)
      self.setAxisLabel(self.labelX, axis='x', redraw=False, target=target)
      self.setAxisLabelColor(value = self.labelXColor, axis = 'x', redraw = False, target=target)
      self.setAxisLabelSize(value = self.labelXSize, axis = 'x', redraw = False, target=target)
      self.setAxisLabelBold(value = self.labelXWeight, axis = 'x', redraw = False, target=target)
      self.setAxisLabelItalic(value = self.labelXStyle, axis = 'x', redraw = False, target=target)
      self.setAxisLabelVariant(value = self.labelXVariant, axis = 'x', redraw = False, target=target)
      self.setAxisLabelAlignment(value = self.labelXAlignment, axis = 'x', redraw = False, target=target)
      self.setAxisLabelAlignmentVertical(value = self.labelXAlignmentVertical, axis = 'x', redraw = False, target=target)
      self.setAxisLabelPad(value = self.labelXPad, axis = 'x', redraw = False, target=target)
      self.setAxisLabelPos(value = self.labelXPos, axis = 'x', redraw = False, target=target)
      self.setAxisLabelAngle(value = self.labelXAngle, axis = 'x', redraw = False, target=target)
      self.setAxisFont(value = self.axisFont['x'], axis = 'x', redraw = False, target=target)
      self.toggleAxisLabel(self.labelYShow, axis='y', redraw=False, target=target)
      self.setAxisLabel(labeltext=self.labelY, axis='y', redraw=False, target=target)
      if(target == 'plot'):
        self.setAxisLabel(labeltext=self.labelY2, axis='y2', redraw=False, target=target)
        self.toggleAxisLabel(self.labelY2Show, axis='y2', redraw=False, target=target)
      self.setAxisLabelColor(value = self.labelYColor, axis = 'y', redraw = False, target=target)
      self.setAxisLabelSize(value = self.labelYSize, axis = 'y', redraw = False, target=target)
      self.setAxisLabelBold(value = self.labelYWeight, axis = 'y', redraw = False, target=target)
      self.setAxisLabelItalic(value = self.labelYStyle, axis = 'y', redraw = False, target=target)
      self.setAxisLabelVariant(value = self.labelYVariant, axis = 'y', redraw = False, target=target)
      self.setAxisLabelAlignment(value = self.labelYAlignment, axis = 'y', redraw = False, target=target)
      self.setAxisLabelAlignmentVertical(value = self.labelYAlignmentVertical, axis = 'y', redraw = False, target=target)
      self.setAxisLabelPad(value = self.labelYPad, axis = 'y', redraw = False, target=target)
      self.setAxisLabelPos(value = self.labelYPos, axis = 'y', redraw = False, target=target)
      self.setAxisLabelAngle(value = self.labelYAngle, axis = 'y', redraw = False, target=target)
      self.setAxisFont(value = self.axisFont['y'], axis = 'y', redraw = False, target=target)
      if(target == 'plot'):
        self.setAxisLabelColor(value = self.labelY2Color, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelSize(value = self.labelY2Size, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelBold(value = self.labelY2Weight, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelItalic(value = self.labelY2Style, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelVariant(value = self.labelY2Variant, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelAlignment(value = self.labelY2Alignment, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelAlignmentVertical(value = self.labelY2AlignmentVertical, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelPad(value = self.labelY2Pad, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelPos(value = self.labelY2Pos, axis = 'y2', redraw = False, target=target)
        self.setAxisLabelAngle(value = self.labelY2Angle, axis = 'y2', redraw = False, target=target)
        self.setAxisFont(value = self.axisFont['y2'], axis = 'y2', redraw = False, target=target)
      
      # set axes properties
      for key in self.axisVisible:
        self.setAxisVisibility(value = self.axisVisible[key], axis = key, redraw = False, target=target)
      for key in self.axisWidth:
        self.setAxisWidth(value = self.axisWidth[key], axis = key, redraw = False, target=target)
      for key in self.axisStyle:
        self.setAxisStyle(value = self.axisStyle[key], axis = key, redraw = False, target=target)
      for key in self.axisDashStyle:
        self.setAxisDashStyle(value = self.axisDashStyle[key], axis = key, redraw = False, target=target)
      for key in self.axisColor:
        self.setAxisColor(value = self.axisColor[key], axis = key, redraw = False, target=target)
      if(not initialize):
        if(target == 'plot'):
          useKeys = ['left', 'right', 'bottom', 'top', 'left2', 'right2']
        else:
          useKeys = ['left', 'right', 'bottom', 'top']
        for key in useKeys:
          self.setAxisPosition(value=self.axisPosition[key], axis=key, redraw=False, target=target)
          self.setAxisPositionValue(value=self.axisPositionValue[key], axis=key, redraw=False, target=target)
        
      # set axes arrows
      for axis in ['x', 'y']:
        self.setAxisArrowColor(value=self.arrowColor[axis], axis=axis, item='line', redraw=False)
        self.setAxisArrowColor(value=self.arrowFill[axis], axis=axis, item='fill', redraw=False)
        self.setAxisArrowHeadWidth(value=self.arrowHeadWidth[axis], axis=axis, redraw=False)
        self.setAxisArrowHeadLength(value=self.arrowHeadLength[axis], axis=axis, redraw=False)
        self.setAxisArrowOverhang(value=self.arrowOverhang[axis], axis=axis, redraw=False)
        self.setAxisArrow(state=self.arrowVisible[axis], axis=axis, redraw=False, target=target)
  
      # set color and size of ticks
      self.toggleTicksLabel(value=self.ticksXShow, axis='x', redraw=False, target=target)
      self.setTickLabelColor(value = self.ticksXColor, axis = 'x', redraw = False, target=target)
      self.setTickLabelSize(value = self.ticksXSize, axis = 'x', redraw = False, target=target)
      self.setTickLabelBold(value = self.ticksXWeight, axis = 'x', redraw = False, target=target)
      self.setTickLabelItalic(value = self.ticksXStyle, axis = 'x', redraw = False, target=target)
      self.setTickLabelAngle(value = self.ticksXAngle, axis = 'x', redraw = False, target=target)
      self.setTickLabelAlignment(value = self.ticksXAlignment, axis = 'x', redraw = False, target=target)
      self.setTickLabelAlignmentVertical(value = self.ticksXAlignmentVertical, axis = 'x', redraw = False, target=target)
      self.setTickLabelPad(value = self.ticksXPad, axis = 'x', redraw = False, target=target)
      self.setTickLabelPad2(value = self.ticksXPad2, axis = 'x', redraw = False, target=target)
      self.setTickFont(value = self.tickFont['x'], axis = 'x', redraw = False, target=target)
      ###self.setTickFormat(axis='x', value=self.ticksXFormat, redraw=False, target=target)
      ### do we need to call tick formatting at all? (will be updated on draw time)

      if(target == 'plot'):
        self.toggleTicksLabel(value=self.ticksYShow, axis='y', redraw=False, target=target)
      else:
        self.toggleTicksLabel(value=self.ticksYShow_resid, axis='y', redraw=False, target=target)
      self.setTickLabelColor(value = self.ticksYColor, axis = 'y', redraw = False, target=target)
      self.setTickLabelSize(value = self.ticksYSize, axis = 'y', redraw = False, target=target)
      self.setTickLabelBold(value = self.ticksYWeight, axis = 'y', redraw = False, target=target)
      self.setTickLabelItalic(value = self.ticksYStyle, axis = 'y', redraw = False, target=target)
      self.setTickLabelAngle(value = self.ticksYAngle, axis = 'y', redraw = False, target=target)
      self.setTickLabelAlignment(value = self.ticksYAlignment, axis = 'y', redraw = False, target=target)
      self.setTickLabelAlignmentVertical(value = self.ticksYAlignmentVertical, axis = 'y', redraw = False, target=target)
      self.setTickLabelPad(value = self.ticksYPad, axis = 'y', redraw = False, target=target)
      self.setTickLabelPad2(value = self.ticksYPad2, axis = 'y', redraw = False, target=target)
      self.setTickFont(value = self.tickFont['y'], axis = 'y', redraw = False, target=target)
      if(target == 'plot'):
        self.toggleTicksLabel(value=self.ticksY2Show, axis='y2', redraw=False, target=target)
        self.setTickLabelColor(value = self.ticksY2Color, axis = 'y2', redraw = False, target=target)
        self.setTickLabelSize(value = self.ticksY2Size, axis = 'y2', redraw = False, target=target)
        self.setTickLabelBold(value = self.ticksY2Weight, axis = 'y2', redraw = False, target=target)
        self.setTickLabelItalic(value = self.ticksY2Style, axis = 'y2', redraw = False, target=target)
        self.setTickLabelAngle(value = self.ticksY2Angle, axis = 'y2', redraw = False, target=target)
        self.setTickLabelAlignment(value = self.ticksY2Alignment, axis = 'y2', redraw = False, target=target)
        self.setTickLabelAlignmentVertical(value = self.ticksY2AlignmentVertical, axis = 'y2', redraw = False, target=target)
        self.setTickLabelPad(value = self.ticksY2Pad, axis = 'y2', redraw = False, target=target)
        self.setTickLabelPad2(value = self.ticksY2Pad2, axis = 'y2', redraw = False, target=target)
        self.setTickFont(value = self.tickFont['y2'], axis = 'y2', redraw = False, target=target)
  
      # set tick properties
      if(target == 'plot'):
        validItems = ['left', 'right', 'top', 'bottom', 'left2', 'right2']
      else:
        validItems = ['left', 'right', 'top', 'bottom']
      for key in self.ticksVisible:
        if(key in validItems):
         self.setTickMarkVisibility(value = self.ticksVisible[key], axis = key, redraw = False, target=target)
      for key in self.ticksWidth:
        if(key in validItems):
          self.setTickMarkWidth(value = self.ticksWidth[key], axis = key, redraw = False, target=target)
      for key in self.ticksLength:
        if(key in validItems):
          self.setTickMarkLength(value = self.ticksLength[key], axis = key, redraw = False, target=target)
      for key in self.ticksColor:
        if(key in validItems):
          self.setTickMarkColor(value = self.ticksColor[key], axis = key, redraw = False, target=target)
      for key in self.ticksDirection:
        if(key in validItems):
          self.setTickMarkDirection(value = self.ticksDirection[key], axis = key, redraw = False, target=target)

      # set grid properties
      for key in self.gridVisible:
         self.setGridVisibility(value = self.gridVisible[key], axis = key, redraw = False, target=target)
      for key in self.gridWidth:
        self.setGridWidth(value = self.gridWidth[key], axis = key, redraw = False, target=target)
      for key in self.gridStyle:
        self.setGridStyle(value = self.gridStyle[key], axis = key, redraw = False, target=target)
      for key in self.gridDashStyle:
        self.setGridDashStyle(value = self.gridDashStyle[key], axis = key, redraw = False, target=target)
      for key in self.gridColor:
        self.setGridColor(value = self.gridColor[key], axis = key, redraw = False, target=target)
      for key in self.gridOrder:
        self.setGridOrder(value = self.gridOrder[key], axis = key, redraw = False, target=target)

      # canvas color etc.
      self.setCanvasColor(value=self.canvasColor, redraw=False, target=target)
      self.toggleCanvasFill(value=self.canvasFill, redraw=False, target=target)
      self.toggleFigureFill(value=self.figureFill, redraw=False, target=target, silent=True)
      self.toggleFrameDraw(value=self.frameDraw, redraw=False, target=target)
      self.setFigureColor(value=self.figureColor, redraw=False, target=target, silent=True)
      self.setCanvasGradientStyle(value=self.canvasGradientStyle, redraw=False, target=target)
      self.setCanvasGradientColor(value=self.canvasGradientColor1, redraw=False, target=target, color=0)
      self.setCanvasGradientColor(value=self.canvasGradientColor2, redraw=False, target=target, color=1)
      self.setCanvasGradientCenter(value=self.canvasGradientCenter[0], redraw=False, target=target, axis='x')
      self.setCanvasGradientCenter(value=self.canvasGradientCenter[1], redraw=False, target=target, axis='y')
      self.setCanvasGradientWidth(value=self.canvasGradientWidth, redraw=False, target=target)
      self.setCanvasGradientAngle(value=self.canvasGradientAngle, redraw=False, target=target)
      self.setCanvasGradient(state=self.canvasGradientVisible, redraw=False, target=target)
      
      # set padding
      self.setPadding(value=self.padSize['bottom'], axis='bottom', redraw=False, target=target)
      
      # frame
      self.setFrameColor(value=self.frameColor, redraw=False, target=target)
      self.setFrameWidth(value=self.frameWidth, redraw=False, target=target)
      self.setFrameStyle(value=self.frameStyle, redraw=False, target=target)
      self.setFrameDashStyle(value=self.frameDashStyle, redraw=False, target=target)

    # the inner situation
    self.changeSplitFraction(value=self.splitFraction, redraw=False)
    self.changeSplitPad(value=self.splitPad, redraw=False)
    self.setInnerParameter(param='axes', state=self.innerAxes, redraw=False)
    self.setInnerParameter(param='ticks', state=self.innerTicks, redraw=False)
    for target in ['plot', 'resid']:
      self.toggleTicksLabel(value=self.ticksXShow_div, axis='x2', redraw=False, target=target)

    # xkcd etc.
    self.xkcdify(state=self.xkcd, redraw=False)
    self.setPathEffects(redraw=False)
    
    # deal with axis ticks
    if(self.ticksXAuto):
      self.setAutoTicks(axis='x', redraw=False, target='plot')
      self.setAutoTicks(axis='x', redraw=False, target='resid')
    else:
      ticksXLabel = self.ticksXLabel
      self.setAxisTicks(value=self.ticksX, axis='x', redraw=False, target='plot')
      self.setAxisTicks(value=self.ticksX, axis='x', redraw=False, target='resid')
      # apply axis labels?
      self.ticksXLabel = ticksXLabel
      if(len(self.ticksXLabel)):
        for axisobject in [self.ax, self.ax_resid]:
          axisobject.xaxis.set_ticklabels(self.ticksXLabel)
    if(self.ticksXAuto_div):
      self.setAutoTicks(axis='x2', redraw=False, target='plot')
      self.setAutoTicks(axis='x2', redraw=False, target='resid')
    else:
      ticksXLabel = self.ticksXLabel_div
      self.setAxisTicks(value=self.ticksX_div, axis='x2', redraw=False, target='plot')
      self.setAxisTicks(value=self.ticksX_div, axis='x2', redraw=False, target='resid')
      # apply axis labels?
      self.ticksXLabel_div = ticksXLabel
      if(len(self.ticksXLabel_div)):
        for axisobject in [self.ax2_div, self.ax_resid_div]:
          axisobject.xaxis.set_ticklabels(self.ticksXLabel_div)
      
    if(self.ticksYAuto):
      self.setAutoTicks(axis='y', redraw=False, target='plot')
    else:
      self.setAxisTicks(value=self.ticksY, axis='y', redraw=False, target='plot')
      
    if(self.ticksResidYAuto):
      self.setAutoTicks(axis='resid', redraw=False, target='resid')
    else:
      self.setAxisTicks(value=self.ticksResidY, axis='resid', redraw=False, target='resid')

    # retrieve axis ticks
    self.ticksX = self.getAxisTicks(axis = 'x')
    self.ticksY = self.getAxisTicks(axis = 'y')
    self.ticksY2 = self.getAxisTicks(axis = 'y2')
    self.ticksResidY = self.getAxisTicks(axis = 'resid')

    # issue plot redraw
    # the follwing call not needed as we will draw a curve afterwards
    self.handleResidZero = self.plotResidZero(self.handleResidZero, redraw=False)
    self.handleResidZero_div = self.plotResidZero(self.handleResidZero_div, redraw=False, splitX=True)
    self.setAxisLimits(lower=self.minResidY, upper=self.maxResidY, axis='y', updateLabel=False, target='resid', redraw=initialize, updateGrid=True)

  def pickHandlerResid(self, event):
    # handles click events in resid plot
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    if((event.button == 1) and (modifiers & QtCore.Qt.ControlModifier or event.dblclick)):
      # compile list of z-ordered items
      zOrderedItems = {}
      for index, entry in enumerate(self.parent.data):
        if((hasattr(entry, 'visibilityResid')) and entry.visibilityResid):
          zOrderedItems[entry.zorderResid] = ['resid', index]
      if(self.visibilityResidLine):
        zOrderedItems[self.zorderResidLine] = ['residLine', 0]
      # now check for click in descending z order
      zKeys = sorted(list(zOrderedItems.keys()))
      currIndex = len(zKeys) - 1
      while(currIndex >= 0):
        currKey = zKeys[currIndex]
        currItem = zOrderedItems[currKey]
        if(currItem[0] == 'resid'):
          relevantHandles = ['handleResid', 'handleResidStack', 'handleResidStackNeg', 'handleResid_div', 'handleResidStack_div', 'handleResidStackNeg_div']
          for handle in relevantHandles:
            if((self.parent.data[currItem[1]].__dict__[handle] != None) and (self.parent.data[currItem[1]].__dict__[handle].contains(event)[0])):
              # found an item that has been clicked on
              currIndex = -1
          # handle bars extra
          for handle in ['handleResidBar', 'handleResidBar_div']:
            if(self.parent.data[currItem[1]].__dict__[handle] != None):
              for patch in self.parent.data[currItem[1]].__dict__[handle].patches:
                if(patch.contains(event)[0]):
                  # found an item that has been clicked on
                  currIndex = -1
          # did we hit the item?
          if(currIndex == -1):
            self.parent.objectsarea.changeStyle(self.parent.data[currItem[1]], False, True, callButton=None)
        elif(currItem[0] == 'residLine'):
          for handle in ['handleResidZero', 'handleResidZero_div']:
            if((self.__dict__[handle] != None) and (self.__dict__[handle].contains(event)[0])):
              # found an item that has been clicked on
              currIndex = -1
              
          if(currIndex == -1):
            self.parent.objectsarea.changeResidZeroStyle(callButton=None)
          
        # advance item
        currIndex -= 1

  def releaseHandler(self, event):
    # called to turn off extra picking
    if(self.pickedExtra != None):
      if(event.inaxes == self.inAxes):
        # map to correct axis
        xdata, ydata = self.pickedAxes.transData.inverted().transform((event.x, event.y))
        xdata, ydata = xdata - self.startX, ydata - self.startY
      else:
        xdata, ydata = 0.0, 0.0
      self.parent.extras[self.pickedExtra].updateMe(xdata, ydata, pickedAxes=self.pickedAxes,\
                        pickedBackground=self.pickedBackground, pickedMode=self.pickedMode, transient=False)
      self.parent.extras[self.pickedExtra].drawMe(redraw=True)
    self.pickedExtra, self.pickedAxes, self.pickedBackground, self.pickedMode, self.inAxes = None, None, None, 0, None

  def moveHandler(self, event):
    # called to allow moving and resizing of extras
    if(self.pickedExtra != None):
      if(event.inaxes == self.inAxes):
        # map to correct axis
        xdata, ydata = self.pickedAxes.transData.inverted().transform((event.x, event.y))
        xdata, ydata = xdata - self.startX, ydata - self.startY
        self.parent.extras[self.pickedExtra].updateMe(xdata, ydata, pickedAxes=self.pickedAxes,\
                          pickedBackground=self.pickedBackground, pickedMode=self.pickedMode, transient=True)

  def toggleCrossHairEncore(self, event):
    # combined handler for all click events
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    fallThrough, hideRectSel = False, False
    if(((modifiers & QtCore.Qt.ControlModifier) or (modifiers & QtCore.Qt.ShiftModifier)) and (event.button == 1)):
      hideRectSel = True
      # determine mode
      if(modifiers & QtCore.Qt.ControlModifier):
        self.pickedMode = 1
      else:
        self.pickedMode = 0
      # compile list of z-ordered extras
      zOrderedExtras = {}
      for index, entry in enumerate(self.parent.extras):
        if((hasattr(entry, 'visibility')) and entry.visibility):
          zOrderedExtras[entry.zorder] = index
      # now check for click in descending z order
      zKeys = sorted(list(zOrderedExtras.keys()))
      currIndex = len(zKeys) - 1
      while(currIndex >= 0):
        currKey = zKeys[currIndex]
        currItem = zOrderedExtras[currKey]          

        for handle in ['handle', 'handle_div']:
          if((self.parent.extras[currItem].__dict__[handle] != None) and (self.parent.extras[currItem].__dict__[handle].contains(event)[0]) and (currIndex != -1)):
            # found an item that has been clicked on - break out of loop
            currIndex = -1
            self.pickedExtra = currItem
            
            # determine which axes to draw on
            if(self.parent.extras[currItem].onSecondAxes):
              if(handle == 'handle'):
                self.pickedAxes = self.parent.plotArea.ax2
              else:
                self.pickedAxes = self.parent.plotArea.ax2_div
            else:
              if(handle == 'handle'):
                self.pickedAxes = self.parent.plotArea.ax
              else:
                self.pickedAxes = self.parent.plotArea.ax_div
            # and additionally define inAxes
            if(handle == 'handle'):
              self.inAxes = self.parent.plotArea.ax
            else:
              self.inAxes = self.parent.plotArea.ax_div
              
            # save canvas for blitting
            self.pickedBackground = self.pickedAxes.figure.canvas.copy_from_bbox(self.pickedAxes.bbox)

            # map to correct axis
            self.startX, self.startY = self.pickedAxes.transData.inverted().transform((event.x, event.y))

        # advance item
        currIndex -= 1
    elif((event.button == 1) and event.dblclick):
      hideRectSel = True
      if(event.dblclick):
        fallThrough = True
      # compile list of z-ordered items
      zOrderedItems = {}
      for index, entry in enumerate(self.parent.fit):
        if((hasattr(entry, 'visibility')) and entry.visibility):
          zOrderedItems[entry.zorder] = ['fit', index]
      for index, entry in enumerate(self.parent.data):
        if((hasattr(entry, 'visibility')) and entry.visibility):
          zOrderedItems[entry.zorder] = ['data', index]
      for index, entry in enumerate(self.parent.extras):
        if((hasattr(entry, 'visibility')) and entry.visibility):
          zOrderedItems[entry.zorder] = ['extra', index]
      # now check for click in descending z order
      zKeys = sorted(list(zOrderedItems.keys()))
      currIndex = len(zKeys) - 1
      while(currIndex >= 0):
        currKey = zKeys[currIndex]
        currItem = zOrderedItems[currKey]
        if(currItem[0] == 'fit'):
          for handle in ['handlePlot', 'handlePlot_div']:
            if((self.parent.fit[currItem[1]].__dict__[handle] != None) and (self.parent.fit[currItem[1]].__dict__[handle].contains(event)[0])):
              # found an item that has been clicked on - break out of loop
              currIndex = -1
          if(currIndex == -1):
            self.parent.objectsarea.changeStyle(self.parent.fit[currItem[1]], False, False, callButton=None)
        elif(currItem[0] == 'data'):
          relevantHandles = ['handleData', 'handleStack', 'handleStackNeg', 'handleData_div', 'handleStack_div', 'handleStackNeg_div']
          for handle in relevantHandles:
            if((self.parent.data[currItem[1]].__dict__[handle] != None) and (self.parent.data[currItem[1]].__dict__[handle].contains(event)[0])):
              # found an item that has been clicked on
              currIndex = -1
          # handle bars extra
          for handle in ['handleBar', 'handleBar_div']:
            if(self.parent.data[currItem[1]].__dict__[handle] != None):
              for patch in self.parent.data[currItem[1]].__dict__[handle].patches:
                if(patch.contains(event)[0]):
                  # found an item that has been clicked on
                  currIndex = -1
          # handle violins extra
          for handle in ['handleViolin', 'handleViolin_div']:
            if(self.parent.data[currItem[1]].__dict__[handle] != None):
              for entry in self.parent.data[currItem[1]].__dict__[handle]:
                if(type(self.parent.data[currItem[1]].__dict__[handle][entry]) == type([])):
                  for item in self.parent.data[currItem[1]].__dict__[handle][entry]:
                    if(item.contains(event)[0]):
                      # found an item that has been clicked on
                      currIndex = -1
                else:
                  if(self.parent.data[currItem[1]].__dict__[handle][entry].contains(event)[0]):
                    # found an item that has been clicked on
                    currIndex = -1
                    
          # did we hit the item?
          if(currIndex == -1):
            self.parent.objectsarea.changeStyle(self.parent.data[currItem[1]], True, False, callButton=None)
        elif(currItem[0] == 'extra'):
          for handle in ['handle', 'handle_div']:
            if((self.parent.extras[currItem[1]].__dict__[handle] != None) and (self.parent.extras[currItem[1]].__dict__[handle].contains(event)[0])):
              # found an item that has been clicked on - break out of loop
              currIndex = -1
          if(currIndex == -1):
            self.parent.objectsarea.changeStyleExtra(currItem[1], callButton=None)

        if(currIndex == -1):
          # we hit an item, so don't fall through
          fallThrough = False

        # advance item
        currIndex -= 1
      
    if((event.button == 2) or fallThrough):
      hideRectSel = True
      # toggle cross hair on middle mouse button -- cannot use QtCore.Qt.MidButton as this equates to 4?!
      self.cursorVisible = not self.cursorVisible
      # check whether cursor already exists
      if(self.cursor == None):
        self.cursor = MyCursor(self.ax, useblit=True, color='black', linewidth=1)
        self.cursor.setParent(self)
        self.cursor.setAx2(self.ax2)
      if(self.cursor_div == None):
        if(self.splitShow):
          self.cursor_div = MyCursor(self.ax_div, useblit=True, color='black', linewidth=1)
          self.cursor_div.setParent(self)
          self.cursor_div.setAx2(self.ax2_div)
          
      # link cursors
      # as of matplotlib 3.1.2. we have to make sure that split axes are displayed before we can initialize the div cursor
      if(self.cursor_div != None):
        self.cursor.setTwin(self.cursor_div)
        self.cursor_div.setTwin(self.cursor)
        # toggle visibility (in correct order to get display of twins right)
        if(event.inaxes == self.ax_div):
          self.cursor.toggleVisibility(self.cursorVisible, event)
          self.cursor_div.toggleVisibility(self.cursorVisible, event)
        else:
          self.cursor_div.toggleVisibility(self.cursorVisible, event)
          self.cursor.toggleVisibility(self.cursorVisible, event)
      else:
        self.cursor.toggleVisibility(self.cursorVisible, event)
    
    # do this to remove superfluous rectSel box    
    if(hideRectSel):
      self.rectSelector.ignore(event)
      self.rectSelector.eventpress = None
      self.rectSelector.eventrelease = None
      self.rectSelector.to_draw.set_visible(False)
    else:
      self.rectSelector.to_draw.set_visible(True)

  def mouseScrolled(self, event):
    # adjusts zoom level when Ctrl is pressed also
    modifiers = QtWidgets.QApplication.queryKeyboardModifiers()
    if((modifiers & QtCore.Qt.ControlModifier) and (event.button in ['down', 'up'])):
      if(event.button == 'down'):
        self.incZoomLevel(1)
      else:
        self.incZoomLevel(-1)

  def destructAboutLogo(self):
    # destroys about logo
    counter = self.dataplotwidget.getDestructionCounter()
    if(counter >= 0):
      counter -= 1
      self.dataplotwidget.setDestructionCounter(np.max((counter, 0)))
      if((counter <= 0) and (len(self.handlesAbout))):
        for entry in self.handlesAbout:
          if(hasattr(entry, 'remove')):
            entry.remove()
        self.handlesAbout = []

  def drawAboutLogo(self, aspect=0, destructCounter=1):
    # draws program info on canvas
    # helper function that transforms coordinates according to axis settings
    def processCoordSet(coords, minX, maxX, modeX, minY, maxY, modeY, relWidth, relHeight, relOffsetX, relOffsetY):
      coords /= 100.0
      # process X coords
      if(modeX == 'linear'):
        coords[:,0] *= (maxX - minX) * relWidth
        coords[:,0] += minX + (maxX - minX) * relOffsetX
      else:
        minX, maxX = np.log(minX), np.log(maxX)
        coords[:,0] *= (maxX - minX) * relWidth
        coords[:,0] += minX + (maxX - minX) * relOffsetX
        coords[:,0] = np.exp(coords[:,0])
      # process Y coords
      if(modeY == 'linear'):
        coords[:,1] *= (maxY - minY) * relHeight
        coords[:,1] += minY + (maxY - minY) * relOffsetY
      else:
        minY, maxY = np.log(minY), np.log(maxY)
        coords[:,1] *= (maxY - minY) * relHeight
        coords[:,1] += minY + (maxY - minY) * relOffsetY
        coords[:,1] = np.exp(coords[:,1])
      return coords

    # helper function that transforms coordinates according to axis settings
    def processCoordSingle(minX, maxX, modeX, minY, maxY, modeY, relOffsetX, relOffsetY):
      # process X coords
      if(modeX == 'linear'):
        x = minX + (maxX - minX) * relOffsetX
      else:
        minX, maxX = np.log(minX), np.log(maxX)
        x = minX + (maxX - minX) * relOffsetX
        x = np.exp(x)
      # process Y coords
      if(modeY == 'linear'):
        y = minY + (maxY - minY) * relOffsetY
      else:
        minY, maxY = np.log(minY), np.log(maxY)
        y = minY + (maxY - minY) * relOffsetY
        y = np.exp(y)
      return [x, y]
    
    # check whether a previous logo is still displayed?
    if(not len(self.handlesAbout)):
      # settings
      zOffset = 1e3
      ubtCol = [0.011, 0.541, 0.384, 1.0]
      greyCol = [0.3, 0.3, 0.3, 1.0]
      blackCol = [0.0, 0.0, 0.0, 1.0]
      
      # retrieve axis info
      minX, maxX = self.minX, self.maxX
      minY, maxY = self.minY, self.maxY
      modeX, modeY = self.modeX, self.modeY

      # no aspect ratio specified, calculate own (don't do on first call since widgets have not resized properly yet)      
      currWidth, currHeight = self.matplot.get_size_inches()
      if(not aspect):
        aspect = currWidth / currHeight
      scaleFont = 100.0 / self.matplot.get_dpi()
        
      # define coordinate sets for graphics ...
      coords0 = np.array([[0.0, 0.0], [0.0, 100.0], [100.0, 100.0], [100.0, 0.0]])
      coords1 = np.array([[4.72, 4.11], [4.72, 95.13], [35.00, 95.13], [35.00, 34.76]])
      coords2 = np.array([[4.72, 4.11], [72.58, 72.14], [95.03, 72.14], [95.03, 49.53], [49.61, 4.11]])
      coords3 = np.array([[0.0, 0.0], [0.0, 100.0], [100.0, 100.0], [100.0, 0.0]])
      # ... and process them
      scaleWidth = 1
      scaleHeight = 1 / aspect
      scaleMin = np.min((scaleWidth, scaleHeight))
      scaleHeight = np.min((2.5, scaleHeight))
      scaleHeight = np.max((1.0, scaleHeight))
      widthBox = 0.8 * scaleWidth
      heightBox = 0.5 * scaleHeight
      coords0 = processCoordSet(coords0, minX, maxX, modeX, minY, maxY, modeY, widthBox, heightBox, 0.1, (1 - heightBox) / 2.0)
      coords1 = processCoordSet(coords1, minX, maxX, modeX, minY, maxY, modeY, 0.1 * scaleMin, 0.1 * scaleMin * aspect, 0.12, 0.62)
      coords2 = processCoordSet(coords2, minX, maxX, modeX, minY, maxY, modeY, 0.1 * scaleMin, 0.1 * scaleMin * aspect, 0.12, 0.62)
      coords3 = processCoordSet(coords3, minX, maxX, modeX, minY, maxY, modeY, 0.1 * scaleMin, 0.1 * scaleMin * aspect, 0.12, 0.62)
  
      # calculate coords for text labels
      text0 = processCoordSingle(minX, maxX, modeX, minY, maxY, modeY, 0.5, 0.64)
      text1 = processCoordSingle(minX, maxX, modeX, minY, maxY, modeY, 0.5, 0.45)
      text2 = processCoordSingle(minX, maxX, modeX, minY, maxY, modeY, 0.5, 0.35)
  
      # draw the background
      polyPatch0 = matplotlib.patches.Polygon(coords0, closed=True, facecolor=[1.0, 1.0, 1.0, 0.7],\
        edgecolor = greyCol, linestyle='solid', linewidth=0.7, zorder=zOffset)
      retv = self.ax.add_patch(polyPatch0)
      self.handlesAbout.append(retv)
      zOffset += 1
      
      # draw UBT logo
      polyPatch1 = matplotlib.patches.Polygon(coords1, closed=True, facecolor=[1.0]*4,\
        edgecolor = blackCol, linestyle='solid', linewidth=0.5, zorder=zOffset)
      retv = self.ax.add_patch(polyPatch1)
      self.handlesAbout.append(retv)
      zOffset += 1
  
      polyPatch2 = matplotlib.patches.Polygon(coords2, closed=True, facecolor=ubtCol,\
        edgecolor = 'None', linestyle='solid', linewidth=0.0, zorder=zOffset)
      retv = self.ax.add_patch(polyPatch2)
      self.handlesAbout.append(retv)
      zOffset += 1
  
      polyPatch3 = matplotlib.patches.Polygon(coords3, closed=True, facecolor='None',\
        edgecolor = blackCol, linestyle='solid', linewidth=0.5, zorder=zOffset)
      retv = self.ax.add_patch(polyPatch3)
      self.handlesAbout.append(retv)
      zOffset += 1
  
      # print some information
      # according to docu, positional argument would be 'text' but Matplotlib wants 's' => better don't use positional arguments
      #retv = self.ax.text(x=self.minX + 0.5 * width, y=self.minY + 0.5 * height, s='Fit-o-mat',\
      #  horizontalalignment='center', zorder=zOffset)
      retv = self.ax.text(text0[0], text0[1], 'Fit-o-mat',\
        horizontalalignment='center', zorder=zOffset, style='normal', fontsize=scaleFont * scaledDPI(12), fontweight='bold', color=ubtCol)
      self.handlesAbout.append(retv)
      zOffset += 1
      
      retv = self.ax.text(text1[0], text1[1],\
        '\u00A9' + ' by A.M. 2017-2020\nandreas.moeglich@uni-bayreuth.de\nGNU General Public License v3.0',\
        horizontalalignment='center', zorder=zOffset, style='normal', fontsize=scaleFont * scaledDPI(10), fontweight='normal', color=greyCol)
      self.handlesAbout.append(retv)
      zOffset += 1
      
      retv = self.ax.text(text2[0], text2[1], 'version '+ VERSION, horizontalalignment='center', zorder=zOffset,\
        style='italic', fontsize=scaleFont * scaledDPI(8), fontweight='normal', color=greyCol)
      self.handlesAbout.append(retv)
      zOffset += 1
    else:
      self.dataplotwidget.setDestructionCounter(1)
      self.destructAboutLogo()
      destructCounter = 0
      
    # refresh the plot to draw everything
    self.dataplotwidget.myRefresh()
    
    # set us up for ready destruction
    self.dataplotwidget.setDestructionCounter(destructCounter)

  def initLegend(self):
    # initializes legend (has to occur after function is drawn)
    self.setLegend(value=self.legendVisible, redraw=False, target='plot')
    self.setLegendPlacement(value=self.legendPlacement, redraw=False, target='plot')
    for prop in ['face', 'edge']:
      self.setLegendColor(value=self.legendColor[prop], prop=prop, redraw=False, target='plot')
    self.setLegendEdgeWidth(value=self.legendEdgeWidth, redraw=False, target='plot')
    self.setLegendShadow(value=self.legendShadow, redraw=False, target='plot')
    self.setLegendLabelColor(value=self.legendLabelColor, redraw=False, target='plot')
    self.setLegendLabelSize(value=self.legendLabelSize, redraw=False, target='plot')
    self.setLegendLabelBold(value=self.legendLabelWeight, redraw=False, target='plot')
    self.setLegendLabelItalic(value=self.legendLabelStyle, redraw=False, target='plot')
    self.setLegendLabelFont(value=self.legendLabelFont, redraw=False, target='plot')
    self.setLegendMarkerFirst(value=self.legendMarkerFirst, redraw=False, target='plot')
    self.setLegendMarkerScale(value=self.legendMarkerScale, redraw=False, target='plot')
    self.setLegendNCol(value=self.legendNumCol, redraw=False, target='plot')
    self.toggleLegendFill(value=self.legendFill, redraw=False, target='plot')
    self.setLegendMarkerNumPoints(value=self.legendNumPoints, redraw=False, target='plot')
    self.setLegendPadBorder(value=self.legendBorderPad, redraw=False, target='plot')
    self.setLegendPadRow(value=self.legendLabelSpacing, redraw=False, target='plot')
    self.setLegendPadCol(value=self.legendColumnSpacing, redraw=False, target='plot')
   
  def changeAxisLimits(self, axis='x', target='plot', redraw=True):
    # check whether to operate on data or resid plot
    if(target in ['plot', 'resid']):
      # changes limits of axis
      if(axis == 'x'):
        # retrieve values from field
        upperx = self.upperLimitx.text()
        try:
          upperx = float(upperx)
        except:
          upperx = 0.0
  
        lowerx = self.lowerLimitx.text()
        try:
          lowerx = float(lowerx)
        except:
          lowerx = 0.0
        # check whether any value changed
        if((upperx != self.maxX) or (lowerx != self.minX)):
          # do some checks and update axis (don't redraw, plot functions will take care of)
          self.setAxisLimits(lower = lowerx, upper = upperx, axis = 'x', updateLabel = False, target='plot', redraw=False, updateGrid=True)
          self.setAxisLimits(lower = lowerx, upper = upperx, axis = 'x', updateLabel = False, target='resid', redraw=False, updateGrid=True)
          # replot function over current x-interval
          self.parent.fit[self.parent.activeFit].handlePlot = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                         handlePlot=self.parent.fit[self.parent.activeFit].handlePlot, redraw=redraw)
          self.handleResidZero = self.plotResidZero(handleResidZero=self.handleResidZero, redraw=redraw)
      elif(axis == 'x2'):
        # retrieve values from field
        upperx = self.xSplitUpperLimitx.text()
        try:
          upperx = float(upperx)
        except:
          upperx = 0.0
  
        lowerx = self.xSplitLowerLimitx.text()
        try:
          lowerx = float(lowerx)
        except:
          lowerx = 0.0
        # check whether any value changed
        if((upperx != self.maxX_div) or (lowerx != self.minX_div)):
          # do some checks and update axis (don't redraw, plot functions will take care of)
          self.setAxisLimits(lower = lowerx, upper = upperx, axis = 'x2', updateLabel = False, target='plot', redraw=False, updateGrid=True)
          self.setAxisLimits(lower = lowerx, upper = upperx, axis = 'x2', updateLabel = False, target='resid', redraw=False, updateGrid=True)
          # replot function over current x-interval
          self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                         handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div,redraw=redraw, splitX=True)
          self.handleResidZero_div = self.plotResidZero(handleResidZero=self.handleResidZero_div, redraw=redraw, splitX=True)
      elif(axis == 'y'):
        # retrieve values from field
        if(target == 'plot'):
          uppery = self.upperLimity.text()
          lowery = self.lowerLimity.text()
        else:
          uppery = self.upperLimitResidy.text()
          lowery = self.lowerLimitResidy.text()

        try:
          uppery = float(uppery)
        except:
          uppery = 0.0
  
        try:
          lowery = float(lowery)
        except:
          lowery = 0.0
        
        # check whether any value changed
        if(target == 'plot'):
          if((uppery != self.maxY) or (lowery != self.minY)):
            # do some checks and update axis
            self.setAxisLimits(lower = lowery, upper = uppery, axis = 'y', updateLabel = False, target=target, redraw=redraw, updateGrid=True)
        else:
          if((uppery != self.maxResidY) or (lowery != self.minResidY)):
            # do some checks and update axis
            self.setAxisLimits(lower = lowery, upper = uppery, axis = 'y', updateLabel = False, target=target, redraw=redraw, updateGrid=True)
      elif(axis == 'y2'):
        # modify second y axis
        uppery = self.secondUpperLimit.text()
        lowery = self.secondLowerLimit.text()

        try:
          uppery = float(uppery)
        except:
          uppery = 0.0
  
        try:
          lowery = float(lowery)
        except:
          lowery = 0.0
        
        # check whether any value changed
        if((uppery != self.maxY2) or (lowery != self.minY2)):
          # do some checks and update axis
          self.setAxisLimits(lower = lowery, upper = uppery, axis = 'y2', updateLabel = False, target=target, redraw=redraw, updateGrid=True)
      
  def setAxisLimits(self, lower=0, upper=1, axis='x', updateLabel=False, target='plot', redraw=True, updateTicks=True, updateGrid=True):
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        plotobject = self.dataplotwidget; axisobject = self.ax
        if(axis == 'x2'):
          axisobject = [self.ax_div, self.ax2_div]
      else:
        plotobject = self.residplotwidget; axisobject = self.ax_resid
        if(axis == 'x2'):
          axisobject = [self.ax_resid_div]
    else:
      axis='abort'
    # performs checks and then sets axis limits
    if(axis == 'x'):
      # have to prevent nan and inf here
      if(np.isfinite(lower)):
        self.minX = lower
      if(np.isfinite(upper)):
        self.maxX = upper
      # check current axis mode and take care of log values
      axis_mode = str(self.modeSelectorx.currentText())
      if (axis_mode == 'log'):
        if ((self.minX <= 0) or (self.maxX <= 0)):
          # look whether data are loaded
          data = self.parent.data[self.parent.activeData].value()
          if ('x' in data):
            xdata = np.array(data['x'])
            xdata = xdata[xdata > 0]
            if(len(xdata)):
              min_xdata = np.min(xdata); max_xdata = np.max(xdata)
              if((self.data_spacer > 0) and (len(xdata) > 1)):
                difference = np.log(max_xdata / min_xdata)
                min_xdata = np.exp(np.log(min_xdata) - self.data_spacer * difference)
                max_xdata = np.exp(np.log(max_xdata) + self.data_spacer * difference)
            else:
              min_xdata, max_xdata = 0, 0
            self.minX = np.max((self.EPSILON, self.minX, min_xdata))
            self.maxX = np.max((self.EPSILON, self.maxX, max_xdata))
          else:
            # ensure that min and max values are positive
            self.minX = np.max((self.EPSILON, self.minX))
            self.maxX = np.max((self.EPSILON, self.maxX))
          updateLabel = True
      
      # update labels?
      if(updateLabel):
        self.upperLimitx.setText(str(self.parent.formatNumber(self.maxX)))
        self.lowerLimitx.setText(str(self.parent.formatNumber(self.minX)))
        
      # update axis
      axisobject.set_xlim([self.minX, self.maxX])
      if(updateTicks):
        self.setTickOne4All(axis=axis, redraw=False, target=target)

      # do we have a grid to draw?
      if(updateGrid):
        for item in ('x', 'y', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)

      for axis in ['left', 'right']:
        if((axis_mode == 'log') and (self.axisPosition[axis] == 'data')):
          # only required for log plots which we had to cast to axes coords
          if(target == 'plot'):
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax, target=target, secondAxes=False)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_div, target=target, secondAxes=False, splitX=True)
          else:
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_resid, target=target, secondAxes=False)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_resid_div, target=target, secondAxes=False, splitX=True)

      for spine in ['left2', 'right2']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2, target='plot', secondAxes=True)
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2_div, target='plot', secondAxes=True, splitX=True)

      if(redraw):
        plotobject.myRefresh()
    elif(axis == 'x2'):
      # have to prevent nan and inf here
      if(np.isfinite(lower)):
        self.minX_div = lower
      if(np.isfinite(upper)):
        self.maxX_div = upper
      # check current axis mode and take care of log values
      axis_mode = str(self.xSplitModeSelectorx.currentText())
      if (axis_mode == 'log'):
        if ((self.minX_div <= 0) or (self.maxX_div <= 0)):
          # look whether data are loaded
          data = self.parent.data[self.parent.activeData].value()
          if ('x' in data):
            xdata = np.array(data['x'])
            xdata = xdata[xdata > 0]
            if(len(xdata)):
              min_xdata = np.min(xdata); max_xdata = np.max(xdata)
              if((self.data_spacer > 0) and (len(xdata) > 1)):
                difference = np.log(max_xdata / min_xdata)
                min_xdata = np.exp(np.log(min_xdata) - self.data_spacer * difference)
                max_xdata = np.exp(np.log(max_xdata) + self.data_spacer * difference)
            else:
              min_xdata, max_xdata = 0, 0
            self.minX_div = np.max((self.EPSILON, self.minX_div, min_xdata))
            self.maxX_div = np.max((self.EPSILON, self.maxX_div, max_xdata))
          else:
            # ensure that min and max values are positive
            self.minX_div = np.max((self.EPSILON, self.minX_div))
            self.maxX_div = np.max((self.EPSILON, self.maxX_div))
          updateLabel = True
      
      # update labels?
      if(updateLabel):
        self.xSplitUpperLimitx.setText(str(self.parent.formatNumber(self.maxX_div)))
        self.xSplitLowerLimitx.setText(str(self.parent.formatNumber(self.minX_div)))
        
      # update axis
      for entry in axisobject:
        entry.set_xlim([self.minX_div, self.maxX_div])
      # should be able to use the same call which updates both regular x axis and divided one
      if(updateTicks):
        self.setTickOne4All(axis='x', redraw=False, target=target)

      # do we have a grid to draw?
      if(updateGrid):
        for item in ('x2', 'y', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)

      '''
      for axis in ['left', 'right']:
        if((axis_mode == 'log') and (self.axisPosition[axis] == 'data')):
          # only required for log plots which we had to cast to axes coords
          if(target == 'plot'):
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_div, target=target, secondAxes=False, splitX=True)
          else:
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax_resid_div, target=target, secondAxes=False, splitX=True)

      for spine in ['left2', 'right2']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2_div, target='plot', secondAxes=True, splitX=True)
      '''
      
      if(redraw):
        plotobject.myRefresh()
    elif(axis == 'y'):
      if(target == 'plot'):
        # have to prevent nan and inf here
        if(np.isfinite(lower)):
          self.minY = lower
        if(np.isfinite(upper)):
          self.maxY = upper
        # check current axis mode and take care of log values
        axis_mode = str(self.modeSelectory.currentText())
        if ((axis_mode == 'log') and (target == 'plot')):
          if ((self.minY <= 0) or (self.maxY <= 0)):
            # look whether data are loaded
            data = self.parent.data[self.parent.activeData].value()
            if ('y' in data):
              ydata = np.array(data['y'])
              ydata = ydata[ydata > 0]
              if(len(ydata)):
                min_ydata = np.min(ydata); max_ydata = np.max(ydata)
                if((self.data_spacer > 0) and (len(ydata) > 1)):
                  difference = np.log(max_ydata / min_ydata)
                  min_ydata = np.exp(np.log(min_ydata) - self.data_spacer * difference)
                  max_ydata = np.exp(np.log(max_ydata) + self.data_spacer * difference)
              else:
                min_ydata, max_ydata = 0, 0
              self.minY = np.max((self.EPSILON, self.minY, min_ydata))
              self.maxY = np.max((self.EPSILON, self.maxY, max_ydata))
            else:
              # ensure that min and max values are positive
              self.minY = np.max((self.EPSILON, self.minY))
              self.maxY = np.max((self.EPSILON, self.maxY))
            updateLabel = True
        
        # update labels?
        if(updateLabel):
          self.upperLimity.setText(str(self.parent.formatNumber(self.maxY)))
          self.lowerLimity.setText(str(self.parent.formatNumber(self.minY)))

        # update axis
        axisobject.set_ylim([self.minY, self.maxY])
        if(updateTicks):
          self.setTickOne4All(axis=axis, redraw=False, target=target)

        # do we have a grid to draw?
        if(updateGrid):
          for item in ('x', 'x2', 'y'):
            if(self.gridVisible[item]):
              self.drawAxisGrid(axis=item, redraw=False, target=target)
  
        # adjust spine lines if needed
        for axis in ['top', 'bottom']:
          if(self.axisPosition[axis] == 'data'):
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax2, target=target, secondAxes=False)
            self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax2_div, target=target, secondAxes=False, splitX=True)

        if(redraw):
          plotobject.myRefresh()
      else:
        # have to prevent nan and inf here
        if(np.isfinite(lower)):
          self.minResidY = lower
        if(np.isfinite(upper)):
          self.maxResidY = upper

        # update labels?
        if(updateLabel):
          self.upperLimitResidy.setText(str(self.parent.formatNumber(self.maxResidY)))
          self.lowerLimitResidy.setText(str(self.parent.formatNumber(self.minResidY)))
        
        # update axis
        axisobject.set_ylim([self.minResidY, self.maxResidY])
        if(updateTicks):
          self.setTickOne4All(axis=axis, redraw=False, target=target)

        # do we have a grid to draw?
        if(updateGrid):
          for item in ('x', 'x2', 'y'):
            if(self.gridVisible[item]):
              self.drawAxisGrid(axis=item, redraw=False, target=target)

        if(redraw):
          plotobject.myRefresh()
    elif(axis == 'y2'):
      axisobject = self.ax2
      # have to prevent nan and inf here
      if(np.isfinite(lower)):
        self.minY2 = lower
      if(np.isfinite(upper)):
        self.maxY2 = upper
      # check current axis mode and take care of log values
      axis_mode = str(self.secondModeSelector.currentText())
      if(axis_mode == 'log'):
        if ((self.minY2 <= 0) or (self.maxY2 <= 0)):
          # look whether data are loaded
          data = self.parent.data[self.parent.activeData].value()
          if ('y' in data):
            ydata = np.array(data['y'])
            ydata = ydata[ydata > 0]
            if(len(ydata)):
              min_ydata = np.min(ydata); max_ydata = np.max(ydata)
              if((self.data_spacer > 0) and (len(ydata) > 1)):
                difference = np.log(max_ydata / min_ydata)
                min_ydata = np.exp(np.log(min_ydata) - self.data_spacer * difference)
                max_ydata = np.exp(np.log(max_ydata) + self.data_spacer * difference)
            else:
              min_ydata, max_ydata = 0, 0
            self.minY2 = np.max((self.EPSILON, self.minY2, min_ydata))
            self.maxY2 = np.max((self.EPSILON, self.maxY2, max_ydata))
          else:
            # ensure that min and max values are positive
            self.minY2 = np.max((self.EPSILON, self.minY2))
            self.maxY2 = np.max((self.EPSILON, self.maxY2))
          updateLabel = True
      
      # update labels?
      if(updateLabel):
        self.secondUpperLimit.setText(str(self.parent.formatNumber(self.maxY2)))
        self.secondLowerLimit.setText(str(self.parent.formatNumber(self.minY2)))

      # update axis
      axisobject.set_ylim([self.minY2, self.maxY2])
      if(updateTicks):
        self.setTickOne4All(axis=axis, redraw=False, target=target)

      # do we have a grid to draw?
      if(updateGrid):
        for item in ('x', 'x2', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)

      # adjust spine lines if needed
      for axis in ['top', 'bottom']:
        if(self.axisPosition[axis] == 'data'):
          self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax2, target=target, secondAxes=False)
          self.setAxisPositionHelper(axis=axis, plotobject=plotobject, axisobject=self.ax2_div, target=target, secondAxes=False, splitX=True)

      if(redraw):
        plotobject.myRefresh()

  def drawAxisGrid(self, axis='x', target='plot', redraw=False):
    # draws custom grid lines
    if(target in ['plot', 'resid']):
      if(target == 'plot'):
        # draw grid on 1st set of axes
        plotobject = self.dataplotwidget; axisobject = [self.ax, self.ax_div]
        if(axis == 'x'):
          axisobject = [self.ax]
        elif(axis == 'x2'):
          axisobject =[self.ax_div]
        elif(axis == 'y2'):
          axisobject = [self.ax2, self.ax2_div]
        useVisible, useColor, useWidth, useStyle, useDashStyle, useGridOrder = self.gridVisible[axis], self.gridColor[axis], self.gridWidth[axis], self.gridStyle[axis], self.gridDashStyle[axis], self.gridOrder[axis]
      else:
        plotobject = self.residplotwidget; axisobject = [self.ax_resid, self.ax_resid_div]
        if(axis == 'x'):
          axisobject = [self.ax_resid]
        elif(axis == 'x2'):
          axisobject =[self.ax_resid_div]
        useVisible, useColor, useWidth, useStyle, useDashStyle, useGridOrder = self.gridVisible_resid[axis], self.gridColor_resid[axis], self.gridWidth_resid[axis], self.gridStyle_resid[axis], self.gridDashStyle_resid[axis], self.gridOrder_resid[axis]
      
      if(useGridOrder == 'back'):
        useZ = 1
      else:
        useZ = 500
        
      # remove previous lines for this axis
      if(target == 'plot'):
        for entry in self.gridLinesStore[axis]:
          entry.remove()
        self.gridLinesStore[axis] = []
      else:
        for entry in self.gridLinesStore_resid[axis]:
          entry.remove()
        self.gridLinesStore_resid[axis] = []

      # replace grid lines by custom lines
      allLineHandles = []
      if(useVisible):
        for targetAxis in axisobject:
          lines = []
          # determine positions for drawing new ones
          if(axis in ['x', 'x2']):
            ticks = np.array(targetAxis.xaxis.get_majorticklocs())
            if(axis == 'x'):
              vmin, vmax = min(self.minX, self.maxX), max(self.minX, self.maxX)
            else:
              vmin, vmax = min(self.minX_div, self.maxX_div), max(self.minX_div, self.maxX_div)
            # filter for visible ticks
            cond1 = ticks >= vmin
            cond2 = ticks <= vmax
            cond3 = ~np.isclose(ticks, vmin)
            cond4 = ~np.isclose(ticks, vmax)
            ticks = ticks.compress(cond1 & cond2 & cond3 & cond4)
            # create plot coordinates
            if(target == 'resid'):
              minY, maxY = min(self.minResidY, self.maxResidY), max(self.minResidY, self.maxResidY)
            else:
              minY, maxY = min(self.minY, self.maxY), max(self.minY, self.maxY)
            for entry in ticks:
              lines.append([[entry, entry], [minY, maxY]])
          else:
            ticks = targetAxis.yaxis.get_majorticklocs()
            if(target == 'resid'):
              vmin, vmax = min(self.minResidY, self.maxResidY), max(self.minResidY, self.maxResidY)
            elif(axis == 'y'):
              vmin, vmax = min(self.minY, self.maxY), max(self.minY, self.maxY)
            else:
              vmin, vmax = min(self.minY2, self.maxY2), max(self.minY2, self.maxY2)
            cond1 = ticks >= vmin
            cond2 = ticks <= vmax
            cond3 = ~np.isclose(ticks, vmin)
            cond4 = ~np.isclose(ticks, vmax)
            ticks = ticks.compress(cond1 & cond2 & cond3 & cond4)
            # create plot coordinates
            if(targetAxis in [self.ax, self.ax2, self.ax_resid]):
              minX, maxX = min(self.minX, self.maxX), max(self.minX, self.maxX)
            else:
              minX, maxX = min(self.minX_div, self.maxX_div), max(self.minX_div, self.maxX_div)
            for entry in ticks:
              lines.append([[minX, maxX], [entry, entry]])
  
          # draw these lines
          for entry in lines:
            drawLine = matplotlib.lines.Line2D(entry[0], entry[1])
            allLineHandles.append(targetAxis.add_line(drawLine))
            # apply styles
            drawLine.set_color(useColor)
            drawLine.set_linewidth(useWidth)
            drawLine.set_linestyle(useStyle)
            drawLine.set_dash_capstyle(useDashStyle)
            drawLine.set_solid_capstyle(useDashStyle)
            drawLine.set_zorder(useZ)
          
        # store them for future manipulation
        if(target == 'plot'):
          self.gridLinesStore[axis].extend(allLineHandles)
        else:
          self.gridLinesStore_resid[axis].extend(allLineHandles)

      # redraw
      if(redraw):
        plotobject.myRefresh()

  def changeAxisMode(self, axis='x', redraw=True):
    # changes scale mode of axis
    if(axis == 'x'):
      # adjust axis
      axis_mode = str(self.modeSelectorx.currentText())
      if(axis_mode == 'linear'):
        # in this case, change axis scale first
        self.ax.set_xscale(axis_mode)
        self.ax_resid.set_xscale(axis_mode)
      self.setAxisLimits(lower = self.minX, upper = self.maxX, axis = 'x', updateLabel = False, target='plot', redraw=False, updateGrid=True)
      self.setAxisLimits(lower = self.minX, upper = self.maxX, axis = 'x', updateLabel = False, target='resid', redraw=False, updateGrid=True)
      if(axis_mode != 'linear'):
        # in this case, change axis scale last
        self.ax.set_xscale(axis_mode)
        self.ax_resid.set_xscale(axis_mode)
      self.modeX = axis_mode
      # trigger redrawing of fit function with new axis limits and minor ticks
      if(self.modeX == 'linear'):
        minorAutoticks = MyAutoMinorLocator(self.ticksXMinor + 1)
        self.ax.xaxis.set_minor_locator(minorAutoticks)
        self.ax_resid.xaxis.set_minor_locator(minorAutoticks)
        self.ax.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        self.ax_resid.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      elif(self.modeX == 'log'):
        # reset minor ticks to 8 when changing to log scale
        if(self.ticksXMinor > 1):
          self.ticksXMinor, targetField = 8, self.parent.graphicsarea.configMinorTickX
          targetField.blockSignals(True)
          if(targetField.findText(str(8)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(8)))
          targetField.blockSignals(False)
        minorAutoticks = MyAutoMinorLocator(self.ticksXMinor + 1)
        self.ax.xaxis.set_minor_locator(minorAutoticks)
        self.ax_resid.xaxis.set_minor_locator(minorAutoticks)
        self.ax.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        self.ax_resid.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        
      self.parent.fit[self.parent.activeFit].handlePlot = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                     handlePlot=self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
      self.handleResidZero = self.plotResidZero(handleResidZero=self.handleResidZero, redraw=False)
      # adjust spine lines if needed
      for spine in ['left', 'right']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax, target='plot', secondAxes=False)
          self.setAxisPositionHelper(axis=spine, plotobject=self.residplot, axisobject=self.ax_resid, target='resid', secondAxes=False)
      for spine in ['left2', 'right2']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2, target='plot', secondAxes=True)
      
      # update axis grid
      for target in ('plot', 'resid'):
        for item in ('x', 'y', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      # redraw
      if(redraw):
        self.dataplotwidget.myRefresh()
        self.residplotwidget.myRefresh()
    elif(axis == 'x2'):
      # adjust axis
      axis_mode = str(self.xSplitModeSelectorx.currentText())
      if(axis_mode == 'linear'):
        # in this case, change axis scale first
        self.ax_div.set_xscale(axis_mode)
        self.ax2_div.set_xscale(axis_mode)
        self.ax_resid_div.set_xscale(axis_mode)
      self.setAxisLimits(lower = self.minX_div, upper = self.maxX_div, axis = 'x2', updateLabel = False, target='plot', redraw=False, updateGrid=True)
      self.setAxisLimits(lower = self.minX_div, upper = self.maxX_div, axis = 'x2', updateLabel = False, target='resid', redraw=False, updateGrid=True)
      if(axis_mode != 'linear'):
        # in this case, change axis scale last
        self.ax_div.set_xscale(axis_mode)
        self.ax2_div.set_xscale(axis_mode)
        self.ax_resid_div.set_xscale(axis_mode)
      self.modeX_div = axis_mode
      # trigger redrawing of fit function with new axis limits and minor ticks
      if(self.modeX_div == 'linear'):
        minorAutoticks2 = MyAutoMinorLocator(self.ticksXMinor_div + 1)
        self.ax_div.xaxis.set_minor_locator(minorAutoticks2)
        self.ax_resid_div.xaxis.set_minor_locator(minorAutoticks2)
        self.ax_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        self.ax_resid_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      elif(self.modeX_div == 'log'):
        # reset minor ticks to 9 when changing to log scale
        if(self.ticksXMinor_div > 1):
          self.ticksXMinor_div, targetField = 8, self.parent.graphicsarea.configInnerMinorTickX
          targetField.blockSignals(True)
          if(targetField.findText(str(8)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(8)))
          targetField.blockSignals(False)
        minorAutoticks2 = MyAutoMinorLocator(self.ticksXMinor_div + 1)
        self.ax2_div.xaxis.set_minor_locator(minorAutoticks2)
        self.ax_resid_div.xaxis.set_minor_locator(minorAutoticks2)
        self.ax2_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        self.ax_resid_div.xaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
        
      self.parent.fit[self.parent.activeFit].handlePlot_div = self.plotFunction(fitobject=self.parent.fit[self.parent.activeFit], x=[],\
                     handlePlot=self.parent.fit[self.parent.activeFit].handlePlot_div, redraw=False, splitX=True)
      self.handleResidZero_div = self.plotResidZero(handleResidZero=self.handleResidZero_div, redraw=False, splitX=True)

      # adjust spine lines if needed
      for spine in ['left', 'right']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax_div, target='plot', secondAxes=False, splitX=True)
          self.setAxisPositionHelper(axis=spine, plotobject=self.residplot, axisobject=self.ax_resid_div, target='resid', secondAxes=False, splitX=True)
      for spine in ['left2', 'right2']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine[:-1], plotobject=self.matplot, axisobject=self.ax2_div, target='plot', secondAxes=True, splitX=True)

      # update axis grid
      for target in ('plot', 'resid'):
        for item in ('x2', 'y', 'y2'):
          if(self.gridVisible[item]):
            if((item != 'y2') or self.isSecondAxesActive()):
              self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      # redraw
      if(redraw):
        self.dataplotwidget.myRefresh()
        self.residplotwidget.myRefresh()
    elif(axis == 'y'):
      # adjust axis
      axis_mode = str(self.modeSelectory.currentText())
      if(axis_mode == 'linear'):
        # in this case, change axis scale first
        self.ax.set_yscale(axis_mode)
      self.setAxisLimits(lower = self.minY, upper = self.maxY, axis = 'y', updateLabel = False, redraw=False, updateGrid=True)
      if(axis_mode != 'linear'):
        # in this case, change axis scale last
        self.ax.set_yscale(axis_mode)
      self.modeY = axis_mode
      if(self.modeY == 'linear'):
        minorAutoticks = MyAutoMinorLocator(self.ticksYMinor + 1)
        self.ax.yaxis.set_minor_locator(minorAutoticks)
        self.ax.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      else:
        # reset minor ticks to 9 when changing to log scale
        if(self.ticksYMinor > 1):
          self.ticksYMinor, targetField = 8, self.parent.graphicsarea.configMinorTickY
          targetField.blockSignals(True)
          if(targetField.findText(str(8)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(8)))
          targetField.blockSignals(False)
        minorAutoticks = MyAutoMinorLocator(self.ticksYMinor + 1)
        self.ax.yaxis.set_minor_locator(minorAutoticks)
        self.ax.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      # adjust spine lines if needed
      for spine in ['bottom', 'top']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax, target='plot', secondAxes=False)
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax_div, target='plot', secondAxes=False, splitX=True)

      # update axis grid
      target = 'plot'
      for item in ('x', 'x2', 'y'):
        if(self.gridVisible[item]):
          self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      # redraw
      if(redraw):
        self.dataplotwidget.myRefresh()
    elif(axis == 'y2'):
      # adjust axis
      axis_mode = str(self.secondModeSelector.currentText())
      if(axis_mode == 'linear'):
        # in this case, change axis scale first
        self.ax2.set_yscale(axis_mode)
      self.setAxisLimits(lower = self.minY2, upper = self.maxY2, axis = 'y2', updateLabel = False, redraw=False, updateGrid=True)
      if(axis_mode != 'linear'):
        # in this case, change axis scale last
        self.ax2.set_yscale(axis_mode)
      self.modeY2 = axis_mode
      if(self.modeY2 == 'linear'):
        minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor + 1)
        self.ax.yaxis.set_minor_locator(minorAutoticks)
        self.ax.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      else:
        # reset minor ticks to 9 when changing to log scale
        if(self.ticksY2Minor > 1):
          self.ticksY2Minor, targetField = 8, self.parent.graphicsarea2.configMinorTickY
          targetField.blockSignals(True)
          if(targetField.findText(str(8)) >= 0):
            targetField.setCurrentIndex(targetField.findText(str(8)))
          targetField.blockSignals(False)        
        minorAutoticks = MyAutoMinorLocator(self.ticksY2Minor + 1)
        self.ax.yaxis.set_minor_locator(minorAutoticks)
        self.ax.yaxis.set_minor_formatter(matplotlib.ticker.NullFormatter())
      # adjust spine lines if needed
      for spine in ['bottom', 'top']:
        if(self.axisPosition[spine] == 'data'):
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax2, target='plot', secondAxes=False)
          self.setAxisPositionHelper(axis=spine, plotobject=self.matplot, axisobject=self.ax2_div, target='plot', secondAxes=False, splitX=True)

      # update axis grid
      target = 'plot'
      for item in ('x', 'x2', 'y2'):
        if(self.gridVisible[item]):
          if((item != 'y2') or self.isSecondAxesActive()):
            self.drawAxisGrid(axis=item, redraw=False, target=target)
      
      # redraw
      if(redraw):
        self.dataplotwidget.myRefresh()

  def plotResidZero(self, handleResidZero=None, redraw=False, splitX=False):
    # plots zero line in residuals plot
    if(splitX):
      self.handleResidZero_div = handleResidZero
      # set up data
      xval = [self.minX_div, self.maxX_div]
      yval = [0, 0]
      # do the actual plot
      if(self.handleResidZero_div != None):
        #self.handleData.remove()
        self.handleResidZero_div.set_xdata(xval)
        self.handleResidZero_div.set_ydata(yval)
      else:
        self.handleResidZero_div, = self.ax_resid_div.plot(xval, yval, 'ko', zorder = 0.5  + self.parent.zOffset)
      handleResidZero = self.handleResidZero_div
    else:
      self.handleResidZero = handleResidZero
      # set up data
      xval = [self.minX, self.maxX]
      yval = [0, 0]
      # do the actual plot
      if(self.handleResidZero != None):
        #self.handleData.remove()
        self.handleResidZero.set_xdata(xval)
        self.handleResidZero.set_ydata(yval)
      else:
        self.handleResidZero, = self.ax_resid.plot(xval, yval, 'ko', zorder = 0.5  + self.parent.zOffset)
      handleResidZero = self.handleResidZero
    self.rememberSettingResidLine['init'] = 'ax_resid.plot(' + repr(xval) + ', ' + repr(yval) + ', zorder=' + repr(0.5  + self.parent.zOffset) + ')'
      
    # apply style of fit curve to zero line
    style = self.parent.data[self.parent.activeData].getResidLineStyle()
    for key in style:
      method = 'set_'+key
      if (hasattr(handleResidZero, method)):
        method2call = getattr(handleResidZero, method)
        method2call(style[key])
        self.rememberSettingResidLine[key] = 'set_' + key + '(' + repr(style[key]) + ')'
    # ensure only line is visible but not markers
    if (hasattr(handleResidZero, 'set_linestyle')):
        method2call = getattr(handleResidZero, 'set_linestyle')
        method2call('solid')        
        self.rememberSettingResidLine['linestyle'] = 'set_linestyle(\'solid\')'
    if (hasattr(handleResidZero, 'set_marker')):
        method2call = getattr(handleResidZero, 'set_marker')
        method2call('None')
        self.rememberSettingResidLine['marker'] = 'set_marker(\'None\')'
        
    # do redraw?
    if(redraw):
      self.residplotwidget.myRefresh()
    
    return handleResidZero

  def plotResid(self, dataobject=None, handleResid=None, handleResidZero=None, handleResidBar=None, handleResidStack=None, handleResidStackNeg=None, handleResidText=None, redraw=True, splitX=False, rescale=True):
    # was dataobject specified?
    if(dataobject == None):
      dataobject = self.parent.data[self.parent.activeData]

    if(splitX):
      useAxes = self.ax_resid_div
    else:
      useAxes = self.ax_resid
      
    # analyze data
    xval = dataobject.x
    yval = dataobject.resid
    if(yval.size > 0):
      # plot residuals
      if(handleResid != None):
        handleResid.set_xdata(xval)
        handleResid.set_ydata(yval)
      else:
        handleResid, = useAxes.plot(xval, yval, 'ko', zorder = dataobject.zorder + self.parent.zOffset)
        if(not splitX):
          handleResid.set_pickradius(PICK_TOLERANCE)
        
      # draw bar?
      if(handleResidBar != None):
        handleResidBar.remove()

      if((dataobject.ResidBarstyle['showBar']) and (dataobject.ResidBarstyle['offset'] != 0)):
        # also use this for error bars
        useOffset = dataobject.ResidBarstyle['offset']
      else:
        useOffset = 0
  
      if(dataobject.ResidBarstyle['showBar']):
        barstyle = dataobject.getResidBarStyle()
        if('width' in barstyle):
          usewidth = barstyle['width']
        else:
          usewidth = 0.5

        handleResidBar = useAxes.bar(xval + useOffset, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, align='center', width=usewidth)
      else:
        handleResidBar = None

      # draw stack?
      if(handleResidStack != None):
        handleResidStack.remove()
      if(handleResidStackNeg != None):
        handleResidStackNeg.remove()

      if(dataobject.ResidStackstyle['showStack']):
        posVals = (yval >= 0)
        posCount = [i for i in posVals if i]
        negCount = [i for i in posVals if (not i)]
        if(len(posCount)):
          handleResidStack, = useAxes.stackplot(xval, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, where=(yval >= 0), interpolate=True)
          if(not splitX):
            handleResidStack.set_pickradius(PICK_TOLERANCE)
        else:
          handleResidStack = None
        if(len(negCount)):
          handleResidStackNeg, = useAxes.stackplot(xval, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, where=(yval < 0), interpolate=True)
          if(not splitX):
            handleResidStackNeg.set_pickradius(PICK_TOLERANCE)
        else:
          handleResidStackNeg = None
      else:
        handleResidStack = None
        handleResidStackNeg = None

      # apply styles
      style = dataobject.getResidStyle()
      for key in style:
        method = 'set_'+key
        if (hasattr(handleResid, method)):
          method2call = getattr(handleResid, method)
          method2call(style[key])
      if(not style['doFill']):
        handleResid.set_markerfacecolor('none')

      # draw text labels?
      if(handleResidText != None):
        for entry in handleResidText:
          entry.remove()
        handleResidText = None
          
      if(dataobject.ResidTextstyle['showText']):
        textstyle = dataobject.getResidTextStyle()
        # prepare list of data points
        labels = [''] * len(xval); useYFlag = False
        if(('type' in textstyle) and (textstyle['type'] == 'labels')):
          labels = dataobject.getLabels()
          if(len(labels) != len(xval)):
            labels = [''] * len(xval)
            self.parent.statusbar.showMessage('Cannot use label information, will use y values instead.', self.parent.STATUS_TIME, color='blue')
            useYFlag = True
        comboList = [[i, j, k] for i, j, k  in zip(xval, yval, labels)]
        if(textstyle['skip']):
          comboList = comboList[::textstyle['skip'] + 1]

        if(len(comboList)):
          handleResidText = []
          if(('padX' in textstyle) and ('padY' in textstyle)):
            padX, padY = textstyle['padX'], textstyle['padY']
          else:
            padX, padY = 0.0, 0.0
          for entry in comboList:
            x, y, label = entry
            if(textstyle['type'] == 'x'):
              output = self.parent.formatNumber(x)
            elif((textstyle['type'] == 'y') or useYFlag):
              output = self.parent.formatNumber(y)
            else:
              output = label
            if(len(output)):
              handleResidText.append(useAxes.text(x + padX + useOffset, y + padY, output, horizontalalignment='center', verticalalignment='bottom', zorder=dataobject.zorder + dataobject.relativeZOrderText + self.parent.zOffset))
              handleResidText[-1].set_clip_on(True)

      # plot zero line
      if(splitX):
        self.handleResidZero_div = self.plotResidZero(self.handleResidZero_div, False, splitX=True)
        handleResidZero = self.handleResidZero_div
      else:
        self.handleResidZero = self.plotResidZero(self.handleResidZero, False)
        self.handleResidZero.set_pickradius(PICK_TOLERANCE)
        handleResidZero = self.handleResidZero
          
      # adjust x-axis limits to those of main plot
      if((not splitX) and rescale):
        self.setAxisLimits(lower = self.minX, upper = self.maxX, axis = 'x', updateLabel = False, target='resid', redraw=False, updateGrid=True)
      
        # auto adjust y limits
        # need to take care of potential nan and inf values
        procval = [i for i in yval if ((not np.isnan(i)) and (not np.isinf(i)))]
        if(len(procval)):
          temp_ylimit = np.max([np.abs(i) for i in procval])
          # ensure minimum limit
          if (temp_ylimit == 0):
            self.maxResidY = self.EPSILON; self.minResidY = -self.EPSILON
          else:
            self.maxResidY = 1.2 * temp_ylimit; self.minResidY = -1.2 * temp_ylimit
          self.setAxisLimits(lower = self.minResidY, upper = self.maxResidY, axis = 'y', updateLabel = True, target='resid', redraw=False, updateGrid=True)
          
      # apply bar styles
      if(dataobject.ResidBarstyle['showBar']):
        barstyle = dataobject.getResidBarStyle()
        for entry in handleResidBar.patches:
          for key in barstyle:
            method = 'set_'+key
            # treat width differently to avoid recentering of bars upon width change (does not heed center position)
            if ((key != 'width') and (hasattr(entry, method))):
              method2call = getattr(entry, method)
              # extra check b/c of hatchMultiply
              if((key == 'hatch') and ('hatchMultiply' in barstyle)):
                method2call(barstyle[key] * barstyle['hatchMultiply'])
              else:
                method2call(barstyle[key])
            # set alternate color?
            if((entry.get_height() < 0) and ('facecolorAlt' in barstyle)):
              entry.set_facecolor(barstyle['facecolorAlt'])
        # check visibility of entire object
        if(not dataobject.visibilityResid):
          for entry in handleResidBar.patches:
            entry.set_visible(False)

        # special treatment for fill of error markers
        if(not dataobject.ResidBarstyle['doFill']):
          for entry in handleResidBar.patches:
            entry.set_facecolor('none')
 
      # apply stack styles
      if(dataobject.ResidStackstyle['showStack']):
        stackstyle = dataobject.getResidStackStyle()
        for handle in [handleResidStack, handleResidStackNeg]:
          if(handle != None):
            for key in stackstyle:
              method = 'set_'+key
              if (hasattr(handle, method)):
                method2call = getattr(handle, method)
                # extra check b/c of hatchMultiply
                if((key == 'hatch') and ('hatchMultiply' in stackstyle)):
                  method2call(stackstyle[key] * stackstyle['hatchMultiply'])
                else:
                  method2call(stackstyle[key])
            # set alternate color?
            if((handle == handleResidStackNeg) and ('facecolorAlt' in stackstyle)):
              handle.set_facecolor(stackstyle['facecolorAlt'])
            else:
              handle.set_facecolor(stackstyle['facecolor'])
        # check visibility of entire object
        if(not dataobject.visibilityResid):
          handleResidStack.set_visible(False)
          handleResidStackNeg.set_visible(False)

        # special treatment for fill of error markers
        if(not dataobject.ResidStackstyle['doFill']):
          for entry in [handleResidStack, handleResidStackNeg]:
            entry.set_facecolor('none')

      # apply text styles
      if(dataobject.ResidTextstyle['showText']):
        textstyle = dataobject.getResidTextStyle()
        if((handleResidText != None) and (len(handleResidText))):
          # apply styles
          for key in textstyle:
            method = 'set_' + key
            if(hasattr(handleResidText[0], method)):
              value = textstyle[key]; safeFont = 'DejaVu Sans'
              for item in handleResidText:
                method2call = getattr(item, method)
                method2call(value)
                if(key == 'fontname'):
                  # test last element descent, should be larger than zero
                  _, _, descent = item._get_layout(self.matplot.canvas.renderer)
                  if(not (descent > 0)):
                    self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                    value = safeFont
                    method2call(value)
          # check visibility of entire object
          if(not dataobject.visibilityResid):
            for item in handleResidText:
              if(hasattr(item, 'set_visible')):
                item.set_visible(False)

      # probably not really needed
      if(1):
        if(splitX):
          # assign handles
          self.handleResid_div = handleResid
          self.handleResidZero_div = handleResidZero
          self.handleResidBar_div = handleResidBar
          self.handleResidStack_div = handleResidStack
          self.handleResidStackNeg_div = handleResidStackNeg
          self.handleResidText_div = handleResidText
        else:
          # assign handles
          self.handleResid = handleResid
          self.handleResidZero = handleResidZero
          self.handleResidBar = handleResidBar
          self.handleResidStack = handleResidStack
          self.handleResidStackNeg = handleResidStackNeg
          self.handleResidText = handleResidText

      # draw everything
      if(redraw):
        self.residplotwidget.myRefresh()

      return handleResid, handleResidZero, handleResidBar, handleResidStack, handleResidStackNeg, handleResidText
    else:
      if(handleResid != None):
        handleResid.remove()
      if(handleResidBar != None):
        handleResidBar.remove()
      if(handleResidStack != None):
        handleResidStack.remove()
      if(handleResidStackNeg != None):
        handleResidStackNeg.remove()
      if(handleResidText != None):
        for entry in handleResidText:
          entry.remove()

      return None, handleResidZero, None, None, None, None
    
  def plotData(self, data, dataobject=None, handleData=None, handleErr=None, handleErrShady=None, handleBar=None, handleStack=None, handleStackNeg=None, handleText=None, handleViolin=None, redraw=True, rescale=True, splitX=False, autoIgnoreCurrentY=False):
    # was dataobject specified?
    if(dataobject == None):
      dataobject = self.parent.data[self.parent.activeData]
    
    # analyze data
    xerr, yerr = np.array([]), np.array([])
    if (('x' in data) and ('y' in data)):
      # okay found valid data, now assign values
      xval = data['x']
      yval = data['y']
      
      if ('xerr' in data):
        xerr = data['xerr']
        
      if ('yerr' in data):
        yerr = data['yerr']
        
      # determine which axes to draw on
      if(dataobject.onSecondAxes):
        useAxes = self.ax2
        if(splitX):
          useAxes = self.ax2_div
      else:
        useAxes = self.ax
        if(splitX):
          useAxes = self.ax_div
        
      # can do some plotting
      if((handleData != None) and (handleData.axes == useAxes)):
        handleData.set_xdata(xval)
        handleData.set_ydata(yval)
      else:
        if((handleData != None) and (handleData.axes != useAxes)):
          handleData.remove()
        handleData, = useAxes.plot(xval, yval, 'ko', zorder = dataobject.zorder  + self.parent.zOffset)
      if(not splitX):
        handleData.set_pickradius(PICK_TOLERANCE)
      
      # draw bar?
      if(handleBar != None):
        handleBar.remove()

      if((dataobject.Barstyle['showBar']) and (dataobject.Barstyle['offset'] != 0)):
        # also use this for error bars
        useOffset = dataobject.Barstyle['offset']
      else:
        useOffset = 0
  
      if(dataobject.Barstyle['showBar']):
        barstyle = dataobject.getBarStyle()
        if('width' in barstyle):
          usewidth = barstyle['width']
        else:
          usewidth = 0.5

        handleBar = useAxes.bar(xval + useOffset, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, align='center', width=usewidth)
      else:
        handleBar = None

      # draw stack?
      if(handleStack != None):
        handleStack.remove()
      if(handleStackNeg != None):
        handleStackNeg.remove()

      if(dataobject.Stackstyle['showStack']):
        posVals = (yval >= 0)
        posCount = [i for i in posVals if i]
        negCount = [i for i in posVals if (not i)]
        if(len(posCount)):
          handleStack, = useAxes.stackplot(xval, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, where=(yval >= 0), interpolate=True)
          if(not splitX):
            handleStack.set_pickradius(PICK_TOLERANCE)
        else:
          handleStack = None
        if(len(negCount)):
          handleStackNeg, = useAxes.stackplot(xval, yval, zorder=dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset, where=(yval < 0), interpolate=True)
          if(not splitX):
            handleStackNeg.set_pickradius(PICK_TOLERANCE)
        else:
          handleStackNeg = None
      else:
        handleStack = None
        handleStackNeg = None

      # draw error bars?
      if (handleErr != None):
        handleErr[0].remove()
        for entry in handleErr[1]:
          entry.remove()
        for entry in handleErr[2]:
          entry.remove()
          
      # prepare errors for drawing them in two direction
      drawXerr, drawYerr = xerr, yerr
      if(dataobject.Errorstyle['direction'] != 'both'):
        if(dataobject.Errorstyle['direction'] == 'negative'):
          if(xerr.size):
            drawXerr = [xerr, 0.0 * xerr]
          if(yerr.size):
            drawYerr = [yerr, 0.0 * yerr]
        else:
          if(xerr.size):
            drawXerr = [0.0 * xerr, xerr]
          if(yerr.size):
            drawYerr = [0.0 * yerr, yerr]
          
      if(xerr.size):
        if(yerr.size):
          handleErr = useAxes.errorbar(xval + useOffset, yval, xerr = drawXerr, yerr = drawYerr, zorder = dataobject.zorder + dataobject.relativeZOrderError + self.parent.zOffset, capsize = 1)#, fmt = 'o')
        else:
          handleErr = useAxes.errorbar(xval + useOffset, yval, xerr = drawXerr, zorder = dataobject.zorder + dataobject.relativeZOrderError + self.parent.zOffset, capsize = 1)#, fmt = 'o')
      elif(yerr.size):
        handleErr = useAxes.errorbar(xval + useOffset, yval, yerr = drawYerr, zorder = dataobject.zorder + dataobject.relativeZOrderError  + self.parent.zOffset, capsize = 1)#, fmt = 'o')
      else:
        handleErr = None
        
      if(handleErr != None):
        # don't draw the error curve
        handleErr[0].set_linestyle('None')
        handleErr[0].set_marker('None')
        
      # should we draw the error intervals as shaded region?
      if(handleErrShady != None):
        handleErrShady.remove()
        handleErrShady = None
      if((dataobject.ErrorShadystyle['visible']) and (yerr.size)):
        useYerrPos, useYerrNeg = 0.0 * yerr, 0.0 * yerr
        
        if(dataobject.Errorstyle['direction'] in ['both', 'positive']):
          useYerrPos = yerr
        if(dataobject.Errorstyle['direction'] in ['both', 'negative']):
          useYerrNeg = yerr
        handleErrShady = useAxes.fill_between(xval + useOffset, yval - useYerrNeg, yval + useYerrPos, zorder = dataobject.zorder + dataobject.relativeZOrderError + self.parent.zOffset - 0.05)
        # apply styles
        style = dataobject.getErrorShadyStyle()
        for key in style:
          method = 'set_'+key
          if (hasattr(handleErrShady, method)):
            method2call = getattr(handleErrShady, method)
            method2call(style[key])
        # check visibility of entire object
        if(not dataobject.visibility):
          if(hasattr(handleErrShady, 'set_visible')):
            handleErrShady.set_visible(False)
            
      # draw text labels?
      if(handleText != None):
        for entry in handleText:
          entry.remove()
        handleText = None
          
      if(dataobject.Textstyle['showText']):
        textstyle = dataobject.getTextStyle()
        # prepare list of data points
        labels = [''] * len(xval); useYFlag = False
        if(('type' in textstyle) and (textstyle['type'] == 'labels')):
          labels = dataobject.getLabels()
          if(len(labels) != len(xval)):
            labels = [''] * len(xval)
            self.parent.statusbar.showMessage('Cannot use label information, will use y values instead.', self.parent.STATUS_TIME, color='blue')
            useYFlag = True
        comboList = [[i, j, k] for i, j, k  in zip(xval, yval, labels)]
        if(textstyle['skip']):
          comboList = comboList[::textstyle['skip'] + 1]

        if(len(comboList)):
          handleText = []
          if(('padX' in textstyle) and ('padY' in textstyle)):
            padX, padY = textstyle['padX'], textstyle['padY']
          else:
            padX, padY = 0.0, 0.0
          for entry in comboList:
            x, y, label = entry
            if(textstyle['type'] == 'x'):
              output = self.parent.formatNumber(x)
            elif((textstyle['type'] == 'y') or useYFlag):
              output = self.parent.formatNumber(y)
            else:
              output = label
            if(len(output)):
              handleText.append(useAxes.text(x + padX + useOffset, y + padY, output, horizontalalignment='center', verticalalignment='bottom', zorder=dataobject.zorder + dataobject.relativeZOrderText + self.parent.zOffset))
              handleText[-1].set_clip_on(True)
     
      # draw violin plot
      if(handleViolin != None):
        for entry in handleViolin:
          if(type(handleViolin[entry]) == type([])):
            for entry2 in handleViolin[entry]:
              if(hasattr(entry2, 'remove')):
                entry2.remove()
          elif(hasattr(handleViolin[entry], 'remove')):
            handleViolin[entry].remove()
        handleViolin = None
          
      if(dataobject.Violinstyle['mode']):
        # get data organized into vectors
        xvector, yvector = dataobject.collateViolinData()
        if(len(xvector) * len(yvector)):
          if(dataobject.Violinstyle['mode'] == 1):
            if(('bodies' in dataobject.Violinstyle) and ('width' in dataobject.Violinstyle['bodies'])):
              useWidth = dataobject.Violinstyle['bodies']['width']
            else:
              useWidth = 0.5
            handleViolin = useAxes.violinplot(yvector, xvector, vert=True, showmeans=True, showextrema=True, showmedians=True, widths=useWidth)
          else:
            if(('boxes' in dataobject.Violinstyle) and ('width' in dataobject.Violinstyle['boxes'])):
              useWidth = dataobject.Violinstyle['boxes']['width']
            else:
              useWidth = 0.5
            if(('boxes' in dataobject.Violinstyle) and ('boxFill' in dataobject.Violinstyle['boxes'])):
              useFill = dataobject.Violinstyle['boxes']['boxFill']
            else:
              useFill = False
            # check matplotlib version
            version = matplotlib.__version__.split('.')
            if((len(version) > 1) and ((int(version[0]) > 3) or ((int(version[0]) == 3) and (int(version[1]))))):
              handleViolin = useAxes.boxplot(yvector, positions=xvector, manage_ticks=False, showmeans=True, showfliers=True, sym=None, widths=useWidth, patch_artist=useFill, flierprops={'marker': 'o'})
            else:
              handleViolin = useAxes.boxplot(yvector, positions=xvector, manage_xticks=False, showmeans=True, showfliers=True, sym=None, widths=useWidth, patch_artist=useFill, flierprops={'marker': 'o'})

      # adjust axis limits
      if(rescale):
        if(splitX):
          useModeX, useAxis, useAutoScale = self.modeX_div, 'x2', self.autoScaleX_div
        else:
          useModeX, useAxis, useAutoScale = self.modeX, 'x', self.autoScaleX
        if(useAutoScale):
          if(xerr.size):
            temp_xmin = np.min([i-j for i, j in zip(xval, xerr)])
            temp_xmax = np.max([i+j for i, j in zip(xval, xerr)])
          else:
            temp_xmin = np.min(xval)
            temp_xmax = np.max(xval)
            
          # ensure minimum limit
          if (temp_xmax - temp_xmin < self.EPSILON):
            temp_xmax += self.EPSILON; temp_xmin -= self.EPSILON
          elif(self.data_spacer > 0):
            if(useModeX == 'linear'):
              difference = temp_xmax - temp_xmin
              temp_xmax += difference * self.data_spacer
              temp_xmin -= difference * self.data_spacer
            else:
              # log scale -- isolate positive data
              pos_x = np.array(xval)
              pos_x = pos_x[pos_x > 0]
              # recalc. xmin to address error when restoring state
              if(len(pos_x > 1)):
                temp_xmin, temp_xmax = np.min(pos_x), np.max(pos_x)
                difference = np.log(temp_xmax / temp_xmin)
                temp_xmin = np.exp(np.log(temp_xmin) - self.data_spacer * difference)
                temp_xmax = np.exp(np.log(temp_xmax) + self.data_spacer * difference)
                
          self.setAxisLimits(lower=temp_xmin, upper=temp_xmax, axis=useAxis, updateLabel=True, redraw=False, updateGrid=True)
        
      # determine axis data is plotted on
      if(dataobject.onSecondAxes):
        axis = 'y2'; useMode = self.modeY2; autoCheck = self.autoScaleY2; temp_y = self.y2
      else:
        axis = 'y'; useMode = self.modeY; autoCheck = self.autoScaleY; temp_y = self.y
      # should we ignore the current scale when autozooming?
      if(autoIgnoreCurrentY):
        temp_y = []

      # it is sufficient to do this for main axes as split axes will follow suit
      if((not splitX) and (autoCheck) and (rescale)):
        if(yerr.size):
          temp_y = np.hstack((temp_y, [i - j for i, j in zip(yval, yerr)], [i + j for i, j in zip(yval, yerr)]))
        else:
          temp_y = np.hstack((temp_y, yval))
        temp_ymin, temp_ymax = np.min(temp_y), np.max(temp_y)
          
        # ensure minimum limit
        if (temp_ymax - temp_ymin < self.EPSILON):
          temp_ymax += self.EPSILON; temp_ymin -= self.EPSILON
        elif(self.data_spacer > 0):
          if(useMode == 'linear'):
            difference = temp_ymax - temp_ymin
            temp_ymax += difference * self.data_spacer
            temp_ymin -= difference * self.data_spacer
          else:
            # log scale -- isolate positive data
            pos_y = np.array(yval)
            pos_y = pos_y[pos_y > 0]
            if(len(pos_y > 1)):
              temp_ymin, temp_ymax = np.min(pos_y), np.max(pos_y)
              difference = np.log(temp_ymax / temp_ymin)
              temp_ymin = np.exp(np.log(temp_ymin) - self.data_spacer * difference)
              temp_ymax = np.exp(np.log(temp_ymax) + self.data_spacer * difference)

        self.setAxisLimits(lower=temp_ymin, upper=temp_ymax, axis=axis, updateLabel=True, redraw=False, updateGrid=True)
      
      # apply styles
      style = dataobject.getStyle()
      for key in style:
        method = 'set_' + key
        if (hasattr(handleData, method)):
          method2call = getattr(handleData, method)
          method2call(style[key])
      if(not style['doFill']):
        handleData.set_markerfacecolor('none')
          
      # apply styles to error bars
      if (handleErr != None):
        errorstyle = dataobject.getErrorStyle()
        # Note: handleErr[1] are the caps, handleErr[2] are the lines (super confusing!!)
        for key in errorstyle:
          method = 'set_'+key
          if(key in ['marker', 'markerX']):
            # deal w/ x-errors
            if(xerr.size):
              # we have x errors, those should be the first two entries in handleErr[1]
              offset = 2
              if(key == 'markerX'):
                for entry in handleErr[1][:min(offset, len(handleErr[1]))]:
                  if (hasattr(entry, 'set_marker')):
                    entry.set_marker(errorstyle[key])
            else:
              offset = 0
            # deal w/ y-errors
            if(yerr.size):
              # we have y errors, those should be the first two entries in handleErr[1]
              if(key == 'marker'):
                for entry in handleErr[1][offset:]:
                  if (hasattr(entry, 'set_marker')):
                    entry.set_marker(errorstyle[key])
          else:
            for entry in handleErr[1]:
              if (hasattr(entry, method)):
                method2call = getattr(entry, method)
                method2call(errorstyle[key])
          for entry in handleErr[2]:
            if (hasattr(entry, method)):
              method2call = getattr(entry, method)
              method2call(errorstyle[key])
        # don't connect caps of error bars
        for entry in handleErr[1]:
          entry.set_linestyle('None')
        # check visibility of entire object
        if(not dataobject.visibility):
          if(hasattr(handleErr[0], 'set_visible')):
            handleErr[0].set_visible(False)
          for entry in handleErr[1]:
            if(hasattr(entry, 'set_visible')):
              entry.set_visible(False)
          for entry in handleErr[2]:
            if(hasattr(entry, 'set_visible')):
              entry.set_visible(False)
        # hide caps when error display is only in one direction
        if(dataobject.Errorstyle['direction'] != 'both'):
          if(xerr.size):
            offset = 2
            if(dataobject.Errorstyle['direction'] == 'positive'):
              for entry in handleErr[1][:min(offset - 1, len(handleErr[1]))]:
                entry.set_visible(False)
            elif(dataobject.Errorstyle['direction'] == 'negative'):
              for entry in handleErr[1][1:min(offset, len(handleErr[1]))]:
                entry.set_visible(False)
          else:
            offset = 0
          if(yerr.size):
            if(dataobject.Errorstyle['direction'] == 'positive'):
              for entry in handleErr[1][offset:-1]:
                entry.set_visible(False)
            elif(dataobject.Errorstyle['direction'] == 'negative'):
              for entry in handleErr[1][offset + 1:]:
                entry.set_visible(False)

        # special treatment for fill of error markers
        if(not dataobject.Errorstyle['doFill']):
          for entry in handleErr[1]:
            if(hasattr(entry, 'set_markerfacecolor')):
              entry.set_markerfacecolor('none')
      
      # set name
      if (hasattr(self.handleData, 'set_label')):
        method2call = getattr(self.handleData, 'set_label')
        method2call(dataobject.name)
        
      # apply bar styles
      if(dataobject.Barstyle['showBar']):
        barstyle = dataobject.getBarStyle()
        for entry in handleBar.patches:
          for key in barstyle:
            method = 'set_'+key
            # treat width differently to avoid recentering of bars upon width change (does not heed center position)
            if ((key != 'width') and (hasattr(entry, method))):
              method2call = getattr(entry, method)
              # extra check b/c of hatchMultiply
              if((key == 'hatch') and ('hatchMultiply' in barstyle)):
                method2call(barstyle[key] * barstyle['hatchMultiply'])
              else:
                method2call(barstyle[key])
            # set alternate color?
            if((entry.get_height() < 0) and ('facecolorAlt' in barstyle)):
              entry.set_facecolor(barstyle['facecolorAlt'])
        # check visibility of entire object
        if(not dataobject.visibility):
          for entry in handleBar.patches:
            if(hasattr(entry, 'set_visible')):
              entry.set_visible(False)
 
        # special treatment for fill of bars
        if(not dataobject.Barstyle['doFill']):
          for entry in handleBar.patches:
            if(hasattr(entry, 'set_facecolor')):
              entry.set_facecolor('none')
  
      # apply stack styles
      if(dataobject.Stackstyle['showStack']):
        stackstyle = dataobject.getStackStyle()
        for handle in [handleStack, handleStackNeg]:
          if(handle != None):
            for key in stackstyle:
              method = 'set_'+key
              if (hasattr(handle, method)):
                method2call = getattr(handle, method)
                # extra check b/c of hatchMultiply
                if((key == 'hatch') and ('hatchMultiply' in stackstyle)):
                  method2call(stackstyle[key] * stackstyle['hatchMultiply'])
                else:
                  method2call(stackstyle[key])
            # set alternate color?
            if((handle == handleStackNeg) and ('facecolorAlt' in stackstyle)):
              handle.set_facecolor(stackstyle['facecolorAlt'])
            else:
              handle.set_facecolor(stackstyle['facecolor'])
        # check visibility of entire object
        if(not dataobject.visibility):
          handles = [handleStack, handleStackNeg]
          for entry in handles:
            if(hasattr(entry, 'set_visible')):
              entry.set_visible(False)

        # special treatment for fill of error markers
        if(not dataobject.Stackstyle['doFill']):
          for entry in [handleStack, handleStackNeg]:
            if(hasattr(entry, 'set_facecolor')):
              entry.set_facecolor('none')
 
      # apply text styles
      if(dataobject.Textstyle['showText']):
        textstyle = dataobject.getTextStyle()
        if((handleText != None) and (len(handleText))):
          # apply styles
          for key in textstyle:
            method = 'set_' + key
            if(hasattr(handleText[0], method)):
              value = textstyle[key]; safeFont = 'DejaVu Sans'
              for item in handleText:
                method2call = getattr(item, method)
                method2call(value)
                if(key == 'fontname'):
                  # test last element descent, should be larger than zero
                  _, _, descent = item._get_layout(self.matplot.canvas.renderer)
                  if(not (descent > 0)):
                    self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                    value = safeFont
                    method2call(value)
          # check visibility of entire object
          if(not dataobject.visibility):
            for item in handleText:
              if(hasattr(item, 'set_visible')):
                item.set_visible(False)

      # apply violin styles
      if(dataobject.Violinstyle['mode']):
        violinstyle = dataobject.getViolinStyle()
        if(handleViolin != None):
          # for boxplot ensure that mean has no symbol
          if(dataobject.Violinstyle['mode'] == 2):
            for item in handleViolin['means']:
              item.set_marker('None')
          for entry in handleViolin:
            if(entry in violinstyle):
              if(type(handleViolin[entry]) == type([])):
                # slave cmins to cmaxes and cmedians to cmeans
                if(entry in ['cmaxes', 'cmins']):
                  targetList = handleViolin['cmaxes'] + handleViolin['cmins']
                elif(entry in ['cmeans', 'cmedians']):
                  targetList = handleViolin['cmeans'] + handleViolin['cmedians']
                else:
                  targetList = handleViolin[entry]
                for key in violinstyle[entry]:
                  method, value = 'set_' + key, violinstyle[entry][key]
                  if((key == 'visible') and (entry in ['cmeans', 'cmedians'])):
                    for item in handleViolin[entry]:
                      if(hasattr(item, method)):
                        method2call = getattr(item, method)
                        method2call(value)
                  else:
                    for item in targetList:
                      if(hasattr(item, method)):
                        method2call = getattr(item, method)
                        method2call(value)
                      if(('color' in key) and (len(value) == 4) and (key != 'facecolor')):
                        item.set_alpha(value[-1])
                for item in targetList:
                  if(entry == 'boxes'):
                    additionalZOffset = -0.05
                  else:
                    additionalZOffset = 0
                  if(hasattr(item, 'set_zorder')):
                    item.set_zorder(dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset + additionalZOffset)
                  if(hasattr(item, 'set_pickradius')):
                    item.set_pickradius(PICK_TOLERANCE)
              else:
                # slave cmins to cmaxes and cmedians to cmeans
                if(entry in ['cmaxes', 'cmins']):
                  targetList = ['cmaxes', 'cmins']
                elif(entry in ['cmeans', 'cmedians']):
                  targetList = ['cmeans', 'cmedians']
                else:
                  targetList = [entry]
                for key in violinstyle[entry]:
                  method, value = 'set_' + key, violinstyle[entry][key]
                  if((key == 'visible') and (entry in ['cmeans', 'cmedians', 'cmins', 'cmaxes'])):
                    if(hasattr(handleViolin[entry], method)):
                      method2call = getattr(handleViolin[entry], method)
                      method2call(value)
                  else:
                    for item in targetList:
                      if(hasattr(handleViolin[item], method)):
                        method2call = getattr(handleViolin[item], method)
                        method2call(value)
                      if(('color' in key) and (len(value) == 4) and (key != 'facecolor')):
                        handleViolin[item].set_alpha(value[-1])
                for item in targetList:
                  if(entry == 'boxes'):
                    additionalZOffset = -0.05
                  else:
                    additionalZOffset = 0
                  if(hasattr(handleViolin[item], 'set_zorder')):
                    handleViolin[item].set_zorder(dataobject.zorder + dataobject.relativeZOrderBar + self.parent.zOffset + additionalZOffset)
                  if(hasattr(handleViolin[item], 'set_pickradius')):
                    handleViolin[item].set_pickradius(PICK_TOLERANCE)
      
          # special treatment for fills of various items
          if(('bodies' in handleViolin) and (not dataobject.Violinstyle['bodies']['doFill'])):
            for entry in handleViolin['bodies']:
              if(hasattr(entry, 'set_facecolor')):
                entry.set_facecolor('none')
          if(('fliers' in handleViolin) and (not dataobject.Violinstyle['fliers']['doFill'])):
            for entry in handleViolin['fliers']:
              if(hasattr(entry, 'set_markerfacecolor')):
                entry.set_markerfacecolor('none')
          if(('boxes' in handleViolin) and (not dataobject.Violinstyle['boxes']['boxFill'])):
            for entry in handleViolin['boxes']:
              if(hasattr(entry, 'set_color')):
                entry.set_color(dataobject.Violinstyle['boxes']['edgecolor'])

      # draw everything
      if(redraw):
        self.dataplotwidget.myRefresh()

    # do we need this at all?
    if(1):
      # assign handles
      if(splitX):
        self.handleData_div = handleData
        self.handleErr_div = handleErr
        self.handleErrShady_div = handleErrShady
        self.handleBar_div = handleBar
        self.handleStack_div = handleStack
        self.handleStackNeg_div = handleStackNeg
        self.handleText_div = handleText
        self.handleViolin_div = handleViolin
      else:
        self.handleData = handleData
        self.handleErr = handleErr
        self.handleErrShady = handleErrShady
        self.handleBar = handleBar
        self.handleStack = handleStack
        self.handleStackNeg = handleStackNeg
        self.handleText = handleText
        self.handleViolin = handleViolin
      
    # return handles to graphics objects
    return handleData, handleErr, handleErrShady, handleBar, handleStack, handleStackNeg, handleText, handleViolin
      
  def plotFunction(self, fitobject=None, x=[], handlePlot=None, redraw=True, splitX=False, doAutoZoom=True):
    # was fitobject specified?
    if(fitobject == None):
      fitobject = self.parent.fit[self.parent.activeFit]

    if(splitX):
      # retrieve plot handle
      self.handlePlot_div = handlePlot
      
      # determine which axes to draw on
      if(fitobject.onSecondAxes):
        useAxes = self.ax2_div
      else:
        useAxes = self.ax_div
    else:
      # retrieve plot handle
      self.handlePlot = handlePlot
      
      # determine which axes to draw on
      if(fitobject.onSecondAxes):
        useAxes = self.ax2
      else:
        useAxes = self.ax

    # retrieve restriction information
    restrictMe, restrictLow, restrictHigh = fitobject.getRestricted()
    restrictLow, restrictHigh = np.min((restrictLow, restrictHigh)), np.max((restrictLow, restrictHigh))
    
    # was target plot interval specified?
    if(splitX):
      if (len(x)):
        self.x_div = np.array(x)
      else:
        # determine x interval of plot
        xmin, xmax = self.minX_div, self.maxX_div
        if(restrictMe):
          if(xmin < xmax):
            xmin, xmax = np.max((xmin, restrictLow)), np.min((xmax, restrictHigh))
          else:
            xmax, xmin = np.max((xmax, restrictLow)), np.min((xmin, restrictHigh))
        if(self.modeX_div == 'linear'):
          self.x_div = np.linspace(xmin, xmax, self.DATAPOINTS_SIMULATION)
        elif(self.modeX_div == 'log'):
          self.x_div = np.linspace(np.log(xmin), np.log(xmax), self.DATAPOINTS_SIMULATION)
          self.x_div = np.exp(self.x_div)
      x = self.x_div

      # calculate function values
      self.x_div, funcY = fitobject.simulateFunc(self.x_div, splitX=True)
      if(fitobject.onSecondAxes):
        self.y_div, self.y2_div = np.array([]), funcY
      else:
        self.y_div, self.y2_div = funcY, np.array([])

      # can do some plotting
      if((self.handlePlot_div != None) and (self.handlePlot_div.axes == useAxes)):
        self.handlePlot_div.set_xdata(self.x_div)
        self.handlePlot_div.set_ydata(funcY)
      else:
        if((self.handlePlot_div != None) and (self.handlePlot_div.axes != useAxes)):
          self.handlePlot_div.remove()
        self.handlePlot_div, = useAxes.plot(self.x_div, funcY, zorder = fitobject.zorder + self.parent.zOffset)
      handlePlot = self.handlePlot_div
    else:
      if (len(x)):
        self.x = np.array(x)
      else:
        # determine x interval of plot
        xmin, xmax = self.minX, self.maxX
        if(restrictMe):
          if(xmin < xmax):
            xmin, xmax = np.max((xmin, restrictLow)), np.min((xmax, restrictHigh))
          else:
            xmax, xmin = np.max((xmax, restrictLow)), np.min((xmin, restrictHigh))
        if(self.modeX == 'linear'):
          self.x = np.linspace(xmin, xmax, self.DATAPOINTS_SIMULATION)
        elif(self.modeX == 'log'):
          self.x = np.linspace(np.log(xmin), np.log(xmax), self.DATAPOINTS_SIMULATION)
          self.x = np.exp(self.x)
      x = self.x
    
      # calculate function values
      self.x, funcY = fitobject.simulateFunc(self.x)
      if(fitobject.onSecondAxes):
        self.y, self.y2 = np.array([]), funcY
      else:
        self.y, self.y2 = funcY, np.array([])

      # can do some plotting
      if((self.handlePlot != None) and (self.handlePlot.axes == useAxes)):
        self.handlePlot.set_xdata(self.x)
        self.handlePlot.set_ydata(funcY)
      else:
        if((self.handlePlot != None) and (self.handlePlot.axes != useAxes)):
          self.handlePlot.remove()
        self.handlePlot, = useAxes.plot(self.x, funcY, zorder = fitobject.zorder + self.parent.zOffset)
      handlePlot = self.handlePlot
      self.handlePlot.set_pickradius(PICK_TOLERANCE)
  
      # determine axis data is plotted on
      if(fitobject.onSecondAxes):
        axis = 'y2'; useMode = self.modeY2; autoCheck = self.autoScaleY2
      else:
        axis = 'y'; useMode = self.modeY; autoCheck = self.autoScaleY

      # adjust y limits
      if(autoCheck and doAutoZoom):
        # check if data is loaded
        if(('y' in self.parent.data[self.parent.activeData].value()) and (fitobject.onSecondAxes == self.parent.data[self.parent.activeData].onSecondAxes)):
          temp_data = self.parent.data[self.parent.activeData].value()
          if(('yerr' in temp_data) and (len(temp_data['yerr']))):
            temp_data1 = [i - j for i, j in zip(temp_data['y'], temp_data['yerr'])]
            temp_data2 = [i + j for i, j in zip(temp_data['y'], temp_data['yerr'])]
            temp_y = np.hstack((funcY, temp_data1, temp_data2))
          else:
            temp_y = np.hstack((funcY, temp_data['y']))
        else:
          temp_y = funcY
  
        temp_y = temp_y[np.isfinite(temp_y)]
        # check to account for inf/nan only curves
        if(len(temp_y)):
          temp_ymin = np.min(temp_y)
          temp_ymax = np.max(temp_y)
            
          if(temp_ymax-temp_ymin<self.EPSILON):
            temp_ymax += self.EPSILON; temp_ymin -= self.EPSILON
          elif(self.data_spacer > 0):
            if(useMode == 'linear'):
              difference = temp_ymax - temp_ymin
              temp_ymax += difference * self.data_spacer
              temp_ymin -= difference * self.data_spacer
            else:
              # log scale -- isolate positive data
              pos_y = np.array(temp_y)
              pos_y = pos_y[pos_y > 0]
              if(len(pos_y > 1)):
                #difference = np.log(pos_y[-1] / pos_y[0])
                temp_ymin, temp_ymax = np.min(pos_y), np.max(pos_y)
                difference = np.log(temp_ymax / temp_ymin)
                temp_ymin = np.exp(np.log(temp_ymin) - self.data_spacer * difference)
                temp_ymax = np.exp(np.log(temp_ymax) + self.data_spacer * difference)
        else:
          if(fitobject.onSecondAxes):
            temp_ymin, temp_ymax = self.minY2, self.maxY2
          else:
            temp_ymin, temp_ymax = self.minY, self.maxY
  
        self.setAxisLimits(lower=temp_ymin, upper=temp_ymax, axis=axis, updateLabel=True, redraw=False, updateGrid=True)
    
    # apply styles
    style = fitobject.getStyle()
    for key in style:
      method = 'set_' + key
      if (hasattr(handlePlot, method)):
        method2call = getattr(handlePlot, method)
        method2call(style[key])
    if(not style['doFill']):
      if(hasattr(handlePlot, 'set_markerfacecolor')):
        handlePlot.set_markerfacecolor('none')
      
    # set name
    if (hasattr(handlePlot, 'set_label')):
      method2call = getattr(handlePlot, 'set_label')
      method2call(fitobject.name)

    # and finally draw everything
    if(redraw):
      self.dataplotwidget.myRefresh()

    # return handles to graphics
    return handlePlot

class BruteWindow(QtWidgets.QMainWindow):
  def __init__(self, parent=None, title=' '):
    super(BruteWindow, self).__init__()
    self.parent = parent
    self.title = title
    self.setWindowTitle(self.title)
    
    self.centralwidget = QWidgetMac(self)
    self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(250), scaledDPI(100)))
    self.centralwidget.setMaximumSize(QtCore.QSize(scaledDPI(250), scaledDPI(100)))
    self.setCentralWidget(self.centralwidget)
    
    self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
    self.vLayout.setAlignment(QtCore.Qt.AlignCenter|QtCore.Qt.AlignTop)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    self.messageLabel = QtWidgets.QLabel()
    self.vLayout.addWidget(self.messageLabel)

    self.messageLabel2 = QtWidgets.QLabel()
    self.vLayout.addWidget(self.messageLabel2)

    self.messageLabel3 = QtWidgets.QLabel()
    self.vLayout.addWidget(self.messageLabel3)

    self.messageLabel4 = QtWidgets.QLabel()
    self.vLayout.addWidget(self.messageLabel4)

    self.closeButton = QPushButtonMac()
    self.closeButton.setText('Stop')
    self.closeButton.clicked.connect(self.close)
    self.vLayout.addWidget(self.closeButton)
    
  def closeEvent(self,event):
    # stop fit procedure in parent window
    self.parent.runFlag = False

class MinWindow(QtWidgets.QMainWindow):
  def __init__(self, parent=None, title=' '):
    super(MinWindow, self).__init__()
    self.parent = parent
    self.title = title
    self.setWindowTitle(self.title)
    
    self.centralwidget = QWidgetMac(self)
    self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(250), scaledDPI(90)))
    self.centralwidget.setMaximumSize(QtCore.QSize(scaledDPI(250), scaledDPI(90)))
    self.setCentralWidget(self.centralwidget)
    
    self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
    self.vLayout.setAlignment(QtCore.Qt.AlignCenter|QtCore.Qt.AlignTop)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    self.messageLabel = QtWidgets.QLabel(self.title)
    self.vLayout.addWidget(self.messageLabel)

    self.iterLabel = QtWidgets.QLabel()
    self.vLayout.addWidget(self.iterLabel)

    self.minLabel = QtWidgets.QLabel()
    self.vLayout.addWidget(self.minLabel)

    self.closeButton = QPushButtonMac()
    self.closeButton.setText('Stop')
    self.closeButton.clicked.connect(self.close)
    self.vLayout.addWidget(self.closeButton)
    
  def closeEvent(self,event):
    # stop fit procedure in parent window
    self.parent.runFlag = False
    self.parent.daughterWindow = None

# a custom QTextEdit
class myQTextEdit(QtWidgets.QTextEdit):
  def __init__(self, parent = None):
    super(myQTextEdit, self).__init__(parent)
    self._originalFocusInEvent = QtWidgets.QTextEdit.focusInEvent
    self.parent = parent
    # for some reason need to explicitly set QSTYLE again -- could be due to nested widgets?! unclear
    if(QSTYLE != None):
      self.setStyle(QSTYLE)

  def focusInEvent(self, event):
    self._originalFocusInEvent(self, event)
    # don't use palettes as these are incompatible with style sheets
    self.setStyleSheet('myQTextEdit {background-color: white;}')
    
  def keyPressEvent(self, event):
    if event.matches(QtGui.QKeySequence.Save):
      if(self.parent != None):
        self.parent.saveFit()
    elif(event.matches(QtGui.QKeySequence.Open) or event.matches(QtGui.QKeySequence.HelpContents)\
      or event.matches(QtGui.QKeySequence.Print) or event.matches(QtGui.QKeySequence.Quit) or event.matches(QtGui.QKeySequence.Italic)\
      or event.matches(QtGui.QKeySequence.ZoomIn) or event.matches(QtGui.QKeySequence.ZoomOut) or event.matches(QtGui.QKeySequence.Find)\
      or event.matches(QtGui.QKeySequence.New) or event.matches(QtGui.QKeySequence.Refresh) or event.matches(QtGui.QKeySequence.FindNext)):
      # pass through event
      event.ignore()
    else:
      QtWidgets.QTextEdit.keyPressEvent(self, event)
      # prevent event from triggering main ui as well
      event.accept()

class GlobalArea(QWidgetMac):
  def __init__(self, parent=None):
    super(GlobalArea, self).__init__()
    self.parent = parent
    self.validFloat = MyValidFloat()
    self.globalParamsCollate = {}
    self.globalParam_active = []
    self.globalParamNames = []
    self.globalParamValues = []
    self.globalConfidence = []
    self.globalConfidence_apriori = []
    self.chisquare, self.red_chisquare = 0, 0
    self.storeGlobalParam = []
    self.fitGlobalResultsHeader = 'Latest global fit results:'
    self.fitGlobalResultsHeader += '\n' + '-' * len(self.fitGlobalResultsHeader) + '\n'
    self.globalOutstring = self.fitGlobalResultsHeader
    
    # use epsilon as minimum error value and for calculating derivatives
    self.EPSILON = 1e-9
    # define amplitude threshold for random variation of parameters
    self.MIN_AMPLITUDE = 0.5

    # advanced export settings
    self.advancedMinimization = {'algorithm': 'Nelder-Mead', 'xtol': 1e-8, 'maxfev': 1e5}
    self.advancedRandomSearch = {'cycles': 5, 'escalate': 1.5, 'maxfev': 1e4}

    # locally import numpy again
    import numpy as np
    # import common functions from numpy for ease of access (and for consistency with local fitting)
    from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh
    self.mySpace = locals()

    # set up GUI
    self.buildRessource()

  def buildRessource(self):
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)

    # specify data sets and associated curves
    self.dataSetContainer = QWidgetMac()
    self.vLayout.addWidget(self.dataSetContainer, stretch=4)
    self.LayoutDataSetContainer = QtWidgets.QVBoxLayout(self.dataSetContainer)
    self.LayoutDataSetContainer.setContentsMargins(0, 0, 0, 0)

    self.dataSetLabel = QtWidgets.QLabel()
    useFont = self.dataSetLabel.font()
    useFont.setBold(True)
    self.dataSetLabel.setFont(useFont)
    self.dataSetLabel.setText('Data sets and curves')
    self.LayoutDataSetContainer.addWidget(self.dataSetLabel)

    self.dataSetTable = QtWidgets.QTableWidget()
    self.dataSetTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.dataSetTable.setEnabled(True)
    self.dataSetTable.setColumnCount(4)
    self.dataSetTable.setRowCount(1)
    self.dataSetTable.setHorizontalHeaderItem(0, QtWidgets.QTableWidgetItem('Use?'))
    self.dataSetTable.setHorizontalHeaderItem(1, QtWidgets.QTableWidgetItem('Item'))
    self.dataSetTable.setHorizontalHeaderItem(2, QtWidgets.QTableWidgetItem('Curve'))
    self.dataSetTable.setHorizontalHeaderItem(3, QtWidgets.QTableWidgetItem('Params'))
    self.LayoutDataSetContainer.addWidget(self.dataSetTable)

    blah = self.HLine()
    self.LayoutDataSetContainer.addWidget(blah)
    
    # global parameter table
    self.parameterTableContainer = QWidgetMac()
    self.vLayout.addWidget(self.parameterTableContainer, stretch=4)
    self.LayoutParameterTableContainer = QtWidgets.QVBoxLayout(self.parameterTableContainer)
    self.LayoutParameterTableContainer.setContentsMargins(0, 0, 0, 0)

    self.parameterLabelContainer = QWidgetMac()
    self.LayoutParameterTableContainer.addWidget(self.parameterLabelContainer)
    self.LayoutParameterLabelContainer = QtWidgets.QHBoxLayout(self.parameterLabelContainer)
    self.LayoutParameterLabelContainer.setContentsMargins(0, 0, 0, 0)

    self.parameterLabel = QtWidgets.QLabel()
    useFont = self.parameterLabel.font()
    useFont.setBold(True)
    self.parameterLabel.setFont(useFont)
    self.parameterLabel.setText('Parameters Local /')
    self.LayoutParameterLabelContainer.addWidget(self.parameterLabel)
    self.parameterLabel2 = QtWidgets.QLabel()
    useFont = self.parameterLabel2.font()
    useFont.setBold(True)
    self.parameterLabel2.setFont(useFont)
    self.parameterLabel2.setText('Global')
    self.parameterLabel2.setStyleSheet('color: blue;')
    self.LayoutParameterLabelContainer.addWidget(self.parameterLabel2)
    self.LayoutParameterLabelContainer.addStretch()

    self.globalParamTable = QtWidgets.QTableWidget()
    self.globalParamTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.globalParamTable.setEnabled(True)
    self.globalParamTable.setColumnCount(4)
    self.globalParamTable.setRowCount(1)
    self.globalParamTable.setHorizontalHeaderItem(0, QtWidgets.QTableWidgetItem('Fit?'))
    self.globalParamTable.setHorizontalHeaderItem(1, QtWidgets.QTableWidgetItem('Value'))
    self.globalParamTable.setHorizontalHeaderItem(2, QtWidgets.QTableWidgetItem('Error'))
    item3 = QtWidgets.QTableWidgetItem('a priori')
    useFont = item3.font()
    useFont.setItalic(True)
    item3.setFont(useFont)
    self.globalParamTable.setHorizontalHeaderItem(3, item3)
    self.LayoutParameterTableContainer.addWidget(self.globalParamTable)

    # set fit controls
    self.ButtonContainer = QWidgetMac()
    self.LayoutParameterTableContainer.addWidget(self.ButtonContainer)
    self.LayoutButtonContainer = QtWidgets.QHBoxLayout(self.ButtonContainer)
    self.LayoutButtonContainer.setContentsMargins(0, 0, 0, 0)

    # set up Fit button
    self.doGlobalFitButton = QPushButtonMac()
    self.doGlobalFitButton.setText('Global Fit')
    self.doGlobalFitButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalFitButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalFitButton.clicked.connect(self.doGlobalFit)
    self.LayoutButtonContainer.addWidget(self.doGlobalFitButton)

    # set up minimize button
    self.doGlobalMinButton = QPushButtonMac()
    self.doGlobalMinButton.setText('Global ' + self.advancedMinimization['algorithm'] + ' Min.')
    self.doGlobalMinButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalMinButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalMinButton.clicked.connect(self.doGlobalMin)
    self.LayoutButtonContainer.addWidget(self.doGlobalMinButton)

    # set up random fit button
    self.doGlobalBruteButton = QPushButtonMac()
    self.doGlobalBruteButton.setText('Random Search')
    self.doGlobalBruteButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalBruteButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doGlobalBruteButton.clicked.connect(self.doBruteGlobalFit)
    self.LayoutButtonContainer.addWidget(self.doGlobalBruteButton)

    # set up Reset button
    self.resetGlobalButton = QPushButtonMac()
    self.resetGlobalButton.setText('Reset Parameters')
    self.resetGlobalButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.resetGlobalButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.resetGlobalButton.clicked.connect(self.resetGlobalParam)
    self.LayoutButtonContainer.addWidget(self.resetGlobalButton)

    # global fit results
    self.globalFitResultsContainer = QWidgetMac()
    self.vLayout.addWidget(self.globalFitResultsContainer, stretch=2)
    self.LayoutGlobalFitResultsContainer = QtWidgets.QVBoxLayout(self.globalFitResultsContainer)
    self.LayoutGlobalFitResultsContainer.setContentsMargins(0, 0, 0, 0)
    
    # set up text edit field for displaying fit results
    blah = self.HLine()
    self.LayoutGlobalFitResultsContainer.addWidget(blah)
    self.globalFitResults = QtWidgets.QTextEdit()
    self.globalFitResults.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
    self.globalFitResults.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(600)))
    self.LayoutGlobalFitResultsContainer.addWidget(self.globalFitResults)
    self.globalFitResults.setReadOnly(True)
    self.globalFitResults.setText(self.fitGlobalResultsHeader)

    # update
    self.updateDataSetTable()

  def updateBruteGlobalParam(self, culledDataSets=[], nop=[], updateResid=False):
    # update global fit parameters once found better resid
    counter = 0
    for index, entry in enumerate(self.globalParam_active):
      if (entry == 1):
        self.globalParamValues[index] = self.globalParam_active_list[counter]
        counter += 1

    # update parameter tables
    self.updateGlobalParamTable(fitted=True)
    # update parameter table for current curve
    self.parent.fitarea.changeParamTable()

    # update individual curves
    selectedDataSets = [index for index, entry in enumerate(self.parent.data) if entry.globalFitCheck]
    selectedCurves = [self.parent.data[index].globalFitCurve for index in selectedDataSets]
    selectedCurves = list(set(selectedCurves))
    for index in selectedCurves:
      # update params as needed
      paramUpdateNames, paramUpdateValues = [], []
      for entry in self.parent.fit[index].paramNames:
        if(entry in self.globalParamNames):
          paramUpdateNames.append(entry)
          paramUpdateValues.append(self.globalParamValues[self.globalParamNames.index(entry)])
      self.parent.fit[index].updateParamSelect(paramUpdateNames, paramUpdateValues)

      if(index != self.parent.activeFit):
        self.updateNonActiveCurve(index)        
      # plot function
      self.parent.fit[index].handlePlot = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot, redraw=False)
      self.parent.fit[index].handlePlot_div = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot_div, redraw=False, splitX=True)

    # update residuals in data sets
    if(updateResid):
      for index, dataSetNumber in enumerate(culledDataSets):
        if(not index):
          self.parent.data[dataSetNumber].setFval(self.globalFval[:nop[index]])
        elif(index < len(culledDataSets) - 1):
          self.parent.data[dataSetNumber].setFval(self.globalFval[sum(nop[:index]):sum(nop[:index + 1])])
        else:
          self.parent.data[dataSetNumber].setFval(self.globalFval[sum(nop[:index]):])
  
        # do the actual plot
        curveIndex = self.parent.data[index].globalFitCurve
        # generate resid style on the fly
        self.parent.data[index].Residstyle.update(self.parent.data[index].style)
        self.parent.data[index].ResidBarstyle.update(self.parent.data[index].Barstyle)
        self.parent.data[index].ResidStackstyle.update(self.parent.data[index].Stackstyle)
        self.parent.data[index].ResidTextstyle.update(self.parent.data[index].Textstyle)
        for item in ['linewidth', 'linestyle', 'color']:
          self.parent.data[index].ResidLinestyle[item] = deepcopy(self.parent.fit[curveIndex].style[item])
        # ensure line is visible to connect dots
        if(self.parent.data[index].Residstyle['linestyle'] == 'None'):
          self.parent.data[index].Residstyle['linestyle'] = 'solid'
        # plot residuals
        self.parent.data[index].handleResid, self.parent.plotArea.handleResidZero,\
          self.parent.data[index].handleResidBar, self.parent.data[index].handleResidStack, self.parent.data[index].handleResidStackNeg, self.parent.data[index].handleResidText = self.parent.plotArea.plotResid(\
          dataobject = self.parent.data[index], handleResid = self.parent.data[index].handleResid,\
          handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[index].handleResidBar,\
          handleResidStack = self.parent.data[index].handleResidStack, handleResidStackNeg = self.parent.data[index].handleResidStackNeg,\
          handleResidText = self.parent.data[index].handleResidText, redraw=False)
        self.parent.data[index].handleResid_div, self.parent.plotArea.handleResidZero_div,\
          self.parent.data[index].handleResidBar_div, self.parent.data[index].handleResidStack_div, self.parent.data[index].handleResidStackNeg_div, self.parent.data[index].handleResidText_div = self.parent.plotArea.plotResid(\
          dataobject = self.parent.data[index], handleResid = self.parent.data[index].handleResid_div,\
          handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[index].handleResidBar_div,\
          handleResidStack = self.parent.data[index].handleResidStack_div, handleResidStackNeg = self.parent.data[index].handleResidStackNeg_div,\
          handleResidText = self.parent.data[index].handleResidText_div, redraw=False, splitX=True)

      # issue plot updates
      self.parent.plotArea.residplotwidget.myRefresh()

    # issue plot updates
    self.parent.plotArea.dataplotwidget.myRefresh()

  def getGlobalRelativeDerivatives(self):
    # determine derivatives of fit parameters
    # define helper function to calc. square deviations
    def XX_monster_minWrapper(globalParam):#, x, globalY, globalYerr):
      self.globalFval = self.XX__monster_Ffunc_(self.globalX, *globalParam)
      globalResid = (self.globalY - self.globalFval) / self.globalYerr
      globalResid = globalResid ** 2
      self.currGlobalResid = np.sum(globalResid)
      return self.currGlobalResid
        
    # probe sensitivity of parameters
    globalParam = [i for i in self.globalParam_active_list]
    self.globalStartVal = self.XX__monster_Ffunc_(self.globalX, *globalParam)
    self.globalStartResid = XX_monster_minWrapper(globalParam)

    # cycle through parameters and calc. derivatives
    for index, entry in enumerate(self.globalParam_active_list):
      globalWorkParam = [i for i in self.globalParam_active_list]
      globalWorkParam[index] *= (1.0 + self.EPSILON)
      globalPerturbResid = XX_monster_minWrapper(globalWorkParam)
      # calc. change in chi square when varying a certain parameter
      self.globalDerivatives[index] = (globalPerturbResid - self.globalStartResid)

    # now also assign amplitudes for random parameter variation
    self.globalRandomAmplitudes = np.array([1.0/i if i != 0 else 0 for i in self.globalDerivatives])
          
    # calc. relative amplitudes
    divisor = np.max(np.abs(self.globalRandomAmplitudes))
    divisor = np.max((divisor, self.EPSILON))
    self.globalRandomAmplitudes = self.globalRandomAmplitudes / divisor / 2.0

  def doBruteGlobalFit(self):
    if(self.doGlobalHelper(modus='random search')):
      # and we are ready to gogog!
      self.globalParam_active_list = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
      self.globalOrigParam = [i for i in self.globalParam_active_list]
      self.daughterWindow = None
      self.runFlag = True
      try:
        # define helper function to calc. square deviations
        def XX_monster_minWrapper(globalParam):#, x, globalY, globalYerr):
          self.globalFval = self.XX__monster_Ffunc_(self.globalX, *globalParam)
          globalResid = (self.globalY - self.globalFval) / self.globalYerr
          globalResid = globalResid ** 2
          self.currGlobalResid = np.sum(globalResid)
          return self.currGlobalResid
        
        # open an extra window to interact with procedure
        self.daughterWindow = BruteWindow(self, 'Global Random Search')
        # apply styles to popup window
        if(QSTYLE != None):
          self.daughterWindow.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          self.daughterWindow.setStyleSheet(QSTYLESHEET)
        self.daughterWindow.show()
  
        # now do the minimization
        # cycle until daughter window closed
        movingCursor = '|,/,-,\\'.split(',')
        cursorCount = 0
        repeatCycleLimit, escalate, lastSuccessLimit = self.advancedRandomSearch['cycles'],\
          self.advancedRandomSearch['escalate'], self.advancedRandomSearch['maxfev']
        escalate = [escalate ** i for i in range(repeatCycleLimit)]
        residstr = ''
        for repeatCycleCount in range(repeatCycleLimit):
          # update message label
          self.daughterWindow.messageLabel.setText('Repeat cycle ' + str(repeatCycleCount + 1) + '/' + str(repeatCycleLimit))
          
          # parameter derivatives
          self.globalDerivatives = np.zeros(len(self.globalParam_active_list))
          self.getGlobalRelativeDerivatives()
          self.daughterWindow.messageLabel2.setText('resid ' + self.parent.formatNumber(self.globalStartResid) + residstr)
        
          lastSuccessCount = 0
          while ((lastSuccessCount < lastSuccessLimit) and (self.runFlag)):
            # randomly vary parameters
            for trial in range(100):
              lastSuccessCount += 1
              # randomly vary parameters -- add epsilon to get rid of zero parameters
              globalWorkamplitude = [i if (np.abs(i) > self.MIN_AMPLITUDE) else (np.sign(i + 1.1 * self.EPSILON) * self.MIN_AMPLITUDE) for i in self.globalParam_active_list]
              globalWorkamplitude = escalate[repeatCycleCount] * np.array(globalWorkamplitude)
              
              globalWorkParam = self.globalParam_active_list  + (globalWorkamplitude * (0.33 - np.random.random(len(self.globalParam_active_list))))
              globalPerturbResid = XX_monster_minWrapper(globalWorkParam)
              
              if(globalPerturbResid < self.globalStartResid):
                # improvement, yeah!
                # update params
                self.globalParam_active_list = [i for i in globalWorkParam]
                self.updateBruteGlobalParam(self.culledDataSets, self.nop, updateResid=False)
                # prepare new round of random search
                self.getGlobalRelativeDerivatives()
                self.daughterWindow.messageLabel2.setText('resid ' + self.parent.formatNumber(self.globalStartResid) + residstr)
                lastSuccessCount = 0
                self.daughterWindow.messageLabel3.setText('Func eval: ' + str(int(np.min((lastSuccessCount,\
                  lastSuccessLimit)))) + '/' + str(int(lastSuccessLimit)))
            
            # periodically update label in daughter window
            cursorCount += 1
            if(cursorCount >= len(movingCursor)):
              cursorCount = 0
            self.daughterWindow.messageLabel3.setText('Func eval: ' + str(int(np.min((lastSuccessCount,\
              lastSuccessLimit)))) + '/' + str(int(lastSuccessLimit)))
            self.daughterWindow.messageLabel4.setText('Working ' + movingCursor[cursorCount])
            # need to still process events
            QtCore.QCoreApplication.processEvents()

          if((repeatCycleCount == 0) or (self.globalStartResid < self.globalBestResid)):
            # first cycle or improvement
            self.globalBestParam = [i for i in self.globalParam_active_list]
            self.globalBestVal = 1.0 * self.globalStartVal
            self.globalBestResid = 1.0 * self.globalStartResid
            residstr = '; best ' + self.parent.formatNumber(self.globalBestResid)

          # reset original parameters for next cycle
          self.globalParam_active_list = [i for i in self.globalOrigParam]
        # finished
        success = True
      except:
        self.parent.statusbar.showMessage('Encountered some problem when conducting random search!', self.parent.STATUS_TIME)
        if(self.daughterWindow != None):
          self.daughterWindow.close()
          self.daughterWindow = None
        success = False
        return False

      if(success):
        # finished all repeat cycles
        self.daughterWindow.close()
        self.daughterWindow = None
        
        # restore best results from previous cycle
        if(repeatCycleCount > 0):
          self.globalParam_active_list = [i for i in self.globalBestParam]
        
        # calc. residuals even if no improvement
        globalPerturbResid = XX_monster_minWrapper(self.globalBestParam)
        # after procedure, set new parameters and update curve
        self.updateBruteGlobalParam(self.culledDataSets, self.nop, updateResid=True)
        # success
        return True

  def doGlobalHelper(self, modus=''):
    # combines preparatory calls needed by both global minimization and random search
    # determine number of selected data sets
    selectedDataSets = [index for index, entry in enumerate(self.parent.data) if entry.globalFitCheck]
    if(len(selectedDataSets) < 2):
      self.parent.statusbar.showMessage('Select at least two datasets for global ' + modus + '!', self.parent.STATUS_TIME)
    elif(sum([1 if i else 0 for i in self.globalParam_active]) == 0):
      self.parent.statusbar.showMessage('Select at least one parameter for global ' + modus + '!', self.parent.STATUS_TIME)
    else:
      # check for no. of global parameters and display warning if equals zero
      noGlobalParams = True
      for index, entry in enumerate(self.globalParamNames):
        if(len(self.globalParamsCollate[entry]) > 1):
          noGlobalParams = False
      if(noGlobalParams):
        self.parent.statusbar.showMessage('No global parameters found! Will minimize but there is no gain by global minimization.', self.parent.STATUS_TIME, color='blue')

      # collate and organize data
      self.culledDataSets = []
      checkYerr = False
      self.globalX, self.globalY, self.globalYerr, self.nop = [], [], [], []
      globalYSecond = []
      for index in selectedDataSets:
        # read and organize data
        indivData, indivRoles = self.parent.data[index].getData_n_Fit()
        currDataOnSecond = self.parent.data[index].onSecondAxes
        if(('x' in indivRoles) and ('y' in indivRoles)):
          self.culledDataSets.append(index)
          colX, colY = indivRoles.index('x'), indivRoles.index('y')
          # get y errors
          if('yerr' in indivRoles):
            colYerr = indivRoles.index('yerr')
          else:
            colYerr = -1
            checkYerr = True
          for line in indivData:
            self.globalX.append(line[colX])
            self.globalY.append(line[colY])
            if(colYerr + 1):
              self.globalYerr.append(line[colYerr])
            else:
              self.globalYerr.append(1)
            globalYSecond.append(currDataOnSecond)
          # count data points
          self.nop.append(len(indivData))
      
      if(checkYerr):
        self.parent.statusbar.showMessage('Warning -- y error missing in certain data sets => set to 1', self.parent.STATUS_TIME, color='blue')

      # replace zero entries by self.EPSILON
      self.globalX, self.globalY, self.globalYerr = np.array(self.globalX), np.array(self.globalY), np.array(self.globalYerr)
      zerosigma = self.globalYerr[self.globalYerr <= 0]
      if(len(zerosigma) > 0):
        self.parent.statusbar.showMessage('Encountered zero/negative sigma values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
        self.globalYerr = np.array([i if(i>0) else self.EPSILON for i in self.globalYerr])
      
      # determine curves to use
      selectedCurves = [self.parent.data[index].globalFitCurve for index in self.culledDataSets]
      selectedCurves = list(set(selectedCurves))
      
      # cycle over all and define the individual fits in the current scope
      noProblem = self.functionInScope(selectedCurves)
      
      # only proceed if success with setting individual fit functions
      if(noProblem):
        # prepare the monster fit function
        globalFitFunc = 'def XX__monster_Ffunc_(self, x, '
        freeParam = [i for i, j in zip(self.globalParamNames, self.globalParam_active) if j]
        globalFitFunc += ', '.join(freeParam) + '):\n'
        globalFitFunc += '\t# fixed parameters\n'
        for index, entry in enumerate(self.globalParamNames):
          if(not(self.globalParam_active[index])):
            globalFitFunc += '\t' + entry + ' = ' + str(self.globalParamValues[index]) + '\n'
  
        # now call individual fit functions
        globalFitFunc += '\n\t# now call functions for individual curves'
        globalFitFunc += '\n\t__globalFval_ = np.array([])\n'
        for index, dataSetNumber in enumerate(self.culledDataSets):
          # localX
          if(not index):
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[:' + str(self.nop[index]) + ']'
          elif(index < len(self.culledDataSets) - 1):
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[' + str(sum(self.nop[:index])) + ':' + str(sum(self.nop[:index + 1])) + ']'
          else:
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[' + str(sum(self.nop[:index])) + ':]'
          # call function w/ localX
          useCurve = self.parent.data[dataSetNumber].globalFitCurve
          globalFitFunc += '\n\t__localFval_' + str(dataSetNumber) + ' = self.__globFfunc_' + str(useCurve) + '(__localX_' + str(dataSetNumber) + ', '
          globalFitFunc += ', '.join(self.parent.fit[useCurve].paramNames) + ')'
          # and np-stack results
          globalFitFunc += '\n\t__globalFval_ = np.hstack((__globalFval_, __localFval_' + str(dataSetNumber) + '))\n'
          
        # and wrap up the monster fit function
        globalFitFunc += '\n\treturn __globalFval_\n'
  
        # now test the monster fit function
        try:
          # generate ffunc in global namespace (this is needed for Python3 vs. Python2, bummer)
          namespace = self.mySpace
          exec(globalFitFunc, namespace)
          # we need to do some initial test to see whether the function can be called
          initpa = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
          retv = namespace['XX__monster_Ffunc_'](self, self.globalX, *initpa)
          # check for dimension mismatch
          if(retv.shape != self.globalX.shape):
            # we found some mismatch b/w x and y -- raise error to prevent program crash
            raise ValueError
        except:
          self.parent.statusbar.showMessage('Error collating global fit -- please check individual fit functions separately!', self.parent.STATUS_TIME)
        else:
          # now define the new function in the object scope
          setattr(GlobalArea, 'XX__monster_Ffunc_', namespace['XX__monster_Ffunc_'])
          return True
        # some kind of error
        return False
          
  def doGlobalMin(self):
    if(self.doGlobalHelper(modus='minimization')):
      # and we are ready to gogog!
      initpa = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
      self.fitpa = [i for i in initpa]
      xtol, maxfev = self.advancedMinimization['xtol'], self.advancedMinimization['maxfev']
      self.fev, self.currGlobalResid = 0, 0
      self.globalFval = 0 * self.globalX
      success = False
      self.daughterWindow = None
      self.runFlag = True
      try:
        # define callback and wrapper functions
        def minimizeCallback(args=0):
          self.fev += 1
          self.fitpa = args
          if((self.fev > maxfev) or (not self.runFlag)):
            # have to raise a warning to terminate
            raise ValueError('exceeded')
          # process events once in a while
          if(not (self.fev % 100)):
            if(self.daughterWindow != None):
              self.daughterWindow.iterLabel.setText('iter ' + str(int(self.fev)) + ' / ' + str(int(maxfev)))
              self.daughterWindow.minLabel.setText('resid ' + self.formatNumber(self.currGlobalResid))
            QtCore.QCoreApplication.processEvents()
      
        # generate wrapper function to calculate square deviation
        def XX_monster_minWrapper(globalParam):#, x, globalY, globalYerr):
          self.globalFval = self.XX__monster_Ffunc_(self.globalX, *globalParam)
          globalResid = (self.globalY - self.globalFval) / self.globalYerr
          globalResid = globalResid ** 2
          self.currGlobalResid = np.sum(globalResid)
          return self.currGlobalResid
        
        # open an extra window to interact with procedure
        self.daughterWindow = MinWindow(self, 'Global ' + self.advancedMinimization['algorithm'] + ' Minimization')
        # apply styles to popup window
        if(QSTYLE != None):
          self.daughterWindow.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          self.daughterWindow.setStyleSheet(QSTYLESHEET)
        self.daughterWindow.show()
  
        # now do the minimization
        options = {'disp': False}
        if(self.advancedMinimization['algorithm'] in ['Nelder-Mead', 'Powell']):
          options.update({'xtol': xtol})
        res = optim.minimize(XX_monster_minWrapper, initpa, method=self.advancedMinimization['algorithm'],\
                             options=options, callback=minimizeCallback)
        success = True
      except ValueError as err:
        if((len(err.args)) and (err.args[0] == 'exceeded')):
          success = True
        else:
          if(self.daughterWindow != None):
            self.daughterWindow.close()
            self.daughterWindow = None
          success = False
          return False
      except:
        self.parent.statusbar.showMessage('Encountered some problem when searching minimum!', self.parent.STATUS_TIME)
        if(self.daughterWindow != None):
          self.daughterWindow.close()
          self.daughterWindow = None
        success = False
        return False
    
      if(success):
        # finish, close window if still visible
        if(self.daughterWindow != None):
          self.daughterWindow.close()
          self.daughterWindow = None
        # now update plot and parameter table
        self.globalParam_active_list = [i for i in self.fitpa]
        # after procedure, set new parameters and update curve
        self.updateBruteGlobalParam(self.culledDataSets, self.nop, updateResid=True)
        # success
        return True

  def doGlobalFit(self):
    # determine number of selected data sets
    selectedDataSets = [index for index, entry in enumerate(self.parent.data) if entry.globalFitCheck]
    if(len(selectedDataSets) < 2):
      self.parent.statusbar.showMessage('Select at least two datasets for global fit!', self.parent.STATUS_TIME)
    elif(sum([1 if i else 0 for i in self.globalParam_active]) == 0):
      self.parent.statusbar.showMessage('Select at least one parameter for global fit!', self.parent.STATUS_TIME)
    else:
      # check for no. of global parameters and display warning if equals zero
      noGlobalParams = True
      for index, entry in enumerate(self.globalParamNames):
        if(len(self.globalParamsCollate[entry]) > 1):
          noGlobalParams = False
      if(noGlobalParams):
        self.parent.statusbar.showMessage('No global parameters found! Will fit but there is no gain by global fit.', self.parent.STATUS_TIME, color='blue')
      
      # collate and organize data
      culledDataSets = []
      checkXerr, checkYerr = False, False
      flagXerr = False
      globalX, globalY, globalYerr, globalXerr, globalXerrOriginal, nop = [], [], [], [], [], []
      globalYSecond = []
      for index in selectedDataSets:
        # read and organize data
        indivData, indivRoles = self.parent.data[index].getData_n_Fit()
        currDataOnSecond = self.parent.data[index].onSecondAxes
        if(('x' in indivRoles) and ('y' in indivRoles)):
          culledDataSets.append(index)
          colX, colY = indivRoles.index('x'), indivRoles.index('y')
          # get y errors
          if('yerr' in indivRoles):
            colYerr = indivRoles.index('yerr')
          else:
            colYerr = -1
            checkYerr = True
          # get x errors
          if('xerr' in indivRoles):
            colXerr = indivRoles.index('xerr')
            flagXerr = True
          else:
            colXerr = -1
            checkXerr = True
          for line in indivData:
            globalX.append(line[colX])
            globalY.append(line[colY])
            if(colYerr + 1):
              globalYerr.append(line[colYerr])
            else:
              globalYerr.append(1)
            if(colXerr + 1):
              globalXerr.append(line[colXerr])
              globalXerrOriginal.append(line[colXerr])
            else:
              globalXerr.append(1)
              globalXerrOriginal.append(0)
            globalYSecond.append(currDataOnSecond)
          # count data points
          nop.append(len(indivData))
      
      if(checkYerr):
        self.parent.statusbar.showMessage('Warning -- y error missing in certain data sets => set to 1', self.parent.STATUS_TIME, color='blue')
      if(checkXerr and flagXerr):
        self.parent.statusbar.showMessage('Warning -- x error missing in certain data sets => set to 1', self.parent.STATUS_TIME, color='blue')
          
      # replace zero entries by self.EPSILON
      globalX, globalY, globalYerr = np.array(globalX), np.array(globalY), np.array(globalYerr)
      zerosigma = globalYerr[globalYerr <= 0]
      if(len(zerosigma) > 0):
        self.parent.statusbar.showMessage('Encountered zero/negative sigma values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
        globalYerr = np.array([i if(i>0) else self.EPSILON for i in globalYerr])
      # deal with x errors?
      if(flagXerr):
        globalXerr = np.array(globalXerr)
        globalXerrOriginal = np.array(globalXerrOriginal)
        zerosigmaX = globalXerr[globalXerr <= 0]
        if(len(zerosigmaX) > 0):
          self.parent.statusbar.showMessage('Encountered zero/negative sigmaX values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
          globalXerr = np.array([i if(i>0) else self.EPSILON for i in globalXerr])
          globalXerrOriginal = np.array([i if(i>0) else 0 for i in globalXerrOriginal])
      
      # determine curves to use
      selectedCurves = [self.parent.data[index].globalFitCurve for index in culledDataSets]
      selectedCurves = list(set(selectedCurves))
      selectedCurvesSecond = [self.parent.fit[index].onSecondAxes for index in selectedCurves]
      
      # cycle over all and define the individual fits in the current scope
      noProblem = self.functionInScope(selectedCurves)
      
      # only proceed if success with setting individual fit functions
      if(noProblem):
        # prepare the monster fit function
        globalFitFunc = 'def XX__monster_Ffunc_(self, x, '
        freeParam = [i for i, j in zip(self.globalParamNames, self.globalParam_active) if j]
        globalFitFunc += ', '.join(freeParam) + '):\n'
        globalFitFunc += '\t# fixed parameters\n'
        for index, entry in enumerate(self.globalParamNames):
          if(not(self.globalParam_active[index])):
            globalFitFunc += '\t' + entry + ' = ' + str(self.globalParamValues[index]) + '\n'
  
        # now call individual fit functions
        globalFitFunc += '\n\t# now call functions for individual curves'
        globalFitFunc += '\n\t__globalFval_ = np.array([])\n'
        for index, dataSetNumber in enumerate(culledDataSets):
          # localX
          if(not index):
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[:' + str(nop[index]) + ']'
          elif(index < len(culledDataSets) - 1):
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[' + str(sum(nop[:index])) + ':' + str(sum(nop[:index + 1])) + ']'
          else:
            globalFitFunc += '\n\t__localX_' + str(dataSetNumber) + ' = x[' + str(sum(nop[:index])) + ':]'
          # call function w/ localX
          useCurve = self.parent.data[dataSetNumber].globalFitCurve
          globalFitFunc += '\n\t__localFval_' + str(dataSetNumber) + ' = self.__globFfunc_' + str(useCurve) + '(__localX_' + str(dataSetNumber) + ', '
          globalFitFunc += ', '.join(self.parent.fit[useCurve].paramNames) + ')'
          # and np-stack results
          globalFitFunc += '\n\t__globalFval_ = np.hstack((__globalFval_, __localFval_' + str(dataSetNumber) + '))\n'
          
        # and wrap up the monster fit function
        globalFitFunc += '\n\treturn __globalFval_\n'
  
        # now test the monster fit function
        try:
          # generate ffunc in global namespace (this is needed for Python3 vs. Python2, bummer)
          namespace = self.mySpace
          exec(globalFitFunc, namespace)
          # we need to do some initial test to see whether the function can be called
          initpa = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
          retv = namespace['XX__monster_Ffunc_'](self, globalX, *initpa)
          # check for dimension mismatch
          if(retv.shape != globalX.shape):
            # we found some mismatch b/w x and y -- raise error to prevent program crash
            raise ValueError
        except:
          self.parent.statusbar.showMessage('Error collating global fit -- please check individual fit functions separately!', self.parent.STATUS_TIME)
        else:
          # now define the new function in the object scope
          setattr(GlobalArea, 'XX__monster_Ffunc_', namespace['XX__monster_Ffunc_'])
          
          # and we are ready to gogog!
          initpa = [i for i, j in zip(self.globalParamValues, self.globalParam_active) if j]
          sigma = globalYerr
          maxfev = 100000
          success = False
          if(flagXerr):
            try:
              # generate wrapper function to refactor x and param vectors
              def XX_monster_odrWrapper(globalParam, x):
                return self.XX__monster_Ffunc_(x, *globalParam)
              # populate x errors
              sigmaX = globalXerr
              sigmaX = [i if(i>0) else self.EPSILON for i in sigmaX]
              # call odr
              odrData = odr.RealData(globalX, globalY, sigmaX, sigma)
              odrModel = odr.Model(XX_monster_odrWrapper)
              odrODR = odr.ODR(odrData, odrModel, beta0=initpa)
              odrODR.set_job(fit_type=2)
              odrOut = odrODR.run()
              fitpa, covar = odrOut.beta, odrOut.cov_beta
              success = True
            except:
              # catch all kind of fit problems
              fitpa = initpa
              covar = np.zeros((len(fitpa), len(fitpa)))
          else:
            try:
              fitpa, covar = optim.curve_fit(self.XX__monster_Ffunc_, globalX, globalY, initpa, sigma, maxfev=maxfev)#, method='lm')
              success = True
            except:
              # catch all kind of fit problems
              fitpa = initpa
              covar = np.zeros((len(fitpa), len(fitpa)))

          # continue if fit successful
          if(success):
            # fit success! -- this is awesome
            # calculate variances etc.
            # evaluate fitted function at x values and store in data object
            globalFval = self.XX__monster_Ffunc_(globalX, *fitpa)
  
            # calculate confidences
            try:
              confidence = np.power(covar.diagonal(), 0.5)
            except:
              # takes care of NaN and similar errors
              confidence = ['--'] * len(fitpa)
            
            # check for 'nan' in confidence
            if(type(confidence) == type(np.array([]))):
              nanCheck = np.isnan(confidence)
              nanList = confidence[nanCheck]
              if(nanList.size):
                confidence = ['--'] * len(fitpa)
            
            # calculate chi_square and reduced chi_square
            resid = globalY - globalFval
            self.chisquare = (globalY - globalFval) ** 2 / globalYerr ** 2
            self.chisquare = np.sum(self.chisquare)
            dof = len(globalX) - sum([1 if i else 0 for i in self.globalParam_active])
            if(dof > 0):
              self.red_chisquare = self.chisquare / dof
            else:
              self.red_chisquare = 'inf'
            # and now calculate a priori errors
            if(self.red_chisquare != 'inf'):
              covar_apriori = covar / self.red_chisquare
              confidence_apriori = np.power(covar_apriori.diagonal(), 0.5)
            else:
              confidence_apriori = ['--'] * len(fitpa)
  
            # update parameters in list and table
            counter = 0
            for index, entry in enumerate(self.globalParam_active):
              if (entry):
                self.globalParamValues[index] = fitpa[counter]
                self.globalConfidence[index] = confidence[counter]
                self.globalConfidence_apriori[index] = confidence_apriori[counter]
                counter += 1
              else:
                self.globalConfidence[index] = '--'
                self.globalConfidence_apriori[index] = '--'
  
            # adjust x-axes limits according to all data sets and curves
            if(self.parent.plotArea.autoScaleX or self.parent.plotArea.autoScaleX_div):
              if(len(globalXerrOriginal)):
                temp_xmin = np.min([i - j for i, j in zip(globalX, globalXerrOriginal)])
                temp_xmax = np.max([i + j for i, j in zip(globalX, globalXerrOriginal)])
              else:
                temp_xmin, temp_xmax = np.min(globalX), np.max(globalX)
              # ensure minimum limit
              if (temp_xmax - temp_xmin < self.EPSILON):
                temp_xmax += self.EPSILON; temp_xmin -= self.EPSILON
              elif(self.parent.plotArea.data_spacer > 0):
                data_spacer = self.parent.plotArea.data_spacer
                if(self.parent.plotArea.modeX == 'linear'):
                  difference = temp_xmax - temp_xmin
                  temp_xmax += difference * data_spacer
                  temp_xmin -= difference * data_spacer
                else:
                  # log scale -- isolate positive data
                  pos_x = np.array(globalX)
                  pos_x = pos_x[pos_x > 0]
                  # recalc. xmin to address error when restoring state
                  if(len(pos_x > 1)):
                    temp_xmin, temp_xmax = np.min(pos_x), np.max(pos_x)
                    difference = np.log(temp_xmax / temp_xmin)
                    temp_xmin = np.exp(np.log(temp_xmin) - data_spacer * difference)
                    temp_xmax = np.exp(np.log(temp_xmax) + data_spacer * difference)
                    
              if(self.parent.plotArea.autoScaleX):
                self.parent.plotArea.setAxisLimits(lower = temp_xmin, upper = temp_xmax, axis = 'x', updateLabel = True, target='plot', redraw=False, updateGrid=True)
                self.parent.plotArea.setAxisLimits(lower = temp_xmin, upper = temp_xmax, axis = 'x', updateLabel = True, target='resid', redraw=False, updateGrid=True)
              if(self.parent.plotArea.autoScaleX_div):
                self.parent.plotArea.setAxisLimits(lower = temp_xmin, upper = temp_xmax, axis = 'x2', updateLabel = True, target='plot', redraw=False, updateGrid=True)
                self.parent.plotArea.setAxisLimits(lower = temp_xmin, upper = temp_xmax, axis = 'x2', updateLabel = True, target='resid', redraw=False, updateGrid=True)
 
            # cycle through individual curves and plot them
            # determine x interval over which to plot
            for index in selectedCurves:
              # update parameters
              self.parent.fit[index].updateParamSelect(names=self.globalParamNames, values=self.globalParamValues)
              # for non-active functions, calculate xy values => do that in this scope as we already defined the functions here
              if(index != self.parent.activeFit):
                self.updateNonActiveCurve(index, redefine=False)
              # plot function
              self.parent.fit[index].handlePlot = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot, redraw=False)
              self.parent.fit[index].handlePlot_div = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot_div, redraw=False, splitX=True)
  
            # update parameter table for current curve
            self.parent.fitarea.changeParamTable()
  
            # update residuals in data sets
            for index, dataSetNumber in enumerate(culledDataSets):
              if(not index):
                self.parent.data[dataSetNumber].setFval(globalFval[:nop[index]])
              elif(index < len(culledDataSets) - 1):
                self.parent.data[dataSetNumber].setFval(globalFval[sum(nop[:index]):sum(nop[:index + 1])])
              else:
                self.parent.data[dataSetNumber].setFval(globalFval[sum(nop[:index]):])
              
            # and we should update the results table
            self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData)
                
            # cycle through all data sets and plot residuals
            for index in culledDataSets:
              curveIndex = self.parent.data[index].globalFitCurve
              # generate resid style on the fly
              self.parent.data[index].Residstyle.update(self.parent.data[index].style)
              self.parent.data[index].ResidBarstyle.update(self.parent.data[index].Barstyle)
              self.parent.data[index].ResidStackstyle.update(self.parent.data[index].Stackstyle)
              self.parent.data[index].ResidTextstyle.update(self.parent.data[index].Textstyle)
              for item in ['linewidth', 'linestyle', 'color']:
                self.parent.data[index].ResidLinestyle[item] = deepcopy(self.parent.fit[curveIndex].style[item])
              # ensure line is visible to connect dots
              if(self.parent.data[index].Residstyle['linestyle'] == 'None'):
                self.parent.data[index].Residstyle['linestyle'] = 'solid'
              # plot residuals
              self.parent.data[index].handleResid, self.parent.plotArea.handleResidZero,\
                self.parent.data[index].handleResidBar, self.parent.data[index].handleResidStack, self.parent.data[index].handleResidStackNeg, self.parent.data[index].handleResidText = self.parent.plotArea.plotResid(\
                dataobject = self.parent.data[index], handleResid = self.parent.data[index].handleResid,\
                handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[index].handleResidBar,\
                handleResidStack = self.parent.data[index].handleResidStack, handleResidStackNeg = self.parent.data[index].handleResidStackNeg,\
                handleResidText = self.parent.data[index].handleResidText, redraw=False)
              self.parent.data[index].handleResid_div, self.parent.plotArea.handleResidZero_div,\
                self.parent.data[index].handleResidBar_div, self.parent.data[index].handleResidStack_div, self.parent.data[index].handleResidStackNeg_div, self.parent.data[index].handleResidText_div  = self.parent.plotArea.plotResid(\
                dataobject = self.parent.data[index], handleResid = self.parent.data[index].handleResid_div,\
                handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[index].handleResidBar_div,\
                handleResidStack = self.parent.data[index].handleResidStack_div, handleResidStackNeg = self.parent.data[index].handleResidStackNeg_div,\
                handleResidText = self.parent.data[index].handleResidText_div, redraw=False, splitX=True)
                
            # adjust y-axes limits according to all data sets and curves
            axes = [i for i, j in zip(['y', 'y2'], [self.parent.plotArea.autoScaleY, self.parent.plotArea.autoScaleY2]) if j]
            condition = {'y': False, 'y2': True}
            mode = {}; mode['y'] = self.parent.plotArea.modeY; mode['y2'] = self.parent.plotArea.modeY2
            for axis in axes:
              # filter for data that is on current y axis
              filter_y = np.array([i for i, j in zip(globalY, globalYSecond) if (j == condition[axis])])
              if(not checkYerr):
                filter_yerr = np.array([i for i, j in zip(globalYerr, globalYSecond) if (j == condition[axis])])
              # prepare temp_y -- data
              if(not checkYerr):
                temp_y = np.array([i - j for i, j in zip(filter_y, filter_yerr)])
                temp_y = np.hstack((temp_y, np.array([i + j for i, j in zip(filter_y, filter_yerr)])))
              else:
                temp_y = filter_y
              # prepare temp_y -- fit
              temp_fval = []
              for index, currFitOnSecond in zip(selectedCurves, selectedCurvesSecond):
                if(currFitOnSecond == condition[axis]):
                  dump_x, curr_y = self.parent.fit[index].simulateFunc()
                  temp_fval = np.hstack((temp_fval, curr_y))
              temp_y = np.hstack((temp_fval, temp_y))
              temp_y = np.array([i for i in temp_y if ((not np.isnan(i)) and (not np.isinf(i)))])
              # if any points available do the auto fit
              if(temp_y.size):
                temp_ymin = np.min(temp_y)
                temp_ymax = np.max(temp_y)
                # ensure minimum limit
                if (temp_ymax - temp_ymin < self.EPSILON):
                  temp_ymax += self.EPSILON; temp_ymin -= self.EPSILON
                elif(self.parent.plotArea.data_spacer > 0):
                  data_spacer = self.parent.plotArea.data_spacer
                  if(mode[axis] == 'linear'):
                    difference = temp_ymax - temp_ymin
                    temp_ymax += difference * data_spacer
                    temp_ymin -= difference * data_spacer
                  else:
                    # log scale -- isolate positive data
                    pos_y = np.array(temp_y)
                    pos_y = pos_y[pos_y > 0]
                    if(len(pos_y > 1)):
                      # recalc. xmin to address error when restoring state
                      temp_ymin, temp_ymax = np.min(pos_y), np.max(pos_y)
                      difference = np.log(temp_ymax / temp_ymin)
                      temp_ymin = np.exp(np.log(temp_ymin) - data_spacer * difference)
                      temp_ymax = np.exp(np.log(temp_ymax) + data_spacer * difference)
                
                self.parent.plotArea.setAxisLimits(lower = temp_ymin, upper = temp_ymax, axis = axis, updateLabel = True, target='plot', redraw=False, updateGrid=True)

            # adjust zoom of residuals plot to encompass all global datasets
            procval = [i for i in resid if ((not np.isnan(i)) and (not np.isinf(i)))]
            if(len(procval)):
              temp_ylimit = np.max([np.abs(i) for i in procval])
              # ensure minimum limit
              if (temp_ylimit == 0):
                maxResidY, minResidY = self.EPSILON, -self.EPSILON
              else:
                maxResidY, minResidY = 1.2 * temp_ylimit, -1.2 * temp_ylimit
              self.parent.plotArea.setAxisLimits(lower = minResidY, upper = maxResidY, axis = 'y', updateLabel = True, target='resid', redraw=False, updateGrid=True)

            # and we should update the fit information
            # did we use x errors?
            if(flagXerr):
              usedAlgorithm = 'odr'
            else:
              usedAlgorithm = 'lm'
            freeparameters = []; fixedparameters = []
            for index, entry in enumerate(self.globalParam_active):
              if(entry):
                if(self.globalConfidence_apriori[index] != '--'):
                  freeparameters.append(self.globalParamNames[index] + ' = ' + self.parent.formatNumber(self.globalParamValues[index])\
                    + ' +/- ' + self.parent.formatNumber(self.globalConfidence[index]) + ' (' + self.parent.formatNumber(self.globalConfidence_apriori[index]) + ')')
                else:
                  freeparameters.append(self.globalParamNames[index] + ' = ' + self.parent.formatNumber(self.globalParamValues[index]) + ' +/- ' + self.parent.formatNumber(self.globalConfidence[index]))
              else:
                fixedparameters.append(self.globalParamNames[index] + ' = ' + self.parent.formatNumber(self.globalParamValues[index]))
            freestring = '\n'.join(freeparameters)
            fixedstring = '\n'.join(fixedparameters)
            self.globalOutstring = self.fitGlobalResultsHeader
            self.globalOutstring += 'algorithm: ' + usedAlgorithm + '\n'
            self.globalOutstring += 'degrees of freedom: ' + str(dof) + '\n'
            self.globalOutstring += u'\N{GREEK CAPITAL LETTER CHI}2 ' + self.parent.formatNumber(self.chisquare) + '\n'
            self.globalOutstring += u'red. \N{GREEK CAPITAL LETTER CHI}2 ' + self.parent.formatNumber(self.red_chisquare) + '\n\n'

            self.globalOutstring += 'used datasets / functions:\n'
            for index in culledDataSets:
              curveIndex = self.parent.data[index].globalFitCurve
              self.globalOutstring += '   ' + self.parent.data[index].name + ' / ' + self.parent.fit[curveIndex].name +'\n'
            self.globalOutstring += '\n'

            self.globalOutstring += 'free parameters:\n' + freestring + '\n'
            if(len(fixedstring)):
              self.globalOutstring += '\nfixed parameters:\n' + fixedstring + '\n'
            self.globalFitResults.setText(self.globalOutstring)

            # remember that last fit was global
            self.parent.lastFitType = 'global'

            # issue plot updates
            self.parent.plotArea.dataplotwidget.myRefresh()
            self.parent.plotArea.residplotwidget.myRefresh()
                
            # update parameter tables
            self.updateGlobalParamTable(fitted=True)
          else:
            # some kind of fit problem
            self.parent.statusbar.showMessage('Error doing global fit -- please check individual fit functions separately!', self.parent.STATUS_TIME)

  def functionInScope(self, selectedCurves=[]):
    # defines a list of functions in current object scope
    # => needed for plotting and fitting
    noProblem = True
    for index in selectedCurves:
      indivFitFunc = 'def __globFfunc_' + str(index) + '(self, x, ' + ', '.join(self.parent.fit[index].paramNames) + '):\n\t'
      indivFitFunc += '\n\t'.join(self.parent.fit[index].ffuncstr_base.split('\n'))
      indivFitFunc += '\n\treturn y'
      try:
        namespace = self.mySpace
        # remove previous definition
        if(hasattr(GlobalArea, '__globFfunc_' + str(index))):
          delattr(GlobalArea, '__globFfunc_' + str(index))
        exec(indivFitFunc, namespace)
        setattr(GlobalArea, '__globFfunc_' + str(index), namespace['__globFfunc_' + str(index)])
      except:
        self.parent.statusbar.showMessage('Error setting fit function no. ' + str(index) + '!', self.parent.STATUS_TIME)
        noProblem = False
        
    # successful?
    return noProblem

  def updateNonActiveCurve(self, index=0, redefine=True):
    # helper function to update curves that are currently not active
    # check whether we should redefine the function (this is to prevent errors when function changed)
    success = True
    if(redefine):
      success = self.functionInScope([index])
    if(success and (hasattr(self, '__globFfunc_' + str(index)))):
      for splitX in [False, True]:
        if(splitX):
          xmin, xmax, useModeX = self.parent.plotArea.minX_div, self.parent.plotArea.maxX_div, self.parent.plotArea.modeX_div
        else:
          xmin, xmax, useModeX = self.parent.plotArea.minX, self.parent.plotArea.maxX, self.parent.plotArea.modeX
        if(useModeX == 'linear'):
          plotX = np.linspace(xmin, xmax, self.parent.plotArea.DATAPOINTS_SIMULATION)
        else:
          plotX = np.linspace(np.log(xmin), np.log(xmax), self.parent.plotArea.DATAPOINTS_SIMULATION)
          plotX = np.exp(plotX)
    
        usepa = []
        for entry in self.parent.fit[index].paramNames:
          index2 = self.globalParamNames.index(entry)
          usepa.append(self.globalParamValues[index2])
        method2call = getattr(self, '__globFfunc_' + str(index))
        indivFval = method2call(plotX, *usepa)
        self.parent.fit[index].updateXY(plotX, indivFval, splitX=splitX)
  
  def reportGlobalParam(self):
    # returns current parameters
    return self.globalParamNames, self.globalParam_active, self.globalParamValues, self.globalConfidence, self.globalConfidence_apriori, self.chisquare, self.red_chisquare

  def resetGlobalParam(self):
    # restores global params
    flag = False
    for index, entry in enumerate(self.storeGlobalParam):
      if(entry != self.globalParamValues[index]):
        flag = True
        
    if(flag):
      # update global values and table
      self.globalParamValues = [i for i in self.storeGlobalParam]
      self.globalConfidence = ['--'] * len(self.globalParamValues)
      self.globalConfidence_apriori = ['--'] * len(self.globalParamValues)
      self.updateGlobalParamTable(fitted=True)
      
      # update individual curves
      selectedDataSets = [index for index, entry in enumerate(self.parent.data) if entry.globalFitCheck]
      selectedCurves = [self.parent.data[index].globalFitCurve for index in selectedDataSets]
      selectedCurves = list(set(selectedCurves))
      for index in selectedCurves:
        # update params as needed
        paramUpdateNames, paramUpdateValues = [], []
        for entry in self.parent.fit[index].paramNames:
          if(entry in self.globalParamNames):
            paramUpdateNames.append(entry)
            paramUpdateValues.append(self.globalParamValues[self.globalParamNames.index(entry)])
        self.parent.fit[index].updateParamSelect(paramUpdateNames, paramUpdateValues)

        if(index != self.parent.activeFit):
          self.updateNonActiveCurve(index)        
        # plot function
        self.parent.fit[index].handlePlot = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot, redraw=False)
        self.parent.fit[index].handlePlot_div = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index], handlePlot = self.parent.fit[index].handlePlot_div, redraw=False, splitX=True)
  
      # update parameter table for current curve
      self.parent.fitarea.changeParamTable()

      # issue plot update
      self.parent.plotArea.dataplotwidget.myRefresh()

  def updateGlobalParamTable(self, fitted=False):
    # updates global param table
    if(not fitted):
      # first collate all parameters from all entries
      self.globalParamsCollate = {}
      self.globalParamNames = []
      self.globalParamValues = []
      self.globalParam_active = []
      for index, entry in enumerate(self.parent.data):
        if(self.dataSetTable.cellWidget(index, 0).isChecked()):
          # sanity check for globalFitCurve
          self.parent.data[index].globalFitCurve = min(self.parent.data[index].globalFitCurve, len(self.parent.fit) - 1)
          indexCurve = self.parent.data[index].globalFitCurve
          indivParam, indivParamNames, indivParamActive = self.parent.fit[indexCurve].paramAll, self.parent.fit[indexCurve].paramNames, self.parent.fit[indexCurve].active
          
          for param, paramName, paramActive in zip(indivParam, indivParamNames, indivParamActive):
            if(paramName in self.globalParamsCollate):
              self.globalParamsCollate[paramName].append(param)
            else:
              self.globalParamsCollate[paramName] = [param]
              self.globalParam_active.append(paramActive)
              self.globalParamNames.append(paramName)
              self.globalParamValues.append(param)
      
      # reset confidences and active parameters        
      self.globalConfidence = ['--'] * len(self.globalParamsCollate)
      self.globalConfidence_apriori = ['--'] * len(self.globalParamsCollate)
      
      # store parameters for later resetting
      self.storeGlobalParam = [i for i in self.globalParamValues]

    # prepare table
    self.globalParamTable.setRowCount(len(self.globalParamsCollate))
    
    # set row height and fix
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.globalParamTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    hheader = self.globalParamTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    
    self.chkBoxItem = []
    # set up new param entries
    for index, entry in enumerate(self.globalParamNames):
      item = QtWidgets.QTableWidgetItem(entry)
      if(len(self.globalParamsCollate[entry]) > 1):
        item.setForeground(QtCore.Qt.blue)
        useFont = item.font()
        useFont.setBold(True)
        item.setFont(useFont)
      self.globalParamTable.setVerticalHeaderItem(index, item)

      qchkbox_item = QPushButtonCheckable()
      if(self.globalParam_active[index]):
        qchkbox_item.setChecked(True)
      else:
        qchkbox_item.setChecked(False)
      qchkbox_item.setText('fit')
      qchkbox_item.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      qchkbox_item.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      qchkbox_item.clicked.connect(partial(self.clickGlobalParam, index))
      self.globalParamTable.setCellWidget(index, 0, qchkbox_item)

      qline_item = QLineEditClick(self.parent.formatNumber(self.globalParamValues[index]))
      qline_item.setValidator(self.validFloat)
      qline_item.setAlignment(QtCore.Qt.AlignRight)
      qline_item.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qline_item.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qline_item.editingFinished.connect(partial(self.editGlobalParam, index))
      self.globalParamTable.setCellWidget(index, 1, qline_item)

      qlabel_item = QtWidgets.QLabel(self.parent.formatNumber(self.globalConfidence[index]))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
      self.globalParamTable.setCellWidget(index, 2, qlabel_item)
      
      qlabel_item = QtWidgets.QLabel(self.parent.formatNumber(self.globalConfidence_apriori[index]))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
      self.globalParamTable.setCellWidget(index, 3, qlabel_item)
      
    # set automatic column size
    self.globalParamTable.resizeColumnsToContents()

  def updateDataSetTable(self):
    # prepare table
    self.dataSetTable.setRowCount(len(self.parent.data))
    
    # set row height and fix
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.dataSetTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    hheader = self.dataSetTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    
    # populate table
    for index, entry in enumerate(self.parent.data):
      self.dataSetTable.setVerticalHeaderItem(index, QtWidgets.QTableWidgetItem(str(index + 1)))

      qchkbox_item = QPushButtonCheckable()
      qchkbox_item.setChecked(entry.globalFitCheck)
      qchkbox_item.setText('use')
      qchkbox_item.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      qchkbox_item.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      qchkbox_item.clicked.connect(partial(self.clickDataSet, index))
      self.dataSetTable.setCellWidget(index, 0, qchkbox_item)

      qlabel_item = QtWidgets.QLabel(entry.name)
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
      self.dataSetTable.setCellWidget(index, 1, qlabel_item)
      
      qcombobox_item = QComboBoxMac()
      qcombobox_item.setMinimumHeight(scaledDPI(BASE_SIZE))
      qcombobox_item.setMaximumHeight(scaledDPI(BASE_SIZE))
      for index2, entry2 in enumerate(self.parent.fit):
        qcombobox_item.addItem(str(index2 + 1) + ' - ' + entry2.name)
      if(self.parent.data[index].globalFitCurve < len(self.parent.fit)):
        qcombobox_item.setCurrentIndex(self.parent.data[index].globalFitCurve)
      else:
        qcombobox_item.setCurrentIndex(0)
      qcombobox_item.activated.connect(partial(self.selectGlobalFfunc, index))
      self.dataSetTable.setCellWidget(index, 2, qcombobox_item)
      
      qlabel_item = QtWidgets.QLabel()
      indexCurve = min(self.parent.data[index].globalFitCurve, (len(self.parent.fit) - 1))
      curr_param = ', '.join(self.parent.fit[indexCurve].paramNames)
      qlabel_item.setText(curr_param)
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(190), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(190), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
      self.dataSetTable.setCellWidget(index, 3, qlabel_item)
      
    # set automatic column size
    self.dataSetTable.resizeColumnsToContents()
    
    # trigger update of global param table
    self.updateGlobalParamTable()

  def selectGlobalFfunc(self, index=0):
    # need to update data object
    indexCurve = self.dataSetTable.cellWidget(index, 2).currentIndex()
    self.parent.data[index].globalFitCurve = indexCurve
    
    # update parameters
    curr_param = ', '.join(self.parent.fit[indexCurve].paramNames)
    self.dataSetTable.cellWidget(index, 3).setText(curr_param)

    # trigger update of global param table
    self.updateGlobalParamTable()

  def clickDataSet(self, index=0):
    # processes click on data set
    state = self.dataSetTable.cellWidget(index, 0).isChecked()
    if(index < len(self.parent.data)):
      self.parent.data[index].globalFitCheck = state

    # trigger update of global param table
    self.updateGlobalParamTable()

  def clickGlobalParam(self, index=0):
    # check/uncheck global param
    state = self.globalParamTable.cellWidget(index, 0).isChecked()
    self.globalParam_active[index] = state

  def editGlobalParam(self, index=0):
    # edits global param
    try:
      value = float(self.globalParamTable.cellWidget(index, 1).text())
    except:
      value = 0
    
    if(self.globalParamValues[index] != value):
      self.globalParamValues[index] = value
      paramName = self.globalParamNames[index]
      # update parameters in curves
      redraw = False
      selectedDataSets = [index2 for index2, entry in enumerate(self.parent.data) if entry.globalFitCheck]
      selectedCurves = [self.parent.data[index2].globalFitCurve for index2 in selectedDataSets]
      selectedCurves = list(set(selectedCurves))
      for index2 in selectedCurves:
        if(paramName in self.parent.fit[index2].paramNames):
          if(index2 == self.parent.activeFit):
            # update parameter table for current curve
            self.parent.fitarea.changeParamTable()
          else:
            self.updateNonActiveCurve(index2)        
            
          self.parent.fit[index2].updateParamSelect([paramName], [self.globalParamValues[index]])
          # plot function
          self.parent.fit[index2].handlePlot = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index2], handlePlot = self.parent.fit[index2].handlePlot, redraw=False)
          self.parent.fit[index2].handlePlot_div = self.parent.plotArea.plotFunction(fitobject = self.parent.fit[index2], handlePlot = self.parent.fit[index2].handlePlot_div, redraw=False, splitX=True)
          if(self.parent.fit[index2].visibility):
            redraw = True
  
      # issue plot updates
      if(redraw):
        self.parent.plotArea.dataplotwidget.myRefresh()

  def setAdvancedRandomSearch(self, key=None, value=None):
    # updates advanced random search settings
    if(key in self.advancedRandomSearch):
      self.advancedRandomSearch[key] = value

  def setAdvancedMinimization(self, key=None, value=None):
    # updates advanced minmization settings
    if(key in self.advancedMinimization):
      self.advancedMinimization[key] = value
      
    if(key == 'algorithm'):
      self.doGlobalMinButton.setText('Global ' + self.advancedMinimization['algorithm'] + ' Min.')

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline
      
  def formatNumber(self, number):
    # formats number for output
    NUMBER_SWITCH = 1e3
    FORMAT_DECIMAL = '{:.3f}'
    FORMAT_SCIENTIFIC = '{:.3e}'
    # determine return string
    if((self.isNumber(number)) and (np.isfinite(float(number)))):
      if((np.abs(number)>NUMBER_SWITCH) or (np.abs(number)<1.0/NUMBER_SWITCH)):
        numberstr = FORMAT_SCIENTIFIC.format(number)
      else:
        numberstr = FORMAT_DECIMAL.format(number)
    else:
      numberstr = str(number)
    
    return numberstr

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False
 
class FitArea(QWidgetMac):
  def __init__(self, parent=None):
    super(FitArea, self).__init__()
    self.parent = parent
    self.validFloat = MyValidFloat()
    self.param = []
    self.storeParam = []
    self.confidence = []
    self.confidence_apriori = []
    self.param_active = []
    self.chisquare, self.red_chisquare = 0, 0
    self.ffuncList = self.initFfunc(path=WORKINGDIR + PATH_SEPARATOR + 'functions' + PATH_SEPARATOR)
    self.fitResultsHeader = 'Latest fit results:'
    self.fitResultsHeader += '\n' + '-' * len(self.fitResultsHeader) + '\n'
    self.outstring = self.fitResultsHeader
    # use epsilon as minimum error value and for calculating derivatives
    self.EPSILON = 1e-9
    # define amplitude threshold for random variation of parameters
    self.MIN_AMPLITUDE = 0.5
    
    # advanced export settings
    self.advancedMinimization = {'algorithm': 'Nelder-Mead', 'xtol': 1e-8, 'maxfev': 1e5}
    self.advancedRandomSearch = {'cycles': 5, 'escalate': 1.5, 'maxfev': 1e4}

    # set up GUI
    self.buildRessource()

  def buildRessource(self):
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    
    # set up container for fit formula
    self.fitFunctionContainer = QWidgetMac()
    self.vLayout.addWidget(self.fitFunctionContainer, stretch=5)
    self.LayoutFitFunctionContainer = QtWidgets.QVBoxLayout(self.fitFunctionContainer)
    self.LayoutFitFunctionContainer.setContentsMargins(0, 0, 0, 0)

    # set up selector for fit functions
    self.comboBox = QComboBoxMac()
    self.comboBox.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.comboBox.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.LayoutFitFunctionContainer.addWidget(self.comboBox)
    self.populateFfuncSelector()
    self.comboBox.activated.connect(self.selectFfunc)

    # set up field that declares parameters
    self.declareParamBox = QWidgetMac()
    self.hLayout = QtWidgets.QHBoxLayout(self.declareParamBox)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.declareParamLabel = QtWidgets.QLabel()
    self.declareParamLabel.setText('Parameters')
    self.declareParamLabel.setMinimumSize(QtCore.QSize(scaledDPI(65), scaledDPI(20)))
    self.declareParamLabel.setMaximumSize(QtCore.QSize(scaledDPI(65), scaledDPI(20)))
    self.hLayout.addWidget(self.declareParamLabel)
    self.declareParamEntry = QLineEditClick()
    self.declareParamEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.declareParamEntry.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.declareParamEntry.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.hLayout.addWidget(self.declareParamEntry)
    
    self.LayoutFitFunctionContainer.addWidget(self.declareParamBox)
    
    # set up edit field for fit function
    self.fitFormula = myQTextEdit(self)
    self.fitFormula.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
    self.fitFormula.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(600)))
    self.LayoutFitFunctionContainer.addWidget(self.fitFormula)

    # read all available fit functions
    if (len(self.ffuncList)):
      defaultFunction = 'binding_isotherm.ffunc'
      functionNo = 0
      for index, entry in enumerate(self.ffuncList):
        if(defaultFunction in entry):
          functionNo = index
      success, parameters, formula, values, active = self.loadFfunc(self.ffuncList[functionNo])
      self.comboBox.blockSignals(True)
      self.comboBox.setCurrentIndex(functionNo)
      self.comboBox.blockSignals(False)
      self.paramList = parameters
      parameters = ', '.join(parameters)
    else:
      parameters = 'A0, A1, KD'
      self.paramList = ['A0', 'A1', 'KD']
      formula = '# a binding isotherm\ny = A0 + A1 * x / (x + KD)'
      values = [1, 1, 1]
      active = [True] * 3

    self.declareParamEntry.setText(parameters)
    self.fitFormula.setText(formula)
    self.param = values
    self.storeParam = [i for i in self.param]
    self.confidence = ['--'] * len(values)
    self.confidence_apriori = ['--'] * len(values)
    self.param_active = [1 if i else 0 for i in active]
    
    # set up buttons
    self.buttonContainer = QWidgetMac()
    self.buttonContainer.setContentsMargins(0, 0, 0, 0)
    self.LayoutFitFunctionContainer.addWidget(self.buttonContainer)
    self.LayoutButtonContainer = QtWidgets.QHBoxLayout(self.buttonContainer)
    self.LayoutButtonContainer.setContentsMargins(0, 0, 0, 0)
    
    self.saveFitButton = QPushButtonMac()
    self.saveFitButton.setText('Save Fit Function')
    self.saveFitButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.saveFitButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.saveFitButton.clicked.connect(self.saveFit)
    self.LayoutButtonContainer.addWidget(self.saveFitButton)
    self.useFitButton = QPushButtonMac()
    self.useFitButton.setText('Apply Fit Function')
    self.useFitButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.useFitButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.useFitButton.clicked.connect(partial(self.useFit, True))
    self.LayoutButtonContainer.addWidget(self.useFitButton)

    # set up container for parameter table
    self.parameterTableContainer = QWidgetMac()
    self.vLayout.addWidget(self.parameterTableContainer, stretch=3)
    self.LayoutParameterTableContainer = QtWidgets.QVBoxLayout(self.parameterTableContainer)
    self.LayoutParameterTableContainer.setContentsMargins(0, 0, 0, 0)

    # set up parameter table
    blah = self.HLine()
    self.LayoutParameterTableContainer.addWidget(blah)
    self.ParamTable = QtWidgets.QTableWidget()
    self.ParamTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.ParamTable.setEnabled(True)
    self.ParamTable.setColumnCount(4)
    self.ParamTable.setRowCount(1)
    self.ParamTable.setHorizontalHeaderItem(0, QtWidgets.QTableWidgetItem('Fit?'))
    self.ParamTable.setHorizontalHeaderItem(1, QtWidgets.QTableWidgetItem('Value'))
    self.ParamTable.setHorizontalHeaderItem(2, QtWidgets.QTableWidgetItem('Error'))
    item3 = QtWidgets.QTableWidgetItem('a priori')
    useFont = item3.font()
    useFont.setItalic(True)
    item3.setFont(useFont)
    self.ParamTable.setHorizontalHeaderItem(3, item3)
    self.LayoutParameterTableContainer.addWidget(self.ParamTable)
    self.updateParamTable()
    self.useFit(redraw=False)
   
    # set fit controls 2
    self.ButtonContainer2 = QWidgetMac()
    self.LayoutParameterTableContainer.addWidget(self.ButtonContainer2)
    self.LayoutButtonContainer2 = QtWidgets.QHBoxLayout(self.ButtonContainer2)
    self.LayoutButtonContainer2.setContentsMargins(0, 0, 0, 0)

    # set up Fit button
    self.doFitButton = QPushButtonMac()
    self.doFitButton.setText('Fit Data')
    self.doFitButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doFitButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doFitButton.clicked.connect(self.doFit)
    self.LayoutButtonContainer2.addWidget(self.doFitButton)

    # set up minimize button
    self.doMinButton = QPushButtonMac()
    self.doMinButton.setText(self.advancedMinimization['algorithm'] + ' Min.')
    self.doMinButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doMinButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doMinButton.clicked.connect(self.doMin)
    self.LayoutButtonContainer2.addWidget(self.doMinButton)

    # set up random fit button
    self.doBruteButton = QPushButtonMac()
    self.doBruteButton.setText('Random Search')
    self.doBruteButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.doBruteButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.doBruteButton.clicked.connect(self.doBruteFit)
    self.LayoutButtonContainer2.addWidget(self.doBruteButton)

    # set up Reset button
    self.resetButton = QPushButtonMac()
    self.resetButton.setText('Reset Parameters')
    self.resetButton.setMinimumHeight(scaledDPI(BASE_SIZE))
    self.resetButton.setMaximumHeight(scaledDPI(BASE_SIZE))
    self.resetButton.clicked.connect(self.resetParam)
    self.LayoutButtonContainer2.addWidget(self.resetButton)

    # set up container for fit results
    self.fitResultsContainer = QWidgetMac()
    self.vLayout.addWidget(self.fitResultsContainer, stretch=2)
    self.LayoutFitResultsContainer = QtWidgets.QVBoxLayout(self.fitResultsContainer)
    self.LayoutFitResultsContainer.setContentsMargins(0, 0, 0, 0)
    
    # set up text edit field for displaying fit results
    blah = self.HLine()
    self.LayoutFitResultsContainer.addWidget(blah)
    self.fitResults = QtWidgets.QTextEdit()
    self.fitResults.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
    self.fitResults.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(600)))
    self.LayoutFitResultsContainer.addWidget(self.fitResults)
    self.fitResults.setReadOnly(True)
    self.fitResults.setText(self.fitResultsHeader)
    self.parent.fit[self.parent.activeFit].fitresults = self.fitResultsHeader

  def reportState(self):
    # reports data content for saveState function
    retv = {}
    retv['parameters'] = self.paramList
    retv['formula'] = self.fitFormula.toPlainText()
    retv['fitresults'] = self.fitResults.toPlainText()
    retv['param'] = self.param
    retv['storeParam'] = self.storeParam
    retv['confidence'] = self.confidence
    retv['confidence_apriori'] = self.confidence_apriori
    retv['active'] = self.param_active
    
    return retv

  def restoreState(self, data):
    # restores data content from loadState function
    try:
      parameters = data['parameters']
      formula = data['formula']
      values = data['param']
      active = data['active']
      fitresults = data['fitresults']
      confidence = data['confidence']
      confidence_apriori = data['confidence_apriori']
      storeParam = data['storeParam']
     
      # restore fit function
      self.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori)
      self.storeParam = storeParam
      
      # additionally restore confidence
      self.confidence = confidence
      self.confidence_apriori = confidence_apriori
      self.changeParamTable()
      self.parent.globalarea.updateDataSetTable()
    except:
      self.parent.statusbar.showMessage('Failed to restore state!', self.parent.STATUS_TIME)
      print('Failed to restore state', data)

  def populateFfuncSelector(self):
    # initializes or updates function selector
    self.comboBox.clear()
    itemList = []
    
    for entry in self.ffuncList:
      menuItem = entry
      if('\\' in menuItem):
        menuItem = menuItem.split('\\')[-1]
      elif('/' in menuItem):
        menuItem = menuItem.split('/')[-1]
      menuItem = menuItem.split('.')[0]
      itemList.append(menuItem)
    
    # sort itemList
    if(len(itemList)):
      itemList, self.ffuncList = [list(i) for i in zip(*sorted(zip(itemList, self.ffuncList), key=lambda s: s[0].lower()))]
    
    #for menuItem in sorted(itemList):
    for menuItem in itemList:
      self.comboBox.addItem(menuItem)

  def saveFit(self):
    # saves fit function
    # determine currently selected function
    index = self.comboBox.currentIndex()
    if(index + 1):
      currFunc = self.ffuncList[index]
    else:
      currFunc = '.'
    
    # open save dialog
    saveDialog = QtWidgets.QFileDialog()
    saveDialog.selectFile(currFunc)   # strangely enough, this call is not heeded
    filename, fitler_ = saveDialog.getSaveFileName(self, filter = 'Fit function (*.ffunc)', directory=currFunc, caption='Save Fit Function')
    filename = str(filename)
    try:
      savehandle=open(filename,'w')
      # write parameters
      savehandle.write('<PARAMETERS>\n')
      for index, entry in enumerate(self.paramList):
        red = entry + ', ' + self.parent.formatNumber(self.param[index])
        red += ', ' + str(self.param_active[index]) + '\n'
        savehandle.write(red)
      
      # write formula
      savehandle.write('<FORMULA>\n')
      red = str(self.fitFormula.toPlainText())
      savehandle.write(red)
      savehandle.close()
      
      # add function to ffunclist and update selector
      self.ffuncList = self.initFfunc(path=WORKINGDIR + PATH_SEPARATOR + 'functions' + PATH_SEPARATOR)
      self.comboBox.blockSignals(True)
      self.populateFfuncSelector()
      
      # determine index of new function in selector (use short filenames)
      if('/' in filename):
        shortFilename = filename.split('/')[-1]
      elif('\\' in filename):
        shortFilename = filename.split('\\')[-1]
      else:
        shortFilename = filename
        
      index = -1
      for index2, entry in enumerate(self.ffuncList):
        if(shortFilename in entry):
          index = index2

      if(index+1):
        self.comboBox.setCurrentIndex(index)
      else:
        self.comboBox.setCurrentIndex(0)
        
      # update storeParam
      self.storeParam = [i for i in self.param]

      self.comboBox.blockSignals(False)
    except:
      self.parent.statusbar.showMessage('Cannot write function file ' + filename, self.parent.STATUS_TIME)


  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline
  
  def getRelativeDerivatives(self, xval, yval, yerr):
    # determine derivatives of fit parameters
    x, self.startVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=xval, param=self.param_active_list)
    self.startResid = np.sum((yval - self.startVal) ** 2 / yerr ** 2)

    # cycle through parameters and calc. derivatives
    for index, entry in enumerate(self.param_active_list):
      workparam = [i for i in self.param_active_list]
      workparam[index] = self.param[index] * (1.0 + self.EPSILON)
      x, perturbVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=xval, param=workparam)
      perturbResid = np.sum((yval - perturbVal) ** 2 / yerr ** 2)
      # calc. change in chi square when varying a certain parameter
      self.derivatives[index] = (perturbResid - self.startResid)# / self.EPSILON #/ self.EPSILON #startResid

    # now also assign amplitudes for random parameter variation
    self.randomAmplitudes = np.array([1.0 / i if i != 0 else 0 for i in self.derivatives])
          
    # calc. relative amplitudes
    divisor = np.max(np.abs(self.randomAmplitudes))
    divisor = np.max((divisor, self.EPSILON))
    self.randomAmplitudes = self.randomAmplitudes / divisor / 2.0

  def doBruteFit(self):
    # check whether there is at least one floating parameter
    if(np.sum(self.param_active) == 0):
      self.parent.statusbar.showMessage('At least one parameter has to be free for fitting!', self.parent.STATUS_TIME)
    else:
      # get data from data object and start the fit procedure
      data = self.parent.data[self.parent.activeData].value()
      if((not 'x' in data) or (len(data['x']) < np.sum(self.param_active))):
        try:
          nop = len(data['x'])
        except:
          nop = 0
        self.parent.statusbar.showMessage('No. of data points (' + str(nop) + ') should at least equal no. of free parameters (' + str(np.sum(self.param_active)) + ')!', self.parent.STATUS_TIME)
      elif(('x' in data) and ('y' in data) and (len(data['x']) > 0)):
        # assign values
        xval = np.array(data['x']); yval = np.array(data['y'])
        if('yerr' in data):
          # weed out zero values
          yerr = np.array([i if(i>0) else self.EPSILON for i in data['yerr']])
        else:
          yerr = np.ones(len(data['x']))
          
        # open an extra window to interact with procedure
        self.runFlag = True
        self.daughterWindow = BruteWindow(self, 'Random Search')
        # apply styles to popup window
        if(QSTYLE != None):
          self.daughterWindow.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          self.daughterWindow.setStyleSheet(QSTYLESHEET)
        self.daughterWindow.show()
        
        # create list of active parameters
        self.param_active_list = [self.param[i] for i, x in enumerate(self.param_active) if (x == 1)]
        self.origParam = [i for i in self.param_active_list]
        
        # cycle until daughter window closed
        movingCursor = '|,/,-,\\'.split(',')
        cursorCount = 0
        repeatCycleLimit, escalate, lastSuccessLimit = self.advancedRandomSearch['cycles'],\
          self.advancedRandomSearch['escalate'], self.advancedRandomSearch['maxfev']
        escalate = [escalate ** i for i in range(repeatCycleLimit)]
        residstr = ''
        for repeatCycleCount in range(repeatCycleLimit):
          # update message label
          self.daughterWindow.messageLabel.setText('Repeat cycle ' + str(repeatCycleCount + 1) + '/' + str(repeatCycleLimit))
          
          # parameter derivatives
          self.derivatives = np.zeros(len(self.param_active_list))
          self.getRelativeDerivatives(xval, yval, yerr)
          self.daughterWindow.messageLabel2.setText('resid ' + self.parent.formatNumber(self.startResid) + residstr)
      
          lastSuccessCount = 0
          while ((lastSuccessCount < lastSuccessLimit) and (self.runFlag)):
            # randomly vary parameters
            for trial in range(100):
              lastSuccessCount += 1
              # randomly vary parameters -- add epsilon to get rid of zero parameters
              workamplitude = [i if (np.abs(i) > self.MIN_AMPLITUDE) else (np.sign(i + 1.1 * self.EPSILON) * self.MIN_AMPLITUDE) for i in self.param_active_list]
              workamplitude = escalate[repeatCycleCount] * np.array(workamplitude)
              
              workparam = self.param_active_list  + (workamplitude * (0.33 - np.random.random(len(self.param_active_list))))
              x, perturbVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=xval, param=workparam)
              perturbResid = np.sum((yval - perturbVal)**2 / yerr**2)
              
              if(perturbResid < self.startResid):
                # improvement, yeah!
                # update params
                self.param_active_list = [i for i in workparam]
                self.updateBruteParam(False)
                # calc. residuals
                self.parent.data[self.parent.activeData].setFval(perturbVal)
                # prepare new round of random search
                self.getRelativeDerivatives(xval, yval, yerr)
                self.daughterWindow.messageLabel2.setText('resid ' + self.parent.formatNumber(self.startResid) + residstr)
                lastSuccessCount = 0
                self.daughterWindow.messageLabel3.setText('Func eval: ' + str(int(np.min((lastSuccessCount,\
                  lastSuccessLimit)))) + '/' + str(int(lastSuccessLimit)))
            
            # periodically update label in daughter window
            cursorCount += 1
            if(cursorCount >= len(movingCursor)):
              cursorCount = 0
            self.daughterWindow.messageLabel3.setText('Func eval: ' + str(int(np.min((lastSuccessCount,\
              lastSuccessLimit)))) + '/' + str(int(lastSuccessLimit)))
            self.daughterWindow.messageLabel4.setText('Working ' + movingCursor[cursorCount])
            # need to still process events
            QtCore.QCoreApplication.processEvents()

          if((repeatCycleCount == 0) or (self.startResid < self.bestResid)):
            # first cycle or improvement
            self.bestParam = [i for i in self.param_active_list]
            self.bestVal = 1.0 * self.startVal
            self.bestResid = 1.0 * self.startResid
            residstr = '; best ' + self.parent.formatNumber(self.bestResid)

          # reset original parameters for next cycle
          self.param_active_list = [i for i in self.origParam]
                      
        # finished all repeat cycles
        self.daughterWindow.close()
        self.daughterWindow = None
        
        # restore best results from previous cycle
        if(repeatCycleCount > 0):
          self.param_active_list = [i for i in self.bestParam]
          self.startVal = 1.0 * self.bestVal
        
        # calc. residuals even if no improvement
        self.parent.data[self.parent.activeData].setFval(self.startVal)
        # after procedure, set new parameters and update curve
        self.updateBruteParam(True)

  def updateBruteParam(self, updateResid=False):
    # update fit parameters once found better resid
    counter = 0
    for index, entry in enumerate(self.param_active):
      if (entry == 1):
        self.param[index] = self.param_active_list[counter]
        counter += 1
    self.parent.fit[self.parent.activeFit].updateParam(self.param_active_list)
    # plot function
    self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
      fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
    self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
      fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot_div, splitX=True)
    # update param table
    self.changeParamTable()
    # also update residuals?
    if(updateResid):
      # generate resid style on the fly
      self.parent.data[self.parent.activeData].Residstyle = deepcopy(self.parent.data[self.parent.activeData].style)
      self.parent.data[self.parent.activeData].ResidBarstyle = deepcopy(self.parent.data[self.parent.activeData].Barstyle)
      self.parent.data[self.parent.activeData].ResidStackstyle = deepcopy(self.parent.data[self.parent.activeData].Stackstyle)
      self.parent.data[self.parent.activeData].ResidLinestyle = deepcopy(self.parent.fit[self.parent.activeFit].style)
      # ensure line is visible to connect dots
      if(self.parent.data[self.parent.activeData].Residstyle['linestyle'] == 'None'):
        self.parent.data[self.parent.activeData].Residstyle['linestyle'] = 'solid'
      # plot residuals
      self.parent.data[self.parent.activeData].handleResid, self.parent.plotArea.handleResidZero,\
        self.parent.data[self.parent.activeData].handleResidBar, self.parent.data[self.parent.activeData].handleResidStack, self.parent.data[self.parent.activeData].handleResidStackNeg, self.parent.data[self.parent.activeData].handleResidText  = self.parent.plotArea.plotResid(\
        dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid,\
        handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar,\
        handleResidStack = self.parent.data[self.parent.activeData].handleResidStack, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg,\
        handleResidText = self.parent.data[self.parent.activeData].handleResidText, redraw=False)
      self.parent.data[self.parent.activeData].handleResid_div, self.parent.plotArea.handleResidZero_div,\
        self.parent.data[self.parent.activeData].handleResidBar_div, self.parent.data[self.parent.activeData].handleResidStack_div, self.parent.data[self.parent.activeData].handleResidStackNeg_div, self.parent.data[self.parent.activeData].handleResidText_div = self.parent.plotArea.plotResid(\
        dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid_div,\
        handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar_div,\
        handleResidStack = self.parent.data[self.parent.activeData].handleResidStack_div, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg_div,\
        handleResidText = self.parent.data[self.parent.activeData].handleResidText_div, splitX=True)
      
  def reportParam(self):
    # returns current parameters
    return self.paramList, self.param_active, self.param, self.confidence, self.confidence_apriori, self.chisquare, self.red_chisquare

  def resetParam(self):
    # restores parameters to original (or, saved) values
    # first check whether we need to restore parameters at all
    flag = False
    for index, entry in enumerate(self.storeParam):
      if(entry != self.param[index]):
        flag = True
        
    if(flag):
      self.param = [i for i in self.storeParam]
      self.confidence = ['--'] * len(self.param)
      self.confidence_apriori = ['--'] * len(self.param)
      self.updateParamTable()
  
      # also recompile the fit function for good measure and plot
      self.setFfunc()
  
      # plot function not needed as already done by setFfunc()
      #self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
      #  fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot)
  
  def doMin(self):
    # check whether there is at least one floating parameter
    if(np.sum(self.param_active) == 0):
      self.parent.statusbar.showMessage('At least one parameter has to be free for minimization!', self.parent.STATUS_TIME)
      return False
    else:
      # get data from data object and start the fit procedure
      data = self.parent.data[self.parent.activeData].value()
      # check number of fit parameters vs. data points
      if((not 'x' in data) or (len(data['x']) < np.sum(self.param_active))):
        try:
          nop = len(data['x'])
        except:
          nop = 0
        self.parent.statusbar.showMessage('No. of data points (' + str(nop) + ') should at least equal no. of free parameters (' + str(np.sum(self.param_active)) + ')!', self.parent.STATUS_TIME)
        return False
      elif (('x' in data) and ('y' in data)):
        # prepare fit
        xtol, maxfev = self.advancedMinimization['xtol'], self.advancedMinimization['maxfev']
        self.fev, self.currResid = 0, 0
        # assign and check y error
        if('yerr' in data):
          sigma = data['yerr']
          sigma = [i if(i>0) else self.EPSILON for i in sigma]
        else:
          sigma = [1] * len(data['y'])
      
        # get active parameters
        self.param_active_list = [self.param[i] for i, x in enumerate(self.param_active) if (x == 1)]
        initpa = [i for i in self.param_active_list]
        self.fitpa = [i for i in initpa]
        self.daughterWindow = None
        self.runFlag = True
        
        try:
          # define callback and wrapper functions
          def minimizeCallback(args=0):
            self.fev += 1
            self.fitpa = args
            if((self.fev > maxfev) or (not self.runFlag)):
              # have to raise a warning to terminate
              raise ValueError('exceeded')
            # process events once in a while
            if(not (self.fev % 100)):
              if(self.daughterWindow != None):
                self.daughterWindow.iterLabel.setText('iter ' + str(int(self.fev)) + ' / ' + str(int(maxfev)))
                self.daughterWindow.minLabel.setText('resid ' + self.formatNumber(self.currResid))
              QtCore.QCoreApplication.processEvents()
          
          def XX_minWrapper(param):
            # calculates square deviation b/w data and curve
            x, fval = self.parent.fit[self.parent.activeFit].evaluateFunc(data['x'], param)
            resid = (fval - data['y']) / sigma
            resid = resid ** 2
            self.currResid = np.sum(resid)
            return self.currResid

          # open an extra window to interact with procedure
          self.daughterWindow = MinWindow(self, self.advancedMinimization['algorithm'] + ' Minimization')
          # apply styles to popup window
          if(QSTYLE != None):
            self.daughterWindow.setStyle(QSTYLE)
          if(QSTYLESHEET != None):
            self.daughterWindow.setStyleSheet(QSTYLESHEET)
          self.daughterWindow.show()

          # now do the minimization
          options = {'disp': False}
          if(self.advancedMinimization['algorithm'] in ['Nelder-Mead', 'Powell']):
            options.update({'xtol': xtol})
          res = optim.minimize(XX_minWrapper, initpa, method=self.advancedMinimization['algorithm'],\
                               options=options, callback=minimizeCallback)
          success = True
        except ValueError as err:
          if((len(err.args)) and (err.args[0] == 'exceeded')):
            success = True
          else:
            if(self.daughterWindow != None):
              self.daughterWindow.close()
              self.daughterWindow = None
            success = False
            return False
        except:
          self.parent.statusbar.showMessage('Encountered some problem when searching minimum!', self.parent.STATUS_TIME)
          if(self.daughterWindow != None):
            self.daughterWindow.close()
            self.daughterWindow = None
          success = False
          return False
        
        if(success):
          # finish, close window if still visible
          if(self.daughterWindow != None):
            self.daughterWindow.close()
            self.daughterWindow = None
          # now update plot and parameter table
          self.param_active_list = [i for i in self.fitpa]
          x, numVal = self.parent.fit[self.parent.activeFit].evaluateFunc(x=data['x'], param=self.fitpa)
          # calc. residuals even if no improvement
          self.parent.data[self.parent.activeData].setFval(numVal)
          # after procedure, set new parameters and update curve
          self.updateBruteParam(True)
          # success
          return True
      else:
        self.parent.statusbar.showMessage('No y values found!', self.parent.STATUS_TIME)
        return False

  def doFit(self):
    # check whether there is at least one floating parameter
    if(np.sum(self.param_active) == 0):
      self.parent.statusbar.showMessage('At least one parameter has to be free for fitting!', self.parent.STATUS_TIME)
      return False
    else:
      # get data from data object and start the fit procedure
      data = self.parent.data[self.parent.activeData].value()
      # check number of fit parameters vs. data points
      if((not 'x' in data) or (len(data['x']) < np.sum(self.param_active))):
        try:
          nop = len(data['x'])
        except:
          nop = 0
        self.parent.statusbar.showMessage('No. of data points (' + str(nop) + ') should at least equal no. of free parameters (' + str(np.sum(self.param_active)) + ')!', self.parent.STATUS_TIME)
        return False
      else:
        success, fitpa, covar = self.parent.fit[self.parent.activeFit].fitFunc(data)
        if (success):
          # evaluate fitted function at x values and store in data object
          x, fval = self.parent.fit[self.parent.activeFit].simulateFunc(x = self.parent.data[self.parent.activeData].x)
          self.parent.data[self.parent.activeData].setFval(fval)

          # calculate confidences
          try:
            confidence = np.power(covar.diagonal(), 0.5)
          except:
            # takes care of NaN and similar errors
            confidence = ['--'] * len(fitpa)
          
          # check for 'nan' in confidence
          if(type(confidence) == type(np.array([]))):
            nanCheck = np.isnan(confidence)
            nanList = confidence[nanCheck]
            if(nanList.size):
              confidence = ['--'] * len(fitpa)
          
          # calculate chi_square and reduced chi_square
          if('yerr' in data):
            yerr = self.parent.data[self.parent.activeData].yerr
            # weed out zero sigma entries
            zerosigma = yerr[yerr <= 0]
            if(len(zerosigma) > 0):
              self.parent.statusbar.showMessage('Encountered zero/negative sigma values => set to ' + str(self.EPSILON), self.parent.STATUS_TIME, color='blue')
              yerr = np.array([i if(i>0) else self.EPSILON for i in yerr])
          else:
            yerr = np.array([1.0 for i in self.parent.data[self.parent.activeData].x])
          self.chisquare = self.parent.data[self.parent.activeData].resid**2 / yerr**2
          self.chisquare = np.sum(self.chisquare)
          nop = np.sum(self.param_active)
          dof = len(self.parent.data[self.parent.activeData].x) - nop
          if(dof > 0):
            self.red_chisquare = self.chisquare / dof
          else:
            self.red_chisquare = 'inf'
          # and now calculate a priori errors
          if((self.red_chisquare != 'inf') and ('yerr' in data)):
            covar_apriori = covar / self.red_chisquare
            confidence_apriori = np.power(covar_apriori.diagonal(), 0.5)
          else:
            confidence_apriori = ['--'] * len(fitpa)
          # did we use x errors?
          if('xerr' in data):
            usedAlgorithm = 'odr'
          else:
            usedAlgorithm = 'lm'
          
          # update parameters in list and table
          counter = 0
          for index, entry in enumerate(self.param_active):
            if (entry):
              self.param[index] = fitpa[counter]
              self.confidence[index] = confidence[counter]
              self.confidence_apriori[index] = confidence_apriori[counter]
              counter += 1
              
          self.changeParamTable()
          
          # update chi square information in fit object
          self.parent.fit[self.parent.activeFit].updateChiSquare(self.chisquare, self.red_chisquare)
          
          # generate resid style on the fly
          self.parent.data[self.parent.activeData].Residstyle.update(self.parent.data[self.parent.activeData].style)
          self.parent.data[self.parent.activeData].ResidBarstyle.update(self.parent.data[self.parent.activeData].Barstyle)
          self.parent.data[self.parent.activeData].ResidStackstyle.update(self.parent.data[self.parent.activeData].Stackstyle)
          self.parent.data[self.parent.activeData].ResidTextstyle.update(self.parent.data[self.parent.activeData].Textstyle)
          for item in ['linewidth', 'linestyle', 'color']:
            self.parent.data[self.parent.activeData].ResidLinestyle[item] = deepcopy(self.parent.fit[self.parent.activeFit].style[item])
          # ensure line is visible to connect dots
          if(self.parent.data[self.parent.activeData].Residstyle['linestyle'] == 'None'):
            self.parent.data[self.parent.activeData].Residstyle['linestyle'] = 'solid'
          # plot function
          self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
            fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
          self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
            fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot_div, splitX=True)
          # plot residuals
          self.parent.data[self.parent.activeData].handleResid, self.parent.plotArea.handleResidZero,\
            self.parent.data[self.parent.activeData].handleResidBar, self.parent.data[self.parent.activeData].handleResidStack, self.parent.data[self.parent.activeData].handleResidStackNeg, self.parent.data[self.parent.activeData].handleResidText = self.parent.plotArea.plotResid(\
            dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid,\
            handleResidZero = self.parent.plotArea.handleResidZero, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar,\
            handleResidStack = self.parent.data[self.parent.activeData].handleResidStack, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg,\
            handleResidText = self.parent.data[self.parent.activeData].handleResidText, redraw=False)
          self.parent.data[self.parent.activeData].handleResid_div, self.parent.plotArea.handleResidZero_div,\
            self.parent.data[self.parent.activeData].handleResidBar_div, self.parent.data[self.parent.activeData].handleResidStack_div, self.parent.data[self.parent.activeData].handleResidStackNeg_div, self.parent.data[self.parent.activeData].handleResidText_div  = self.parent.plotArea.plotResid(\
            dataobject = self.parent.data[self.parent.activeData], handleResid = self.parent.data[self.parent.activeData].handleResid_div,\
            handleResidZero = self.parent.plotArea.handleResidZero_div, handleResidBar = self.parent.data[self.parent.activeData].handleResidBar_div,\
            handleResidStack = self.parent.data[self.parent.activeData].handleResidStack_div, handleResidStackNeg = self.parent.data[self.parent.activeData].handleResidStackNeg_div,\
            handleResidText = self.parent.data[self.parent.activeData].handleResidText_div, splitX=True)
          # and we should update the results table
          self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData)

          # and we should update the fit information
          freeparameters = []; fixedparameters = []
          for index, entry in enumerate(self.param_active):
            if(entry):
              if(self.confidence_apriori[index] != '--'):
                freeparameters.append(self.paramList[index] + ' = ' + self.parent.formatNumber(self.param[index])\
                  + ' +/- ' + self.parent.formatNumber(self.confidence[index]) + ' (' + self.parent.formatNumber(self.confidence_apriori[index]) + ')')
              else:
                freeparameters.append(self.paramList[index] + ' = ' + self.parent.formatNumber(self.param[index]) + ' +/- ' + self.parent.formatNumber(self.confidence[index]))
            else:
              fixedparameters.append(self.paramList[index] + ' = ' + self.parent.formatNumber(self.param[index]))
          freestring = '\n'.join(freeparameters)
          fixedstring = '\n'.join(fixedparameters)
          self.outstring = self.fitResultsHeader
          self.outstring += 'algorithm: ' + usedAlgorithm + '\n'
          self.outstring += 'degrees of freedom: ' + str(dof) + '\n'
          self.outstring += u'\N{GREEK CAPITAL LETTER CHI}2 ' + self.parent.formatNumber(self.chisquare) + '\n'
          self.outstring += u'red. \N{GREEK CAPITAL LETTER CHI}2 ' + self.parent.formatNumber(self.red_chisquare) + '\n\n'
          index = self.comboBox.currentIndex()
          if(index + 1):
            currFunc = self.ffuncList[index]
          else:
            currFunc = ''
          self.outstring += 'function: ' + currFunc + '\n'
          self.outstring += '  ' + '\n  '.join(str(self.fitFormula.toPlainText()).splitlines()) + '\n\n'
          self.outstring += 'free parameters:\n' + freestring + '\n'
          if(len(fixedstring)):
            self.outstring += '\nfixed parameters:\n' + fixedstring + '\n'
          self.fitResults.setText(self.outstring)
          self.parent.fit[self.parent.activeFit].fitresults = self.outstring
          
          # remember that last fit was local
          self.parent.lastFitType = 'local'
          
        # used for handling keyboard shortcuts
        return True
      
  def changeParamTable(self):
    # fills in values into the parameter table
    for index, entry in enumerate(self.paramList):
      self.ParamTable.cellWidget(index, 1).setText(self.parent.formatNumber(self.param[index]))
      self.ParamTable.cellWidget(index, 2).setText(self.parent.formatNumber(self.confidence[index]))
      self.ParamTable.cellWidget(index, 3).setText(self.parent.formatNumber(self.confidence_apriori[index]))

  def useFit(self, redraw=True):
    # update parameter table
    self.updateParamTable()
    # set fit function
    self.setFfunc(redraw=redraw)

  def setFfunc(self, redraw=True):
    # dynamically assign fit function
    # function body
    ffunc_orig = str(self.fitFormula.toPlainText())
    ffunc = '\t'+'\n\t'.join(ffunc_orig.split('\n'))
    
    ffunc_top = ''; ffunc_header = ''; param_count = 0; fitpa = []
    # cycle over all parameters
    for index, entry in enumerate(self.paramList):
      if(self.param_active[index]):
        param_count += 1
        fitpa.append(float(self.param[index]))
        ffunc_header += ', '+entry
      else:
        ffunc_top += '\t'+entry+' = '+str(float(self.param[index]))+'\n'
    
    ffunc = ffunc_top + ffunc
    
    # update the function in the fit object
    if (self.parent.fit[self.parent.activeFit].updateFunc(ffunc, ffunc_header, testParam=fitpa)):
      # update parameters
      self.parent.fit[self.parent.activeFit].updateParam(fitpa)
      self.parent.fit[self.parent.activeFit].updateChiSquare(self.chisquare, self.red_chisquare)
      # store this information in current fit function
      if(hasattr(self, 'fitResults')):
        fitresults = self.fitResults.toPlainText()
      else:
        fitresults = ''
      self.parent.fit[self.parent.activeFit].storeInfo(self.paramList, self.param, self.param_active,\
        self.confidence, self.confidence_apriori, ffunc_orig, ffunc_header, fitresults, self.chisquare, self.red_chisquare)
      # plot function
      self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
        fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot,\
        redraw=False)
      self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
        fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot_div,\
        redraw=redraw, splitX=True)
      # don't use palettes as these are incompatible with style sheets
      self.fitFormula.setStyleSheet('myQTextEdit {background-color: white;}')
    else:
      # some kind of failure
      if(hasattr(self.parent, 'statusbar')):
        self.parent.statusbar.showMessage('Error setting fit function!', self.parent.STATUS_TIME)
        # don't use palettes as these are incompatible with style sheets
        self.fitFormula.setStyleSheet('myQTextEdit {background-color: rgb(250, 190, 190);}')
   
  def updateParamTable(self):
    # check which params we have
    self.paramList = str(self.declareParamEntry.text()).split(',')
    self.paramList = [i.strip() for i in self.paramList]
    # initialize newly added parameters to 1
    while(len(self.param)<len(self.paramList)):
      self.param.append(1.0)
      self.confidence.append('--')
      self.confidence_apriori.append('--')
      self.param_active.append(1)
    # truncate self.param if parameters have been deleted
    if(len(self.param)>len(self.paramList)):
      self.param=self.param[:len(self.paramList)]
      self.confidence=self.confidence[:len(self.paramList)]
      self.confidence_apriori=self.confidence_apriori[:len(self.paramList)]
      self.param_active=self.param_active[:len(self.paramList)]
    
    # prepare table
    self.ParamTable.setRowCount(len(self.paramList))
    
    # set row height and fix
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.ParamTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    vheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    hheader = self.ParamTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    
    self.chkBoxItem = []
    # set up new param entries
    for index, entry in enumerate(self.paramList):
      self.ParamTable.setVerticalHeaderItem(index, QtWidgets.QTableWidgetItem(entry))

      qchkbox_item = QPushButtonCheckable()
      if(self.param_active[index]):
        qchkbox_item.setChecked(True)
      else:
        qchkbox_item.setChecked(False)
      qchkbox_item.setText('fit')
      qchkbox_item.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      qchkbox_item.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      qchkbox_item.clicked.connect(partial(self.clickParam, index))
      self.ParamTable.setCellWidget(index, 0, qchkbox_item)

      qline_item = QLineEditClick(self.parent.formatNumber(self.param[index]))
      qline_item.setValidator(self.validFloat)
      qline_item.setAlignment(QtCore.Qt.AlignRight)
      qline_item.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qline_item.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qline_item.editingFinished.connect(partial(self.editParam, index))
      self.ParamTable.setCellWidget(index, 1, qline_item)

      qlabel_item = QtWidgets.QLabel(self.parent.formatNumber(self.confidence[index]))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
      self.ParamTable.setCellWidget(index, 2, qlabel_item)
      
      qlabel_item = QtWidgets.QLabel(self.parent.formatNumber(self.confidence_apriori[index]))
      qlabel_item.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      qlabel_item.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignVCenter)
      self.ParamTable.setCellWidget(index, 3, qlabel_item)
      
    # set automatic column size
    self.ParamTable.resizeColumnsToContents()
    
  def editParam(self, index):
    try:
      self.param[index] = float(self.ParamTable.cellWidget(index, 1).text())
    except:
      self.param[index] = 0

    # update parameters
    # check whether this parameter is fixed or not
    if (self.param_active[index]):
      fitpa = []
      for index, entry in enumerate(self.param):
        if(self.param_active[index]):
          fitpa.append(entry)
      self.parent.fit[self.parent.activeFit].updateParam(fitpa)
    else:
      # also have to recompile the fit function
      self.setFfunc()

    # plot function
    self.parent.fit[self.parent.activeFit].handlePlot = self.parent.plotArea.plotFunction(\
      fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot, redraw=False)
    self.parent.fit[self.parent.activeFit].handlePlot_div = self.parent.plotArea.plotFunction(\
      fitobject = self.parent.fit[self.parent.activeFit], handlePlot = self.parent.fit[self.parent.activeFit].handlePlot_div, splitX=True)
    
  def clickParam(self, index):
    # test what state the checkbox now has
    if(self.ParamTable.cellWidget(index, 0).isChecked()):
      self.param_active[index] = 1
    else:
      self.param_active[index] = 0
      self.confidence[index] = '--'
      self.ParamTable.cellWidget(index, 2).setText(str(self.confidence[index]))
      self.confidence_apriori[index] = '--'
      self.ParamTable.cellWidget(index, 3).setText(str(self.confidence_apriori[index]))
    
    # update ffunc and parameters
    fitpa = []
    for index, entry in enumerate(self.param):
      if(self.param_active[index]):
        fitpa.append(entry)
    self.parent.fit[self.parent.activeFit].updateParam(fitpa)
    self.setFfunc()
    # but we should not need to update the plot itself

  def initFfunc(self, path='', pattern='*.ffunc'):
    # returns list of available fit functions
    if(path == ''):
      path = WORKINGDIR + PATH_SEPARATOR + 'functions' + PATH_SEPARATOR
    ffunc_list = glob(path+pattern)
    return ffunc_list
    
  def loadFfunc(self, filename):
    # load fit function
    try:
      # read file contents
      readhandle = open(filename, 'r')
      red = readhandle.readline()
      params = []; formula = ''; mode = 0; values = []; active = []
      while(red):
        if ('<PARAMETERS>' in red):
          mode = 1
        elif ('<FORMULA>' in red):
          mode = 2
        elif (mode == 1):
          red = red.strip()
          if (',' in red):
            temparray = red.split(',')
            params.append(temparray[0])
            try:
              values.append(float(temparray[1]))
            except:
              values.append(0.0)
            if(red.count(',') > 1):
              try:
                active.append(bool(float(temparray[2])))
              except:
                active.append(True)
            else:
              active.append(True)
          else:
            params.append(red)
            values.append(1.0)
            active.append(True)
        elif (mode == 2):
          formula += red
        
        red = readhandle.readline()
        
      readhandle.close()
      success = True
    except:
      success = False; params = []; formula = ''; values = []; active = []
    
    return success, params, formula, values, active
    
  def selectFfunc(self):
    # a new fit function was selected in the list
    index = self.comboBox.currentIndex()
    success, parameters, formula, values, active = self.loadFfunc(self.ffuncList[index])
    if(success):
      self.paramList = parameters
      parameters = ', '.join(parameters)
      self.declareParamEntry.setText(parameters)
      self.fitFormula.setText(formula)
      self.param = values
      self.storeParam = [i for i in self.param]
      self.confidence = ['--'] * len(values)
      self.confidence_apriori = ['--'] * len(values)
      self.param_active = [1 if i else 0 for i in active]
      self.updateParamTable()
      self.useFit()
      self.parent.globalarea.updateDataSetTable()
    else:
      self.parent.statusbar.showMessage('Cannot load function ' + self.comboBox.currentText() + '!', self.parent.STATUS_TIME)
    
  def restoreFfunc(self, parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=True):
    # an existing fit function was restored
    self.paramList = parameters
    parameters = ', '.join(parameters)
    self.declareParamEntry.setText(parameters)
    self.fitFormula.setText(formula)
    self.fitResults.setText(fitresults)
    self.param = values
    self.storeParam = [i for i in self.param]
    # need these checks for backward compatibility
    if((type(confidence) != type([])) or (len(confidence) != len(values))):
      self.confidence = ['--'] * len(values)
    else:
      self.confidence = confidence
    if((type(confidence_apriori) != type([])) or (len(confidence_apriori) != len(values))):
      self.confidence_apriori = ['--'] * len(values)
    else:
      self.confidence_apriori = confidence_apriori
    self.param_active = [1 if i else 0 for i in active]
    self.updateParamTable()
    self.useFit(redraw=redraw)
    
  def setAdvancedRandomSearch(self, key=None, value=None):
    # updates advanced random search settings
    if(key in self.advancedRandomSearch):
      self.advancedRandomSearch[key] = value

  def setAdvancedMinimization(self, key=None, value=None):
    # updates advanced minmization settings
    if(key in self.advancedMinimization):
      self.advancedMinimization[key] = value

    if(key == 'algorithm'):
      self.doMinButton.setText(self.advancedMinimization['algorithm'] + ' Min.')

  def formatNumber(self, number):
    # formats number for output
    NUMBER_SWITCH = 1e3
    FORMAT_DECIMAL = '{:.3f}'
    FORMAT_SCIENTIFIC = '{:.3e}'
    # determine return string
    if((self.isNumber(number)) and (np.isfinite(float(number)))):
      if((np.abs(number)>NUMBER_SWITCH) or (np.abs(number)<1.0/NUMBER_SWITCH)):
        numberstr = FORMAT_SCIENTIFIC.format(number)
      else:
        numberstr = FORMAT_DECIMAL.format(number)
    else:
      numberstr = str(number)
    
    return numberstr

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False
  
class FitObject(object):
  def __init__(self, parent = None):
    self.parent = parent
    self.parent.zcount += 1
    self.zorder = self.parent.zcount
    self.onSecondAxes = False

    # locally import numpy again
    import numpy as np
    # import common functions from numpy for ease of access
    from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh
    self.mySpace = locals()
    
    self.param = np.array([])
    self.active = []
    self.paramNames =[]
    self.paramAll = []
    self.confidence = []
    self.confidence_apriori = []
    self.ffuncstr_base = ''
    self.ffunc_header = ''
    self.fitresults = ''
    self.chisq = '--'
    self.redchisq = '--'
    
    # memorize plot formatting
    self.rememberSetting = {}
    # use epsilon as minimum error value
    self.EPSILON = 1e-9
    # initialize handles for graphics
    self.handlePlot = None
    self.handlePlot_div = None
    # initialize name
    self.setName('Curve_'+str(len(self.parent.fit)))
    # initialize visibility
    self.visibility = True
    # initialize activity state
    self.retired = False
    # initialize data storage
    self.x = np.array([])
    self.y = np.array([])
    self.x_div = np.array([])
    self.y_div = np.array([])
    # initalize style
    self.style = {}
    self.style['linewidth'] = 2.0
    self.style['linestyle'] = 'solid'
    self.style['dash_capstyle'] = 'butt'
    #self.style['solid_capstyle'] = 'butt'
    self.style['color'] = [0.89, 0.29, 0.2, 1.0]
    self.style['markerfacecolor'] = [0.89, 0.29, 0.2, 1.0]
    self.style['markerfacecoloralt'] = [0.0, 0.0, 0.0, 1.0]
    self.style['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
    self.style['markeredgewidth'] = 1.0
    self.style['markersize'] = 14.0
    self.style['marker'] = 'None'
    self.style['fillstyle'] = 'full'
    self.style['markevery'] = 100
    self.style['doFill'] = True
    # restrict plot interval?
    self.restrictMe, self.restrictLow, self.restrictHigh = False, 0.0, 1.0
    
    # initialize funcstr_base
    self.ffuncstr_base = ''
    self.ffunc_header = ''
    self.fitresults = ''
    
    # memorize plot settings
    for key in self.style:
      self.rememberSetting[key] = 'set_' + key + '(' + repr(self.style[key]) + ')'
    
  def reportState(self):
    # reports data content for saveState function
    items = 'name,param,ffuncstr_base,ffunc_header,active,paramNames,confidence,confidence_apriori,fitresults,paramAll,zorder,retired,x,y,onSecondAxes,chisq,redchisq,restrictMe,restrictLow,restrictHigh'.split(',')
    retv = {}
    
    for entry in items:
      if(hasattr(self, entry)):
        value = self.__dict__[entry]
        if(type(value) == type(np.array([]))):
          value = value.tolist()
        retv[entry] = value
    
    return retv

  def restoreState(self, data={}, zoffset=0):
    # restores data content for loadState function
    for entry in data:
      if(hasattr(self, entry)):
        if(entry in ['x', 'y']):
          value = np.array(data[entry])
        elif(entry == 'zorder'):
          value = data[entry] + zoffset
        elif(entry == 'name'):
          value = data[entry]
          self.setName(value)
        else:
          value = data[entry]
        self.__dict__[entry] = value
        
    # redefine fit function
    if((self.ffuncstr_base != '') or (self.ffunc_header != '')):
      self.updateFunc(self.ffuncstr_base, self.ffunc_header)
      
  def retrieveInfo(self):
    # returns previous fit formula and values etc.
    return self.paramNames, self.ffuncstr_base, self.paramAll, self.active, self.fitresults, self.confidence, self.confidence_apriori

  def retrieveInfoReport(self):
    # returns previous fit formula and values etc. -- for use in generating HTML report
    return self.paramNames, self.active, self.paramAll, self.confidence, self.confidence_apriori, self.chisq, self.redchisq
    
  def storeInfo(self, paramNames, paramAll, active, confidence, confidence_apriori, ffuncstr_base, ffunc_header, fitresults, chisq, redchisq):
    self.paramNames = paramNames
    self.paramAll = paramAll
    self.active = active
    self.confidence = confidence
    self.confidence_apriori = confidence_apriori
    self.ffuncstr_base = ffuncstr_base
    self.ffunc_header = ffunc_header
    self.fitresults = fitresults
    self.chisq = chisq
    self.redchisq = redchisq

  def setName(self, name='Jane Doe'):
    # updates name of object
    self.name = name
    # update plot if necessary
    if(self.handlePlot != None):
      self.handlePlot.set_label(name)
    self.rememberSetting['name'] = 'set_label(' + repr(self.name) + ')'
    
  def setZOrder(self, zorder=0, redraw=True):
    # updates z order
    if(self.zorder == zorder):
      redraw, changed = False, False
    else:
      changed = True
    self.zorder = zorder
    # update plot if necessary
    updateFlag = False
    if(self.handlePlot != None):
      self.handlePlot.set_zorder(self.zorder + self.parent.zOffset)
      updateFlag = True
      self.rememberSetting['zorder'] = 'set_zorder(' + str(self.zorder + self.parent.zOffset) + ')'
    if(self.handlePlot_div != None):
      self.handlePlot_div.set_zorder(self.zorder + self.parent.zOffset)
      updateFlag = True
    # update plot
    if(redraw and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return changed

  def setSecondAxes(self, state=False, redraw=True):
    # moves plot between axes
    self.onSecondAxes = state
    # trigger redraw
    self.drawMe(redraw=redraw)

  def setVisibility(self, state=True, redraw=True):
    # toggles visibility of curve
    if(self.visibility == state):
      redraw, changed = False, False
    else:
      changed = True
    self.visibility = state
    updateFlag = False
    if(self.handlePlot != None):
      self.handlePlot.set_visible(state)
      if(self.visibility):
        self.handlePlot.set_label(self.name)
      else:
        self.handlePlot.set_label('_nolegend_')
      updateFlag = True
      self.rememberSetting['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if(self.handlePlot_div != None):
      self.handlePlot_div.set_visible(state)
      updateFlag = True
    # update plot
    if(redraw and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return changed

  def spawned(self, source=None):
    # copies contents of the source object to current object
    # note: we do not need to copy ffunc() since we will redefine it in the new object
    if(source != None):
      copyItems = 'param,style,x,y,visibility,ffuncstr_base,ffunc_header,active,paramNames,confidence,fitresults,paramAll,onSecondAxes,chisq,redchisq,restrictMe,restrictLow,restrictHigh'.split(',') #, ffunc
      for item in copyItems:
        if(hasattr(source, item)):
          sourceItem = deepcopy(getattr(source, item))
          setattr(self, item, sourceItem)
      # redefine fit function
      if((self.ffuncstr_base != '') or (self.ffunc_header != '')):
        self.updateFunc(self.ffuncstr_base, self.ffunc_header)
    
  def initialize(self):
    # initialize object with default values
    success = False
    if (len(self.parent.fitarea.ffuncList)):
      defaultFunction = 'binding_isotherm.ffunc'
      functionNo = 0
      for index, entry in enumerate(self.parent.fitarea.ffuncList):
        if(defaultFunction in entry):
          functionNo = index
      success, self.paramNames, self.ffuncstr_base, self.paramAll, self.active = self.parent.fitarea.loadFfunc(self.parent.fitarea.ffuncList[functionNo])
    # opt for default function if problems arise
    if(not success):
      self.paramNames = ['A0', 'A1', 'KD']
      self.ffuncstr_base = '# a binding isotherm\ny = A0 + A1 * x / (x + KD)'
      self.paramAll = [1, 1, 1]
      self.active = [True] * 3
      
    # prepare and set fit function
    self.param = [i for i, j in zip(self.paramAll, self.active) if j]
    nonactive = [i for i, j in zip(self.paramAll, self.active) if (not j)]
    self.ffunc_header = ', '.join(nonactive)
    self.confidence = ['--'] * len(self.param)

    # redefine fit function
    if((self.ffuncstr_base != '') or (self.ffunc_header != '')):
      self.updateFunc(self.ffuncstr_base, self.ffunc_header)
    
  def drawMe(self, redraw=True, rescale=True):
    # causes curve to be drawn on canvas
    self.handlePlot = self.parent.plotArea.plotFunction(fitobject=self, handlePlot=self.handlePlot, redraw=False, doAutoZoom=rescale)
    # set visibility
    if (self.handlePlot != None):
      self.handlePlot.set_visible(self.visibility)

    self.handlePlot_div = self.parent.plotArea.plotFunction(fitobject=self, handlePlot=self.handlePlot_div, redraw=redraw, splitX=True, doAutoZoom=rescale)
    # set visibility
    if (self.handlePlot_div != None):
      self.handlePlot_div.set_visible(self.visibility)

  def getStyle(self):
    # returns the style object
    return self.style

  def getRestricted(self):
    # returns restriction info
    return self.restrictMe, self.restrictLow, self.restrictHigh

  def setRestricted(self, key, value, redraw=True):
    # toggles plot interval restriction
    if(key in ('restrictMe', 'restrictLow', 'restrictHigh')):
      if((key == 'restrictMe') or (self.__dict__[key] != value)):
        self.__dict__[key] = value
        if(self.retired):
          # temporarily unretire and update
          prevActive = self.parent.activeFit
          self.parent.activeFit = self.parent.fit.index(self)
          self.retired, self.parent.fit[prevActive].retired = False, True
          # change fit formula
          parameters, formula, values, active, fitresults, confidence, confidence_apriori = self.retrieveInfo()
          self.parent.fitarea.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=False)
          self.drawMe(redraw=redraw, rescale=False)
          # restore previous function
          self.retired, self.parent.fit[prevActive].retired = True, False
          self.parent.activeFit = prevActive
          parameters, formula, values, active, fitresults, confidence, confidence_apriori = self.parent.fit[prevActive].retrieveInfo()
          self.parent.fitarea.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=redraw)
        else:
          self.drawMe(redraw=redraw, rescale=True)

  def toggleMarkerFill(self, value, redraw=True):
    # toggles marker fill
    if(self.style['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.style['doFill'] = value
    # adjust value
    if(value):
      value = self.style['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    if(self.handlePlot != None):
      self.handlePlot.set_markerfacecolor(value)
      self.rememberSetting['markerfacecolor'] = 'set_markerfacecolor(' + repr(value) + ')'
    if(self.handlePlot_div != None):
      self.handlePlot_div.set_markerfacecolor(value)

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return (changed and self.visibility)
    
  def setStyle(self, key, value, redraw=True):
    # changes the style value
    if(key in self.style):
      if(self.style[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.style[key] = value
      # cause plot to be updated
      updateFlag = False
      # special treatment for markerfacecolor
      if((key != 'markerfacecolor') or self.style['doFill']):
        if(self.handlePlot != None):
          method = 'set_'+key
          if (hasattr(self.handlePlot, method)):
            method2call = getattr(self.handlePlot, method)
            method2call(value)
            updateFlag = True
            self.rememberSetting[key] = 'set_' + key + '(' + repr(value) + ')'
            # special treatment for capstyle
            if((key == 'dash_capstyle') and (hasattr(self.handlePlot, 'set_solid_capstyle'))):
              method2call = getattr(self.handlePlot, 'set_solid_capstyle')
              method2call(value)
              self.rememberSetting['solid_capstyle'] = 'set_solid_capstyle(' + repr(value) + ')'
        if(self.handlePlot_div != None):
          method = 'set_'+key
          if (hasattr(self.handlePlot_div, method)):
            method2call = getattr(self.handlePlot_div, method)
            method2call(value)
            updateFlag = True
            # special treatment for capstyle
            if((key == 'dash_capstyle') and (hasattr(self.handlePlot_div, 'set_solid_capstyle'))):
              method2call = getattr(self.handlePlot_div, 'set_solid_capstyle')
              method2call(value)
      else:
        # prevent update of plot
        changed = False

      if(redraw and self.visibility and updateFlag):
        self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)
    
  def updateFunc(self, funcstr_base, ffunc_header, testParam=[]):
    try:
      funcstr = 'def ffunc(self, x' + ffunc_header + '):\n' + funcstr_base + '\n\treturn y'
      # generate ffunc in global namespace (this is needed for Python3 vs. Python2, bummer)
      namespace = self.mySpace
      exec(funcstr, namespace)
      # we need to do some initial test to see whether the function can be called
      if(len(testParam)):
        # determine x-range over which function will be applied => we should test this
        xmin, xmax = self.parent.plotArea.minX, self.parent.plotArea.maxX
        if(self.parent.plotArea.modeX == 'linear'):
          testRange = np.linspace(xmin, xmax, self.parent.plotArea.DATAPOINTS_SIMULATION)
        elif(self.parent.plotArea.modeX == 'log'):
          testRange = np.linspace(np.log(xmin), np.log(xmax), self.parent.plotArea.DATAPOINTS_SIMULATION)
          testRange = np.exp(testRange)
        # call function for test purposes
        retv = namespace['ffunc'](self, testRange, *testParam)
        # check for dimension mismatch
        if(retv.shape != testRange.shape):
          # we found some mismatch b/w x and y -- raise error to prevent program crash
          raise ValueError
      # now define the new function in the object scope
      setattr(FitObject, 'ffunc', namespace['ffunc'])
      self.funcstr_base = funcstr_base
      self.ffunc_header = ffunc_header
      return True
    except:
      return False

  def updateXY(self, x=[], y=[], splitX=False):
    # called by global fit to update fit curve
    if((len(x)) and (len(y))):
      if(splitX):
        self.x_div, self.y_div = x, y
      else:
        self.x, self.y = x, y

  def updateChiSquare(self, chisquare, red_chisquare):
    self.chisq, self.redchisq = chisquare, red_chisquare

  def updateParam(self, param=[]):
    self.param = param

  def updateParamSelect(self, names=[], values=[]):
    # called by global fit to update parameters
    updated = False
    paramActiveNames = [i for i, j in zip(self.paramNames, self.active) if j]
    for index, entry in enumerate(names):
      if(entry in self.paramNames):
        updated = True
        self.paramAll[self.paramNames.index(entry)] = values[index]
      if(entry in paramActiveNames):
        self.param[paramActiveNames.index(entry)] = values[index]
    
    # reset all confidences and a priori confidences to '--'
    if(updated):
      self.confidence = ['--'] * len(self.param)
      self.confidence_apriori = ['--'] * len(self.param)
    
  def evaluateFunc(self, x=np.array([]), param=[]):
    # evaluate function for a given param array
    if(len(param) == 0):
      param = self.param
    if(not self.retired):
      # evaluate function
      try:
        retv = self.ffunc(x, *param)
      except:
        # some kind of function problem, return empty array
        # for the future: could do this for each data point individually
        retv = np.array([0 for i in x])

    return x, retv

  def simulateFunc(self, x=np.array([]), splitX=False):
    # is this function still active?
    if(splitX):
      if(not self.retired):
        # check for empty x and, if so, use existing self.x
        if(not x.size):
          x = self.x_div
        # evaluate function
        try:
          retv = self.ffunc(x, *self.param)
        except:
          # some kind of function problem, return empty array
          # for the future: could do this for each data point individually
          retv = np.array([0 for i in x])
          
        # store results for future use
        self.x_div, self.y_div = x, retv
      
      # implement check for size -- if mismatch then better return x/y for principal axis
      if((self.x_div.size > 0) and (self.x_div.size == self.y_div.size)):
        return self.x_div, self.y_div
      else:
        return self.x, self.y
    else:
      if(not self.retired):
        # check for empty x and, if so, use existing self.x
        if(not x.size):
          x = self.x
        # evaluate function
        try:
          retv = self.ffunc(x, *self.param)
        except:
          # some kind of function problem, return empty array
          # for the future: could do this for each data point individually
          retv = np.array([0 for i in x])
          
        # store results for future use
        self.x, self.y = x, retv
      
      return self.x, self.y
    
  def fitFunc(self, data={}, initpa=[]):
    # check if ffunc is defined
    if (hasattr(FitObject, 'ffunc')):
      if (('x' in data) and ('y' in data)):
        # prepare fit
        maxfev = 100000
        # assign and check y error
        if('yerr' in data):
          sigma = data['yerr']
          sigma = [i if(i>0) else self.EPSILON for i in sigma]
        else:
          sigma = [1]*len(data['y'])
          
        if(not len(initpa)):
          initpa = self.param
          
        # do the actual fit
        if('xerr' in data):
          try:
            # generate wrapper function to refactor x and param vectors
            def odrWrapper(param, x):
              return self.ffunc(x, *param)
            # populate x errors
            sigmaX = data['xerr']
            sigmaX = [i if(i>0) else self.EPSILON for i in sigmaX]
            # call odr
            odrData = odr.RealData(data['x'], data['y'], sigmaX, sigma)
            odrModel = odr.Model(odrWrapper)
            odrODR = odr.ODR(odrData, odrModel, beta0=initpa)
            odrODR.set_job(fit_type=2)
            odrOut = odrODR.run()
            fitpa, covar = odrOut.beta, odrOut.cov_beta
          except:
            # catch all kind of fit problems
            fitpa = initpa
            covar = np.zeros((len(fitpa), len(fitpa)))
        else:
          try:
            fitpa, covar = optim.curve_fit(self.ffunc, data['x'], data['y'], initpa, sigma, maxfev=maxfev)#, method='lm')
          except:
            # catch all kind of fit problems
            fitpa = initpa
            covar = np.zeros((len(fitpa), len(fitpa)))

        # update parameters
        self.param = fitpa

        return True, fitpa, covar
      else:
        return False, [], []
    else:
      self.parent.statusbar.showMessage('No fit function defined!', self.parent.STATUS_TIME)
      return False, [], []

# the extras object is used to draw annotation and text on the canvas
class ExtrasObject(object):
  def __init__(self, parent=None):
    self.parent = parent
    self.parent.zcount += 1
    self.zorder = self.parent.zcount
    self.onSecondAxes = False

    self.name = ''
    self.visibility = True
    self.handle = None
    self.handle_div = None
    self.extrasType = 'text'
    self.x, self.y = 1, 1
    self.labeltext = 'text'
    self.color = [0.0, 0.0, 0.0, 1.0]
    self.fontsize = 12.0
    self.fontname = 'DejaVu Sans'
    self.rotation = 0.0
    self.horizontalalignment = 'center'
    self.verticalalignment = 'center'
    self.fontweight = 'normal'
    self.fontstyle = 'normal'
    
    self.arrow__x, self.arrow__y = 2, 2
    self.arrow__arrowstyle = '->'
    self.arrow__head_length, self.arrow__head_width, self.arrow__tail_width = 0.4, 0.4, 0.2
    self.arrow__facecolor, self.arrow__edgecolor = [1.0, 1.0, 1.0, 0.7], [0.0, 0.0, 0.0, 1.0]
    self.arrow__linewidth, self.arrow__linestyle, self.arrow__dash_capstyle = 1.0, 'solid', 'butt'
    self.arrow__shrinkA, self.arrow__shrinkB = 5, 5
    self.arrow__lengthA, self.arrow__lengthB = 0.5, 0.5
    self.arrow__widthA, self.arrow__widthB = 0.5, 0.5
    self.arrow__connector = 'arc3'
    self.arrow__hatch = ''
    self.arrow__hatchMultiply = 1
    self.arrow__doFill = True
    
    self.bbox__show = True
    self.bbox__boxstyle = 'square'
    self.bbox__facecolor, self.bbox__edgecolor = [1.0, 1.0, 1.0, 0.7], [0.0, 0.0, 0.0, 1.0]
    self.bbox__linewidth, self.bbox__linestyle, self.bbox__dash_capstyle = 1.0, 'solid', 'butt'
    self.bbox__pad = 0.5
    self.bbox__hatch = ''
    self.bbox__hatchMultiply = 1
    self.bbox__tooth_size, self.bbox__rounding_size = 0.5, 0.5
    self.bbox__doFill = True
    
    self.x2, self.y2 = self.arrow__x, self.arrow__y
    self.line__linewidth = 1.0
    self.line__linestyle = 'solid'
    self.line__dash_capstyle = 'butt'
    self.line__solid_capstyle = 'butt'
    self.line__color = self.color

    self.shape__type = 'rect'
    self.shape__facecolor = [1.0, 1.0, 1.0, 1.0]
    self.shape__hatch = ''
    self.shape__hatchMultiply = 1
    self.shape__numSpokes = 5
    self.shape__spikiness = 0.6
    self.shape__doFill = True
    
    # store information for graphics export as Python script
    self.rememberSetting = {}
    
    # extra handle for drawing line when interactively modifying annotation object
    self.handleMarkerLine = None

  def reportState(self):
    # reports data content for saveState function
    items = 'name,zorder,extrasType,x,y,labeltext,color,fontsize,fontname,rotation,horizontalalignment,verticalalignment,fontweight,fontstyle'
    items += ',arrow__x,arrow__y,arrow__facecolor,arrow__edgecolor,arrow__linewidth,arrow__linestyle'
    items += ',arrow__shrinkA,arrow__shrinkB,arrow__arrowstyle,arrow__dash_capstyle,arrow__connector,arrow__hatch,arrow__hatchMulitply,arrow__doFill'
    items += ',arrow__lengthA,arrow__lengthB,arrow__widthA,arrow__widthB'
    items += ',bbox__show,bbox__boxstyle,bbox__facecolor,bbox__edgecolor'
    items += ',bbox__linewidth,bbox__linestyle,bbox__dash_capstyle,bbox__pad,bbox__hatch,bbox__hatchMultiply,bbox__tooth_size,bbox__rounding_size,bbox__doFill'
    items += ',x2,y2,line__linewidth,line__linestyle,line__dash_capstyle,line__solid_capstyle,line__color'
    items += ',shape__type,shape__facecolor,shape__hatch,shape__hatchMultiply,shape__numSpokes,shape__spikiness,shape__doFill,onSecondAxes'
    items = items.split(',')
    retv = {}
    
    for entry in items:
      if(hasattr(self, entry)):
        value = self.__dict__[entry]
        if(type(value) == type(np.array([]))):
          value = value.tolist()
        retv[entry] = value
    
    return retv

  def restoreState(self, data={}, zoffset=0):
    # restores data content for loadState function
    for entry in data:
      if(hasattr(self, entry)):
        if(entry == 'zorder'):
          value = data[entry] + zoffset
        else:
          value = data[entry]
        self.__dict__[entry] = value

  def drawMe(self, redraw=True):
    # delete previous object if present
    if(self.handle != None):
      self.handle.remove()
    if(self.handle_div != None):
      self.handle_div.remove()
      
    # determine which axes to draw on
    if(self.onSecondAxes):
      useAxes, useAxes2 = self.parent.plotArea.ax2, self.parent.plotArea.ax2_div
    else:
      useAxes, useAxes2 = self.parent.plotArea.ax, self.parent.plotArea.ax_div
        
    # treat lines differently
    if(self.extrasType == 'line'):
      self.handle, = useAxes.plot([self.x, self.x2], [self.y, self.y2])
      self.handle.set_pickradius(PICK_TOLERANCE)
      self.handle.set_marker('None')
      self.handle_div, = useAxes2.plot([self.x, self.x2], [self.y, self.y2])
      self.handle_div.set_marker('None')
      
      # remember settings
      self.rememberSetting['origin_before'] = ''
      self.rememberSetting['origin'] = 'plot([' + repr(self.x) + ', ' + repr(self.arrow__x) + '], [' 
      self.rememberSetting['origin'] += repr(self.y) + ', ' + repr(self.arrow__y) + '])'
      self.rememberSetting['marker'] = 'set_marker(\'None\')'
      
      # apply styles
      for entry in ['linewidth', 'linestyle', 'color', 'dash_capstyle', 'solid_capstyle']:
        if(hasattr(self.handle, 'set_' + entry)):
          method2call = getattr(self.handle, 'set_' + entry)
          method2call(self.__dict__['line__' + entry])
          self.rememberSetting[entry] = 'set_' + entry + '(' + repr(self.__dict__['line__' + entry]) + ')'
        if(hasattr(self.handle_div, 'set_' + entry)):
          method2call = getattr(self.handle_div, 'set_' + entry)
          method2call(self.__dict__['line__' + entry])
      # treat z order separately
      self.handle.set_zorder(self.zorder + self.parent.zOffset)
      self.handle_div.set_zorder(self.zorder + self.parent.zOffset)
      self.rememberSetting['zorder'] = 'set_zorder(' + repr(self.zorder + self.parent.zOffset) + ')'

      if(redraw):
        self.parent.plotArea.dataplotwidget.myRefresh()
    elif(self.extrasType == 'shape'):
      # generate shape
      if(self.shape__type == 'rect'):
        useX, useY = self.x - self.x2 / 2.0, self.y - self.y2 / 2.0
        useWidth, useHeight = self.x2, self.y2
        # generate default rectangle
        extraPatch = matplotlib.patches.Rectangle(xy=(-0.5, -0.5), width=1.0, height=1.0)
        extraPatch2 = matplotlib.patches.Rectangle(xy=(-0.5, -0.5), width=1.0, height=1.0)
        # apply transforms (needed b/c rectangle rotates around bottom left corner, not center)
        transform, transform2 = self.masterTransform(useX, useY, useWidth, useHeight)
        extraPatch.set_transform(transform)
        extraPatch2.set_transform(transform2)
        # remember settings
        self.rememberSetting['origin_before'] = 'extraTransform = matplotlib.transforms.Affine2D().scale(sx=' + repr(useWidth) + ', sy=' + repr(useHeight) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().rotate_deg(' + repr(self.rotation) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useWidth / 2.0) + ', ty=' + repr(useHeight / 2.0) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useX) + ', ty=' + repr(useY) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += ax.transData\n'
        self.rememberSetting['origin_before'] += 'extraPatch = matplotlib.patches.Rectangle(xy=(-0.5, -0.5), width=1.0, height=1.0)\n'
        self.rememberSetting['origin_before'] += 'extraPatch.set_transform(extraTransform)'
        self.rememberSetting['origin'] = 'add_patch(extraPatch)' 
      elif(self.shape__type == 'circle'):
        useX, useY = self.x, self.y
        useWidth, useHeight = self.x2, self.y2
        extraPatch = matplotlib.patches.Ellipse(xy=(useX, useY), width=useWidth, height=useHeight, angle=self.rotation)
        extraPatch2 = matplotlib.patches.Ellipse(xy=(useX, useY), width=useWidth, height=useHeight, angle=self.rotation)
        # remember settings
        self.rememberSetting['origin_before'] = 'extraPatch = matplotlib.patches.Ellipse(xy=(' + repr(useX) + ', ' + repr(useY) + '), width=' + repr(useWidth)
        self.rememberSetting['origin_before'] += ', height=' + repr(useHeight) + ', angle=' + repr(self.rotation) + ')'
        self.rememberSetting['origin'] = 'add_patch(extraPatch)' 
      elif(self.shape__type == 'poly'):
        useX, useY = self.x, self.y
        useWidth, useHeight = self.x2, self.y2
        # generate regular polygon
        extraPatch = matplotlib.patches.RegularPolygon(xy=(-0.5, -0.5), numVertices=self.shape__numSpokes, radius=0.5)
        extraPatch2 = matplotlib.patches.RegularPolygon(xy=(-0.5, -0.5), numVertices=self.shape__numSpokes, radius=0.5)
        # apply transforms
        transform, transform2 = self.masterTransform(useX, useY, useWidth, useHeight)
        extraPatch.set_transform(transform)
        extraPatch2.set_transform(transform2)
        # remember settings
        self.rememberSetting['origin_before'] = 'extraTransform = matplotlib.transforms.Affine2D().scale(sx=' + repr(useWidth) + ', sy=' + repr(useHeight) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useWidth / 2.0) + ', ty=' + repr(useHeight / 2.0) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().rotate_deg(' + repr(self.rotation) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useX) + ', ty=' + repr(useY) + ')\n'
        self.rememberSetting['origin_before'] += 'extraTransform += ax.transData\n'
        self.rememberSetting['origin_before'] += 'extraPatch = matplotlib.patches.RegularPolygon(xy=(-0.5, -0.5), numVertices=' + repr(self.shape__numSpokes) + ', radius=0.5)\n'
        self.rememberSetting['origin_before'] += 'extraPatch.set_transform(extraTransform)'
        self.rememberSetting['origin'] = 'add_patch(extraPatch)' 
      else:
        # use star shape as default
        useX, useY = self.x, self.y
        useWidth, useHeight = self.x2, self.y2
        extraPatch = self.pointyStar(xy=(-0.5, -0.5), numVertices=self.shape__numSpokes, radius=0.5, ratio=self.shape__spikiness)
        extraPatch2 = self.pointyStar(xy=(-0.5, -0.5), numVertices=self.shape__numSpokes, radius=0.5, ratio=self.shape__spikiness)
        if(extraPatch != None):
          # apply transforms
          transform, transform2 = self.masterTransform(useX, useY, useWidth, useHeight)
          extraPatch.set_transform(transform)
          extraPatch2.set_transform(transform2)

          # remember settings
          self.rememberSetting['origin_before'] += 'extraTransform = matplotlib.transforms.Affine2D().scale(sx=' + repr(useWidth) + ', sy=' + repr(useHeight) + ')\n'
          self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().rotate_deg(' + repr(self.rotation) + ')\n'
          self.rememberSetting['origin_before'] += 'extraTransform += matplotlib.transforms.Affine2D().translate(tx=' + repr(useX) + ', ty=' + repr(useY) + ')\n'
          self.rememberSetting['origin_before'] += 'extraTransform += ax.transData\n'
          self.rememberSetting['origin_before'] += 'extraPatch.set_transform(extraTransform)'
          self.rememberSetting['origin'] = 'add_patch(extraPatch)' 
      
      if(extraPatch != None):
        self.handle = useAxes.add_patch(extraPatch)
      if(extraPatch2 != None):
        self.handle_div = useAxes2.add_patch(extraPatch2)
      
      # apply line styles
      for entry in ['linewidth', 'linestyle', 'color', 'capstyle', 'solid_capstyle']:
        if(hasattr(self.handle, 'set_' + entry)):
          method2call = getattr(self.handle, 'set_' + entry)
          if(entry == 'capstyle'):
            method2call(self.__dict__['line__dash_capstyle'])
            self.rememberSetting[entry] = 'set_capstyle(' + repr(self.__dict__['line__dash_capstyle']) + ')'
          else:
            method2call(self.__dict__['line__' + entry])
            self.rememberSetting[entry] = 'set_' + entry + '(' + repr(self.__dict__['line__' + entry]) + ')'
        if(hasattr(self.handle_div, 'set_' + entry)):
          method2call = getattr(self.handle_div, 'set_' + entry)
          if(entry == 'capstyle'):
            method2call(self.__dict__['line__dash_capstyle'])
          else:
            method2call(self.__dict__['line__' + entry])

      # apply fill styles
      for entry in ['hatch', 'facecolor']:
        if(hasattr(self.handle, 'set_' + entry)):
          method2call = getattr(self.handle, 'set_' + entry)
          if(entry == 'hatch'):
            hatchString = self.shape__hatch * self.shape__hatchMultiply
            method2call(hatchString)
            self.rememberSetting[entry] = 'set_hatch(' + repr(hatchString) + ')'
          else:
            method2call(self.__dict__['shape__' + entry])
            self.rememberSetting[entry] = 'set_' + entry + '(' + repr(self.__dict__['shape__' + entry]) + ')'
        if(hasattr(self.handle_div, 'set_' + entry)):
          method2call = getattr(self.handle_div, 'set_' + entry)
          if(entry == 'hatch'):
            hatchString = self.shape__hatch * self.shape__hatchMultiply
            method2call(hatchString)
          else:
            method2call(self.__dict__['shape__' + entry])
            
      # check whether to fill shape
      if(not self.shape__doFill):
        self.handle.set_facecolor('none')
        self.handle_div.set_facecolor('none')

      # treat z order separately
      self.handle.set_zorder(self.zorder + self.parent.zOffset)
      self.handle_div.set_zorder(self.zorder + self.parent.zOffset)
      self.rememberSetting['zorder'] = 'set_zorder(' + repr(self.zorder + self.parent.zOffset) + ')'

      if(redraw):
        self.parent.plotArea.dataplotwidget.myRefresh()
    else:
      # prepare bbox
      if(self.bbox__show):
        if(self.bbox__hatch == ''):
          hatchString = self.bbox__hatch
        else:
          hatchString = self.bbox__hatch * self.bbox__hatchMultiply
        # implement check to account for different bbox styles on different operating systems
        availableBoxStyles = list(matplotlib.patches.BoxStyle.get_styles().keys())
        if(not(self.bbox__boxstyle in availableBoxStyles)):
          self.bbox__boxstyle = 'square'
        
        # check whether to fill box
        if(self.bbox__doFill):
          useFaceColor = self.bbox__facecolor
        else:
          useFaceColor = 'none'
        # need to implement pad and rounding_size and tooth_size
        bboxProps = {'boxstyle': self.bbox__boxstyle, 'facecolor': useFaceColor, 'edgecolor': self.bbox__edgecolor,\
                     'linewidth': self.bbox__linewidth, 'linestyle': self.bbox__linestyle, 'hatch': hatchString, 'capstyle': self.bbox__dash_capstyle}
        #bboxProps['pad'] = self.bbox__pad  # this effing will not work under Linux
        bboxProps['boxstyle'] = bboxProps['boxstyle'] + ',pad=' + str(self.bbox__pad)  # this will work under Linux as well
      # causes extras to be drawn on canvas
      if(self.extrasType == 'text'):
        if(self.bbox__show):
          self.handle = useAxes.text(self.x, self.y, self.labeltext, bbox=bboxProps)
          self.handle_div = useAxes2.text(self.x, self.y, self.labeltext, bbox=bboxProps)
          # apply bbox properties post creation
          styleObject = self.handle.get_bbox_patch().get_boxstyle()
          boxstyleExtension = ''
          for entry in ['tooth_size', 'rounding_size', 'pad']:
            if(hasattr(styleObject, entry)):
              boxstyleExtension += ',' + entry + '=' + str(self.__dict__['bbox__' + entry])
          bboxProps['boxstyle'] = self.bbox__boxstyle + boxstyleExtension
          self.handle.get_bbox_patch().set_boxstyle(bboxProps['boxstyle'])
          # remember settings
          self.rememberSetting['origin_before'] = ''
          self.rememberSetting['origin'] = 'text(' + repr(self.x) + ', ' + repr(self.y) + ', ' + repr(self.labeltext)
          self.rememberSetting['origin'] += ', bbox=' + repr(bboxProps) + ')'
          # and do this for handle_div
          self.handle_div.get_bbox_patch().set_boxstyle(bboxProps['boxstyle'])
        else:
          self.handle = useAxes.text(self.x, self.y, self.labeltext)
          self.handle_div = useAxes2.text(self.x, self.y, self.labeltext)
          self.rememberSetting['origin'] = 'text(' + repr(self.x) + ', ' + repr(self.y) + ', ' + repr(self.labeltext) + ')'
      else:
        # implement check for quadratic connector
        safeConnector = 'arc3'
        if(self.arrow__arrowstyle in ['fancy', 'simple', 'wedge']):
          if(not(self.arrow__connector in ['arc3', 'angle3'])):
            self.parent.statusbar.showMessage('Connector style ' + self.arrow__connector + ' incompatible with ' + self.arrow__arrowstyle + '. Reverting to ' + safeConnector + '!', self.parent.STATUS_TIME)
            self.arrow__connector = safeConnector
  
        # check whether to fill arrow
        if(self.arrow__doFill):
          useFaceColor = self.arrow__facecolor
        else:
          useFaceColor = 'none'
        # draw annotation (unfortunately, matplotlib hard-codes 'round' capstyle, so this setting won't do anything)
        arrowProps = {'facecolor': useFaceColor, 'arrowstyle': self.arrow__arrowstyle,\
                      'edgecolor': self.arrow__edgecolor, 'linewidth': self.arrow__linewidth, 'linestyle': self.arrow__linestyle,\
                      'capstyle': self.arrow__dash_capstyle, 'shrinkA': self.arrow__shrinkA, 'shrinkB': self.arrow__shrinkB,\
                      'connectionstyle': self.arrow__connector}#, 'head_length': self.arrow__head_length}
        if(self.bbox__show):
          self.handle = useAxes.annotate(self.labeltext, xytext=(self.x, self.y), xy=(self.arrow__x, self.arrow__y), arrowprops=arrowProps, bbox=bboxProps)
          self.handle_div = useAxes2.annotate(self.labeltext, xytext=(self.x, self.y), xy=(self.arrow__x, self.arrow__y), arrowprops=arrowProps, bbox=bboxProps)
          # apply bbox properties post creation
          styleObject = self.handle.get_bbox_patch().get_boxstyle()
          boxstyleExtension = ''
          for entry in ['tooth_size', 'rounding_size', 'pad']:
            if(hasattr(styleObject, entry)):
              boxstyleExtension += ',' + entry + '=' + str(self.__dict__['bbox__' + entry])
          bboxProps['boxstyle'] = self.bbox__boxstyle + boxstyleExtension
          self.handle.get_bbox_patch().set_boxstyle(bboxProps['boxstyle'])
          self.handle_div.get_bbox_patch().set_boxstyle(bboxProps['boxstyle'])
        else:
          self.handle = useAxes.annotate(self.labeltext, xytext=(self.x, self.y), xy=(self.arrow__x, self.arrow__y), arrowprops=arrowProps)
          self.handle_div = useAxes2.annotate(self.labeltext, xytext=(self.x, self.y), xy=(self.arrow__x, self.arrow__y), arrowprops=arrowProps)
        
        # apply properties to annotation
        if(self.arrow__hatch == ''):
          hatchString = self.arrow__hatch
        else:
          hatchString = self.arrow__hatch * self.arrow__hatchMultiply
        self.handle.arrow_patch.set_hatch(hatchString)
        self.handle_div.arrow_patch.set_hatch(hatchString)
        self.rememberSetting['hatch'] = 'arrow_patch.set_hatch(' + repr(hatchString) + ')'
        
        # apply arrow properties post creation
        goodProperties = []
        styleObject = self.handle.arrow_patch.get_arrowstyle()
        self.arrow__head_width, self.arrow__head_length = self.arrow__widthB, self.arrow__lengthB
        self.arrow__tail_width = self.arrow__widthA
        properties = 'arrow__lengthA,arrow__lengthB,arrow__widthA,arrow__widthB,arrow__head_width,arrow__head_length,arrow__tail_width'
        for entry in properties.split(','):
          workArrowStyle = self.arrow__arrowstyle
          currProp = entry.split('__')[-1]
          if(hasattr(styleObject, currProp)):
            workArrowStyle += ', ' + currProp + '=' + str(self.__dict__[entry])
            # try setting this property to thus check wether current style accepts it (this is really ugly but matplotlib wants it like this, grrrrrrrrr)
            try:
              self.handle.arrow_patch.set_arrowstyle(workArrowStyle)
              self.handle_div.arrow_patch.set_arrowstyle(workArrowStyle)
              goodProperties.append(entry)
            except:
              # suck it up and do nothing
              pass
        # check whether any property survived
        if(len(goodProperties)):
          workArrowStyle = self.arrow__arrowstyle
          for entry in goodProperties:
            currProp = entry.split('__')[-1]
            workArrowStyle += ', ' + currProp + '=' + str(self.__dict__[entry])
          # throw in another try for safety's measure
          try:
            self.handle.arrow_patch.set_arrowstyle(workArrowStyle)
            self.handle_div.arrow_patch.set_arrowstyle(workArrowStyle)
          except:
            pass
          # remember this
          self.rememberSetting['arrowstyle'] = 'arrow_patch.set_arrowstyle(' + repr(workArrowStyle) + ')'
        elif('arrowstyle' in self.rememberSetting):
          # delete key from dict
          self.rememberSetting.pop('arrowstyle', None)
          
        # now remember all this
        self.rememberSetting['origin_before'] = ''
        self.rememberSetting['origin'] = 'annotate(' + repr(self.labeltext) + ', xytext=(' + repr(self.x) + ', ' + repr(self.y) + ')'
        self.rememberSetting['origin'] += ', xy=(' + repr(self.arrow__x) + ', ' + repr(self.arrow__y) + '), arrowprops=' + repr(arrowProps)
        if(self.bbox__show):
          self.rememberSetting['origin'] += ', bbox=' + repr(bboxProps) + ')'
        else:
          self.rememberSetting['origin'] += ')'
  
      # set visibility
      if (self.handle != None):
        self.handle.set_visible(self.visibility)
        self.rememberSetting['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
        
        styleItems = 'color,fontsize,fontname,rotation,horizontalalignment,verticalalignment,fontweight,fontstyle'.split(',')
        for entry in styleItems:
          if((hasattr(self.handle, 'set_' + entry)) and (hasattr(self, entry))):
            method2call = getattr(self.handle, 'set_' + entry)
            method2call(self.__dict__[entry])
            self.rememberSetting[entry] = 'set_' + entry + '(' + repr(self.__dict__[entry]) + ')'
          if((self.handle_div != None) and (hasattr(self.handle_div, 'set_' + entry)) and (hasattr(self, entry))):
            method2call = getattr(self.handle_div, 'set_' + entry)
            method2call(self.__dict__[entry])
        
        # treat z order separately
        self.handle.set_zorder(self.zorder + self.parent.zOffset)
        self.rememberSetting['zorder'] = 'set_zorder(' + repr(self.zorder + self.parent.zOffset) + ')'
        if(self.handle_div != None):
          self.handle_div.set_visible(self.visibility)
          self.handle_div.set_zorder(self.zorder + self.parent.zOffset)
  
        # process text and check for bad math text
        try:
          self.handle._get_layout(self.parent.plotArea.matplot.canvas.renderer)
          if(self.handle_div != None):
            self.handle_div._get_layout(self.parent.plotArea.matplot.canvas.renderer)
        except:
          self.parent.statusbar.showMessage('Problems setting label to ' + self.labeltext + '!', self.parent.STATUS_TIME)
          self.labeltext = self.labeltext.replace('$', '')
        
        self.labeltext = self.labeltext.replace('\n', '\\n')
        self.labeltext = self.labeltext.replace('\t', '\\t')
        self.labeltext = '\n'.join([i for i in self.labeltext.split('\\n') if (len(i.strip()))])
        self.labeltext = '\t'.join([i for i in self.labeltext.split('\\t') if (len(i.strip()))])
        self.handle.set_text(self.labeltext)
        if(self.handle_div != None):
          self.handle_div.set_text(self.labeltext)
  
        # need to implement extra check for fontname due to erroneous fonts
        try:
          if(redraw):
            self.parent.plotArea.dataplotwidget.myRefresh()
        except:
          safeFont = 'DejaVu Sans'
          self.parent.statusbar.showMessage('Experiencing problems with font ' + self.fontname + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.fontname = safeFont
          self.handle.set_fontname(safeFont)
          if(self.handle_div != None):
            self.handle_div.set_fontname(safeFont)
  
          if(redraw):
            self.parent.plotArea.dataplotwidget.myRefresh()
        
        # adjust remember settings
        self.rememberSetting['text'] = 'set_text(' + repr(self.labeltext) + ')'
        self.rememberSetting['fontname'] = 'set_fontname(' + repr(self.fontname) + ')'

  def masterTransform(self, useX, useY, useWidth, useHeight):
    # helper function that calculates transforms for extras object
    # needed to outsource it to here as also required by updateMe()
    if(self.onSecondAxes):
      useAxes, useAxes2 = self.parent.plotArea.ax2, self.parent.plotArea.ax2_div
    else:
      useAxes, useAxes2 = self.parent.plotArea.ax, self.parent.plotArea.ax_div

    if(self.shape__type == 'rect'):
      # apply transforms (needed b/c rectangle rotates around bottom left corner, not center)
      transform = matplotlib.transforms.Affine2D().scale(sx=useWidth, sy=useHeight)
      transform += matplotlib.transforms.Affine2D().rotate_deg(self.rotation)
      transform += matplotlib.transforms.Affine2D().translate(tx=useWidth / 2.0, ty=useHeight / 2.0)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX, ty=useY)
    elif(self.shape__type == 'circle'):
      # return matrix for circle (first return to origin before scaling)
      transform = matplotlib.transforms.Affine2D().translate(tx=-self.x, ty=-self.y)
      transform += matplotlib.transforms.Affine2D().scale(sx=useWidth, sy=useHeight)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX + self.x, ty=useY + self.y)
    elif(self.shape__type == 'poly'):
      # transformation for polygon
      transform = matplotlib.transforms.Affine2D().scale(sx=useWidth, sy=useHeight)
      transform += matplotlib.transforms.Affine2D().translate(tx=useWidth / 2.0, ty=useHeight / 2.0)
      transform += matplotlib.transforms.Affine2D().rotate_deg(self.rotation)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX, ty=useY)
    else:
      # use star shape as default
      transform = matplotlib.transforms.Affine2D().scale(sx=useWidth, sy=useHeight)
      transform += matplotlib.transforms.Affine2D().rotate_deg(self.rotation)
      transform += matplotlib.transforms.Affine2D().translate(tx=useX, ty=useY)

    transform2 = transform + useAxes2.transData
    transform += useAxes.transData

    return transform, transform2

  def pointyStar(self, xy=(0, 0), numVertices=5, radius=1, ratio=0.7):
    # draws a pointy star with arbitrary spokes
    if(numVertices > 2):
      # calculate the coords
      coords = []
      angles = np.linspace(0, 2.0 * np.pi, numVertices + 1)
      for index, entry in enumerate(angles):
        coords.append([radius * np.sin(entry), radius * np.cos(entry)])
        if(index < len(angles) - 1):
          coords.append([ratio * radius * np.sin((entry + angles[index + 1]) / 2.0), ratio * radius * np.cos((entry + angles[index + 1]) / 2.0)])
        
      # remember setting
      self.rememberSetting['origin_before'] = 'extraPatch = matplotlib.patches.Polygon(xy=' + repr(coords) + ', closed=True)\n'
        
      # draw the shape
      extrasPatch = matplotlib.patches.Polygon(xy=coords, closed=True)
      return extrasPatch

    return None

  def setValues(self, valueDict, redraw=True):
    # sets values of the extras object
    tempRedraw = False
    if(type(valueDict) == type({})):
      keys = valueDict.keys()
      for entry in keys:
        if(hasattr(self, entry)):
          if(self.__dict__[entry] != valueDict[entry]):
            tempRedraw = True
          self.__dict__[entry] = valueDict[entry]
          
      if(redraw and tempRedraw):
        self.drawMe(redraw=redraw)

  def setSecondAxes(self, state=False, redraw=True):
    # moves extra between axes
    self.onSecondAxes = state
    # update plot
    self.drawMe(redraw=redraw)
          
  def setVisibility(self, state=True, redraw=True):
    # toggles visibility of extra
    self.visibility = state
    updateFlag = False
    if(self.handle != None):
      self.handle.set_visible(state)
      updateFlag = True
      # adjust remember settings
      self.rememberSetting['visible'] = 'set_visible(' + repr(state) + ')'
    if(self.handle_div != None):
      self.handle_div.set_visible(state)
      updateFlag = True

    # update plot
    if(redraw and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def spawned(self, source=None):
    # copies contents of the source object to current object
    if(source != None):
      copyItems = 'x,y,visibility,extrasType,labeltext,color,fontsize,fontname,rotation,horizontalalignment,verticalalignment,fontweight,fontstyle'
      copyItems += ',arrow__x,arrow__y,arrow__facecolor,arrow__edgecolor,arrow__linewidth,arrow__linestyle,arrow__dash_capstyle'
      copyItems += ',arrow__shrinkA,arrow__shrinkB,arrow__arrowstyle,arrow__connector,arrow__hatch,arrow__hatchMultiply,arrow__doFill'
      copyItems += ',arrow__lengthA,arrow__lengthB,arrow__widthA,arrow__widthB'
      copyItems += ',bbox__show,bbox__boxstyle,bbox__facecolor,bbox__edgecolor'
      copyItems += ',bbox__linewidth,bbox__linestyle,bbox__dash_capstyle,bbox__pad,bbox__hatch,bbox__hatchMultiply,bbox__tooth_size,bbox__rounding_size,bbox__doFill'
      copyItems += ',x2,y2,line__linewidth,line__linestyle,line__dash_capstyle,line__solid_capstyle,line__color'
      copyItems += ',shape__type,shape__facecolor,shape__hatch,shape__hatchMultiply,shape__numSpokes,shape__spikiness,shape__doFill,onSecondAxes'
      copyItems = copyItems.split(',')
      for item in copyItems:
        if(hasattr(source, item)):
          sourceItem = deepcopy(getattr(source, item))
          setattr(self, item, sourceItem)
          
  def getStyle(self):
    # returns as dictionary various style settings
    copyItems = 'x,y,visibility,extrasType,labeltext,color,fontsize,fontname,rotation,horizontalalignment,verticalalignment,fontweight,fontstyle'
    copyItems += ',arrow__x,arrow__y,arrow__facecolor,arrow__edgecolor,arrow__linewidth,arrow__linestyle,arrow__dash_capstyle'
    copyItems += ',arrow__shrinkA,arrow__shrinkB,arrow__arrowstyle,arrow__connector,arrow__hatch,arrow__hatchMultiply,arrow__doFill'
    copyItems += ',arrow__lengthA,arrow__lengthB,arrow__widthA,arrow__widthB'
    copyItems += ',bbox__show,bbox__boxstyle,bbox__facecolor,bbox__edgecolor'
    copyItems += ',bbox__linewidth,bbox__linestyle,bbox__dash_capstyle,bbox__pad,bbox__hatch,bbox__hatchMultiply,bbox__tooth_size,bbox__rounding_size,bbox__doFill'
    copyItems += ',x2,y2,line__linewidth,line__linestyle,line__dash_capstyle,line__solid_capstyle,line__color'
    copyItems += ',shape__type,shape__facecolor,shape__hatch,shape__hatchMultiply,shape__numSpokes,shape__spikiness,shape__doFill,onSecondAxes'
    copyItems = copyItems.split(',')
    style = {}
    for entry in copyItems:
      if(hasattr(self, entry)):
        style[entry] = self.__dict__[entry]
    
    return style

  def setStyle(self, key=None, value=0, redraw=True):
    # sets a style setting
    if(hasattr(self, key)):
      if(self.__dict__[key] == value):
        redraw = False
      self.__dict__[key] = value
      if(redraw):
        self.drawMe()

  def setZOrder(self, zorder=0, redraw=True):
    # updates z order
    self.zorder = zorder
    # update plot if necessary
    updateFlag = False
    if(self.handle != None):
      self.handle.set_zorder(self.zorder + self.parent.zOffset)
      updateFlag = True
    if(self.handle_div != None):
      self.handle_div.set_zorder(self.zorder + self.parent.zOffset)
      updateFlag = True

    # update plot
    if(redraw and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def updateMe(self, deltaX, deltaY, pickedAxes, pickedBackground, pickedMode=0, transient=True):
    # function called by interactive drag and resize
    if((pickedAxes != None) and (pickedBackground != None)):
      tempX, tempX2, tempY, tempY2 = self.x + deltaX, self.x2 + deltaX, self.y + deltaY, self.y2 + deltaY
      renderer = self.parent.plotArea.matplot.canvas.renderer
      
      # determine which axis we are on -- don't confuse second axis with div
      if(pickedAxes in (self.parent.plotArea.ax_div, self.parent.plotArea.ax2_div)):
        useHandle = self.handle_div
      else:
        useHandle = self.handle
      
      # restore background
      pickedAxes.figure.canvas.restore_region(pickedBackground)

      if(self.extrasType == 'line'):
        if(pickedMode):
          tempX, tempX2, tempY, tempY2 = self.x - deltaX / 2.0, self.x2 + deltaX / 2.0, self.y - deltaY / 2.0, self.y2 + deltaY / 2.0
  
        useHandle.set_xdata([tempX, tempX2])
        useHandle.set_ydata([tempY, tempY2])
  
        if(not transient):
          self.x, self.x2, self.y, self.y2 = tempX, tempX2, tempY, tempY2
      elif(self.extrasType == 'shape'):
        if(pickedMode):
          tempX, tempX2, tempY, tempY2 = self.x, self.x2 + deltaX, self.y, self.y2 + deltaY
        else:
          tempX, tempX2, tempY, tempY2 = self.x + deltaX, self.x2, self.y + deltaY, self.y2

        # here it will be better to go via set_transform
        if(self.shape__type == 'circle'):
          transform, transform2 = self.masterTransform(useX=tempX - self.x, useY=tempY - self.y, useWidth=tempX2 / self.x2, useHeight=tempY2 / self.y2)
        elif(self.shape__type == 'rect'):
          transform, transform2 = self.masterTransform(useX=tempX - self.x2 / 2.0, useY=tempY - self.y2 / 2.0, useWidth=tempX2, useHeight=tempY2)
        else:
          transform, transform2 = self.masterTransform(useX=tempX, useY=tempY, useWidth=tempX2, useHeight=tempY2)

        if(pickedAxes in (self.parent.plotArea.ax_div, self.parent.plotArea.ax2_div)):
          useHandle.set_transform(transform2)
        else:
          useHandle.set_transform(transform)

        if(not transient):
          if(pickedMode and (self.shape__type == 'rect')):
              self.x, self.x2, self.y, self.y2 = tempX - (self.x2 - tempX2) / 2.0, tempX2, tempY - (self.y2 - tempY2) / 2.0, tempY2
          else:
            self.x, self.x2, self.y, self.y2 = tempX, tempX2, tempY, tempY2
      elif(self.extrasType == 'text'):
        if(not pickedMode):
          useHandle.set_x(tempX)
          useHandle.set_y(tempY)
  
          if(not transient):
            self.x, self.y = tempX, tempY
      elif(self.extrasType == 'annotation'):
        if(pickedMode):
          tempX, tempX2, tempY, tempY2 = self.x, self.arrow__x + deltaX, self.y, self.arrow__y + deltaY
  
          # we need to generate a temp line here to serve as the marker for the interactive modification as the arrow object does not update
          if(self.handleMarkerLine == None):
            self.handleMarkerLine, = pickedAxes.plot([tempX, tempX2], [tempY, tempY2])
            self.handleMarkerLine.set_linestyle('solid')
            self.handleMarkerLine.set_linewidth(1)
            if(pickedAxes == self.parent.plotArea.ax_div):
              canvasColor = self.parent.plotArea.ax2_div.patch.get_facecolor()
            elif(pickedAxes == self.parent.plotArea.ax):
              canvasColor = self.parent.plotArea.ax2.patch.get_facecolor()
            else:
              canvasColor = pickedAxes.patch.get_facecolor()
            # we need this check to deal with canvas having 'none' facecolor
            if(np.isclose(sum(canvasColor), 0.0)):
              canvasColor = self.parent.plotArea.matplot.get_facecolor()
            if(sum(canvasColor[0:3]) < 1.5):
              self.handleMarkerLine.set_color('white')
            else:
              self.handleMarkerLine.set_color('black')
            self.handleMarkerLine.set_zorder(self.zorder + self.parent.zOffset + 0.1)
          else:
            self.handleMarkerLine.set_xdata([tempX, tempX2])
            self.handleMarkerLine.set_ydata([tempY, tempY2])
            
          self.handleMarkerLine.draw(renderer)
        else:
          tempX, tempX2, tempY, tempY2 = self.x + deltaX, self.arrow__x, self.y + deltaY, self.arrow__y
  
          useHandle.set_x(tempX)
          useHandle.set_y(tempY)
    
        if(not transient):
          self.x, self.arrow__x, self.y, self.arrow__y = tempX, tempX2, tempY, tempY2
          if(self.handleMarkerLine != None):
            if(hasattr(self.handleMarkerLine, 'remove')):
              self.handleMarkerLine.remove()
            self.handleMarkerLine = None

      # update object
      useHandle.draw(renderer)
    
      # and blit just the redrawn area
      pickedAxes.figure.canvas.blit(pickedAxes.bbox)
    
# the data object holds individual data sets
class DataObject(object):
  def __init__(self, parent=None):
    self.x = np.array([])
    self.y = np.array([])
    self.xerr = np.array([])
    self.yerr = np.array([])
    self.fval = np.array([])
    self.resid = np.array([])
    self.labels = []
    self.parent = parent
    self.parent.zcount += 1
    self.zorder = self.parent.zcount
    self.zorderResid = len(self.parent.data) + 2
    self.onSecondAxes = False
    
    # parameters for global fit
    self.globalFitCheck = True
    self.globalFitCurve = 0

    # initalize parameters
    self.initParam()
    
  def initParam(self):    
    # memorize plot formatting
    self.rememberSetting = {}
    self.rememberSettingError = {}
    self.rememberSettingErrorShady = {}
    self.rememberSettingBar = {}
    self.rememberSettingStack = {}
    self.rememberSettingStackNeg = {}
    self.rememberSettingResid = {}
    self.rememberSettingResidBar = {}
    self.rememberSettingResidStack = {}
    self.rememberSettingResidStackNeg = {}
    # initialize handles for graphics
    self.handleData = None
    self.handleErr = None
    self.handleBar = None
    self.handleStack = None
    self.handleStackNeg = None
    self.handleErrShady = None
    self.handleText = None
    self.handleViolin = None
    self.handleResid = None
    self.handleResidBar = None
    self.handleResidStack = None
    self.handleResidStackNeg = None
    self.handleResidText = None
    ##
    self.handleData_div = None
    self.handleErr_div = None
    self.handleBar_div = None
    self.handleStack_div = None
    self.handleStackNeg_div = None
    self.handleErrShady_div = None
    self.handleText_div = None
    self.handleViolin_div = None
    self.handleResid_div = None
    self.handleResidBar_div = None
    self.handleResidStack_div = None
    self.handleResidStackNeg_div = None
    self.handleResidText_div = None
    # initialize name
    self.setName('Data_' + str(len(self.parent.data)))
    self.setNameResid('Resid_' + str(len(self.parent.data)))
    # initialize visibility
    self.visibility = True
    self.visibilityResid = True
    # initalize style
    self.style = {}
    self.style['linewidth'] = 1.0
    self.style['linestyle'] = 'None'
    self.style['dash_capstyle'] = 'butt'
    #self.style['solid_capstyle'] = 'butt'
    self.style['color'] = [0.89, 0.29, 0.2, 1.0]
    self.style['markerfacecolor'] = [0.89, 0.29, 0.2, 1.0]
    self.style['markerfacecoloralt'] = [0.0, 0.0, 0.0, 1.0]
    self.style['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
    self.style['markeredgewidth'] = 1.0
    self.style['markersize'] = 14.0
    self.style['marker'] = 'o'
    self.style['fillstyle'] = 'full'
    self.style['markevery'] = 1
    self.style['doFill'] = True
    
    # intialize error style
    self.Errorstyle = {}
    self.Errorstyle['color'] = [0.89, 0.29, 0.2, 1.0]
    self.Errorstyle['linewidth'] = 1.0
    self.Errorstyle['linestyle'] = 'solid'
    self.Errorstyle['marker'] = '_'
    self.Errorstyle['markerX'] = '|'
    self.Errorstyle['markerfacecolor'] = [0.89, 0.29, 0.2, 1.0]
    self.Errorstyle['markerfacecoloralt'] = [0.0, 0.0, 0.0, 1.0]
    self.Errorstyle['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
    self.Errorstyle['markeredgewidth'] = 1.0
    self.Errorstyle['markersize'] = 14.0
    self.Errorstyle['fillstyle'] = 'full'
    self.Errorstyle['doFill'] = True
    self.Errorstyle['errorInFront'] = False
    self.Errorstyle['visible'] = True
    self.Errorstyle['direction'] = 'both'
    
    # intialize error shading style
    self.ErrorShadystyle = {}
    self.ErrorShadystyle['visible'] = False
    self.ErrorShadystyle['facecolor'] = [0.8, 0.2, 0.2, 0.5]
    self.ErrorShadystyle['edgecolor'] = [0.8, 0.2, 0.2, 1.0]
    self.ErrorShadystyle['linestyle'] = 'solid'
    self.ErrorShadystyle['linewidth'] = 0.0
    
    # initialize bar style
    self.Barstyle = {}
    self.Barstyle['showBar'] = False
    self.Barstyle['linewidth'] = 0.5
    self.Barstyle['linestyle'] = 'solid'
    self.Barstyle['capstyle'] = 'butt'
    self.Barstyle['facecolor'] = [0.8, 0.2, 0.2, 1.0]
    self.Barstyle['facecolorAlt'] = [0.3, 0.2, 0.6, 1.0]
    self.Barstyle['edgecolor'] = [0.3, 0.3, 0.3, 1.0]
    self.Barstyle['width'] = 0.1
    self.Barstyle['hatch'] = ''
    self.Barstyle['hatchMultiply'] = 1
    self.Barstyle['offset'] = 0
    self.Barstyle['doFill'] = True
    
    # initialize stack style
    self.Stackstyle = {}
    self.Stackstyle['showStack'] = False
    self.Stackstyle['linewidth'] = 0.5
    self.Stackstyle['linestyle'] = 'solid'
    self.Stackstyle['facecolor'] = [0.2, 0.8, 0.2, 0.5]
    self.Stackstyle['facecolorAlt'] = [0.3, 0.2, 0.6, 1.0]
    self.Stackstyle['edgecolor'] = [0.3, 0.3, 0.3, 1.0]
    self.Stackstyle['hatch'] = ''
    self.Stackstyle['hatchMultiply'] = 1
    self.Stackstyle['doFill'] = True
    
    # initialize text style
    self.Textstyle = {}
    self.Textstyle['showText'] = False
    self.Textstyle['skip'] = 1
    self.Textstyle['color'] = [0.2, 0.2, 0.2, 1.0]
    self.Textstyle['fontsize'] = 10
    self.Textstyle['fontweight'] = 'normal'
    self.Textstyle['fontstyle'] = 'normal'
    self.Textstyle['fontname'] = 'Dejavu Sans'
    self.Textstyle['rotation'] = 0.0
    self.Textstyle['padX'] = 0.0
    self.Textstyle['padY'] = 0.0
    self.Textstyle['type'] = 'y'
    
    # initialize violin style
    self.Violinstyle = {}
    self.Violinstyle['mode'] = 0
    self.Violinstyle['bodies'] = {'facecolor': [0.8, 0.8, 0.9, 1.0], 'edgecolor': [0.2, 0.2, 0.2, 1.0], 'linestyle': 'solid', 'linewidth': 1.0,\
                    'capstyle': 'butt', 'hatch': '', 'hatchMultiply': 1, 'visible': True, 'width': 0.5, 'doFill': True}
    self.Violinstyle['cmaxes'] = {'linestyle': 'solid', 'linewidth': 1.0, 'color': [0.2, 0.2, 0.2, 1.0], 'capstyle': 'butt', 'visible': True}
    for slaved in ['cbars', 'cmeans']:
      self.Violinstyle[slaved] = {}
      self.Violinstyle[slaved].update(self.Violinstyle['cmaxes'])
    self.Violinstyle['cmedians'] = {'visible': False}
    self.Violinstyle['cmins'] = {'visible': True}

    # initialize boxplot style -- we can lumo this together with the violin style as the keys are non-overlapping
    self.Violinstyle['boxes'] = {'linestyle': 'solid', 'linewidth': 1.0, 'color': [0.2, 0.2, 0.2, 1.0], 'dash_capstyle': 'butt', 'visible': True}
    for slaved in ['whiskers', 'medians', 'caps']:
      self.Violinstyle[slaved] = {}
      self.Violinstyle[slaved].update(self.Violinstyle['boxes'])
    self.Violinstyle['boxes'].update({'edgecolor': [0.2, 0.2, 0.2, 1.0], 'width': 0.5, 'boxFill': True, 'facecolor': [0.8, 0.8, 0.9, 0.0], 'hatch': '', 'hatchMultiply': 1})
    # only used this key temporarily for slaving whiskers etc.
    del self.Violinstyle['boxes']['color']
    self.Violinstyle['fliers'] = {'visible': True, 'marker': 'o', 'markerfacecolor': [0.89, 0.29, 0.2, 1.0], 'markerfacecoloralt': [0.0, 0.0, 0.0, 1.0],\
                    'markeredgecolor': [0.0, 0.0, 0.0, 1.0], 'markeredgewidth': 0.5, 'markersize': 10.0, 'fillstyle': 'full', 'doFill': True}

    # initialize resid style
    self.Residstyle = deepcopy(self.style)
    self.ResidLinestyle = {}
    self.ResidLinestyle['linewidth'] = 1.0
    self.ResidLinestyle['linestyle'] = 'solid'
    self.ResidLinestyle['dash_capstyle'] = 'butt'
    self.ResidLinestyle['color'] = [0.8, 0.2, 0.2, 1.0]
    self.ResidBarstyle = deepcopy(self.Barstyle)
    self.ResidStackstyle = deepcopy(self.Stackstyle)
    self.ResidTextstyle = deepcopy(self.Textstyle)
    
    # fine-sort zorder
    self.relativeZOrderError = -0.4
    self.relativeZOrderBar = -0.2
    self.relativeZOrderText = 0.2

    # memorize plot settings
    for key in self.style:
      self.rememberSetting[key] = 'set_' + key + '(' + repr(self.style[key]) + ')'
    for key in self.Errorstyle:
      if(key != 'errorInFront'):
        self.rememberSettingError[key] = 'set_' + key + '(' + repr(self.Errorstyle[key]) + ')'
    for key in self.ErrorShadystyle:
      self.rememberSettingErrorShady[key] = 'set_' + key + '(' + repr(self.ErrorShadystyle[key]) + ')'
    for key in self.Barstyle:
      if(not (key in ['showBar', 'offset', 'hatchMultiply'])):
        self.rememberSettingBar[key] = 'set_' + key + '(' + repr(self.Barstyle[key]) + ')'
    for key in self.Stackstyle:
      if(key.startswith('facecolor')):
        if(key == 'facecolor'):
          self.rememberSettingStack[key] = 'set_facecolor(' + repr(self.Stackstyle[key]) + ')'
        else:
          self.rememberSettingStackNeg[key] = 'set_facecolor(' + repr(self.Stackstyle[key]) + ')'
      elif(not (key in ['showStack', 'hatchMultiply'])):
        self.rememberSettingStack[key] = 'set_' + key + '(' + repr(self.Stackstyle[key]) + ')'
        self.rememberSettingStackNeg[key] = 'set_' + key + '(' + repr(self.Stackstyle[key]) + ')'
    for key in self.Residstyle:
      self.rememberSettingResid[key] = 'set_' + key + '(' + repr(self.Residstyle[key]) + ')'
    for key in self.ResidBarstyle:
      if(not (key in ['showBar', 'offset', 'hatchMultiply'])):
        self.rememberSettingResidBar[key] = 'set_' + key + '(' + repr(self.ResidBarstyle[key]) + ')'
    for key in self.ResidStackstyle:
      if(key.startswith('facecolor')):
        if(key == 'facecolor'):
          self.rememberSettingResidStack[key] = 'set_facecolor(' + repr(self.ResidStackstyle[key]) + ')'
        else:
          self.rememberSettingResidStackNeg[key] = 'set_facecolor(' + repr(self.ResidStackstyle[key]) + ')'
      elif(not (key in ['showStack', 'hatchMultiply'])):
        self.rememberSettingResidStack[key] = 'set_' + key + '(' + repr(self.ResidStackstyle[key]) + ')'
        self.rememberSettingResidStackNeg[key] = 'set_' + key + '(' + repr(self.ResidStackstyle[key]) + ')'
    
  def toggleResidBar(self, showBar):
    # turns on/off bar graphics
    self.ResidBarstyle['showBar'] = showBar
    self.drawMeResid(rescale=False)

  def toggleResidStack(self, showStack):
    # turns on/off stack graphics
    self.ResidStackstyle['showStack'] = showStack
    self.drawMeResid(rescale=False)

  def toggleBar(self, showBar):
    # turns on/off bar graphics
    self.Barstyle['showBar'] = showBar
    self.drawMe(rescale=False)

  def toggleStack(self, showStack):
    # turns on/off stack graphics
    self.Stackstyle['showStack'] = showStack
    self.drawMe(rescale=False)

  def toggleText(self, showText):
    # turns on/off text graphics
    self.Textstyle['showText'] = showText
    self.drawMe(rescale=False)

  def toggleResidText(self, showText):
    # turns on/off text graphics
    self.ResidTextstyle['showText'] = showText
    self.drawMeResid(rescale=False)

  def toggleViolin(self, mode, redraw=False):
    # turns on/off violin graphics
    self.Violinstyle['mode'] = mode
    self.drawMe(rescale=False, redraw=redraw)

  def reportState(self):
    # reports data content for saveState function
    items = ['name', 'nameResid', 'zorder', 'zorderResid', 'x', 'y', 'xerr', 'yerr', 'fval', 'resid', 'labels', 'onSecondAxes']
    retv = {}
    
    for entry in items:
      if(hasattr(self, entry)):
        value = self.__dict__[entry]
        if(type(value) == type(np.array([]))):
          value = value.tolist()
        retv[entry] = value
    
    return retv

  def restoreState(self, data={}, zoffset=0, zoffsetResid=0):
    # restores data content for loadState function
    for entry in data:
      if(hasattr(self, entry)):
        if(entry in ['x', 'y', 'xerr', 'yerr', 'fval', 'resid']):
          value = np.array(data[entry])
        elif(entry in ['zorder']):
          value = data[entry] + zoffset
        elif(entry in ['zorderResid']):
          value = data[entry] + zoffsetResid
        elif(entry == 'name'):
          value = data[entry]
          self.setName(value)
        elif(entry == 'nameResid'):
          value = data[entry]
          self.setNameResid(value)
        else:
          value = data[entry]
        self.__dict__[entry] = value

  def setName(self, name='John Doe'):
    # updates name of object
    self.name = name
    # update plot if necessary
    if(self.handleData != None):
      self.handleData.set_label(self.name)
    self.rememberSetting['name'] = 'set_label(' + repr(self.name) + ')'
    
  def setNameResid(self, name='John Doe'):
    # updates name of object
    self.nameResid = name
    # update plot if necessary
    if(self.handleResid != None):
      self.handleResid.set_label(self.nameResid)
    self.rememberSettingResid['name'] = 'set_label(' + repr(self.nameResid) + ')'
    
  def setZOrderError(self, state=True, redraw=True):
    # toggles relative z order of error bars
    self.Errorstyle['errorInFront'] = state
    if(state):
      self.relativeZOrderError = 0.4
    else:
      self.relativeZOrderError = -0.4
    # reassign z values
    # in case of redraw, ensure that this is done by temporarily altering z-order ever so slightly
    if(redraw):
      self.zorder -= 0.01
      self.setZOrder(self.zorder + 0.01, redraw=redraw)
    else:
      self.setZOrder(self.zorder, redraw=redraw)

  def setZOrderResid(self, zorder=0, redraw=True):
    # updates z order of residuals
    self.zorderResid = zorder
    # update plot if necessary
    if(self.handleResid != None):
      self.handleResid.set_zorder(self.zorderResid + self.parent.zOffset)
      self.rememberSettingResid['zorder'] = 'set_zorder(' + str(self.zorderResid + self.parent.zOffset) + ')'
    if(self.handleResidBar != None):
      for entry in self.handleResidBar.patches:
        entry.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingResidBar['zorder'] = 'set_zorder(' + str(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleResidStack != None):
      self.handleResidStack.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingResidStack['zorder'] = 'set_zorder(' + str(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleResidStackNeg != None):
      self.handleResidStackNeg.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingResidStackNeg['zorder'] = 'set_zorder(' + str(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleResidText != None):
      for entry in self.handleResidText:
        entry.set_zorder(self.zorderResid + self.parent.zOffset + self.relativeZOrderText)
      
    if(self.handleResid_div != None):
      self.handleResid_div.set_zorder(self.zorderResid + self.parent.zOffset)
    if(self.handleResidBar_div != None):
      for entry in self.handleResidBar_div.patches:
        entry.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleResidStack_div != None):
      self.handleResidStack_div.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleResidStackNeg_div != None):
      self.handleResidStackNeg_div.set_zorder(self.zorderResid + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleResidText_div != None):
      for entry in self.handleResidText_div:
        entry.set_zorder(self.zorderResid + self.parent.zOffset + self.relativeZOrderText)
      
    # update plot
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def setZOrder(self, zorder=0, redraw=True):
    # updates z order
    if(self.zorder == zorder):
      redraw, changed = False, False
    else:
      changed = True
    self.zorder = zorder
    # update plot if necessary
    if(self.handleData != None):
      self.handleData.set_zorder(self.zorder + self.parent.zOffset)
      self.rememberSetting['zorder'] = 'set_zorder(' + str(self.zorder + self.parent.zOffset) + ')'
    if(self.handleErr != None):
      self.handleErr[0].set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
      for entry in self.handleErr[1]:
        entry.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
      for entry in self.handleErr[2]:
        entry.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
      self.rememberSettingError['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderError + self.parent.zOffset) + ')'
    if(self.handleErrShady != None):
      self.handleErrShady.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset - 0.05)
      self.rememberSettingErrorShady['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderError + self.parent.zOffset - 0.05) + ')'
    if(self.handleBar != None):
      for entry in self.handleBar.patches:
        entry.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingBar['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleStack != None):
      self.handleStack.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingStack['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleStackNeg != None):
      self.handleStackNeg.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
      self.rememberSettingStackNeg['zorder'] = 'set_zorder(' + str(self.zorder + self.relativeZOrderBar + self.parent.zOffset) + ')'
    if(self.handleText != None):
      for entry in self.handleText:
        entry.set_zorder(self.zorder + self.parent.zOffset + self.relativeZOrderText)
    if(self.handleViolin != None):
      for key in self.handleViolin:
        if(key == 'boxes'):
          additionalZOffset = -0.05
        else:
          additionalZOffset = 0
        if(type(self.handleViolin[key]) == type([])):
          for entry in self.handleViolin[key]:
            entry.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset + additionalZOffset)
        else:
          self.handleViolin[key].set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset + additionalZOffset)

    if(self.handleData_div != None):
      self.handleData_div.set_zorder(self.zorder + self.parent.zOffset)
    if(self.handleErr_div != None):
      self.handleErr_div[0].set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
      for entry in self.handleErr_div[1]:
        entry.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
      for entry in self.handleErr_div[2]:
        entry.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset)
    if(self.handleErrShady_div != None):
      self.handleErrShady_div.set_zorder(self.zorder + self.relativeZOrderError + self.parent.zOffset - 0.05)
    if(self.handleBar_div != None):
      for entry in self.handleBar_div.patches:
        entry.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleStack_div != None):
      self.handleStack_div.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleStackNeg_div != None):
      self.handleStackNeg_div.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset)
    if(self.handleText_div != None):
      for entry in self.handleText_div:
        entry.set_zorder(self.zorder + self.parent.zOffset + self.relativeZOrderText)
    if(self.handleViolin_div != None):
      for key in self.handleViolin_div:
        if(key == 'boxes'):
          additionalZOffset = -0.05
        else:
          additionalZOffset = 0
        if(type(self.handleViolin_div[key]) == type([])):
          for entry in self.handleViolin_div[key]:
            entry.set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset + additionalZOffset)
        else:
          self.handleViolin[key].set_zorder(self.zorder + self.relativeZOrderBar + self.parent.zOffset + additionalZOffset)

    # update plot
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()
      
    return changed

  def collateViolinData(self):
    # arranges data for violin plot
    EPSILON, MINMEMBERS = 1e-6, 2
    
    if(len(self.x) * len(self.y)):
      xvector, yvector = [], []
      for x, y in zip(self.x, self.y):
        # check for close previous x entry
        closeness = np.isclose(x, xvector, rtol=EPSILON)
        position = [i for i in range(len(closeness)) if closeness[i]]
        if(len(position)):
          yvector[position[0]].append(y)
        else:
          # make new entry
          xvector.append(x)
          yvector.append([])
          yvector[-1].append(y)
      
      # exclude  groups that have too few points
      nu_xvector = [i for i, j in zip(xvector, yvector) if (len(j) >= MINMEMBERS)]
      nu_yvector = [j for j in yvector if (len(j) >= MINMEMBERS)]
      xvector, yvector = nu_xvector, nu_yvector
      return xvector, yvector
    else:
      return [], []

  def getData_n_Fit(self):
    # returns data, fit and residuals along with rolestr
    descriptors = ['x', 'xerr', 'y', 'yerr', 'fval', 'resid']
    roles = []
    values = np.array([])
    for entry in descriptors:
      if(len(self.__dict__[entry])):
        if(len(values)):
          values = np.vstack((values, self.__dict__[entry]))
        else:
          values = self.__dict__[entry]
        roles.append(entry)
    
    if(len(values)):
      values = values.transpose()
    return values, roles

  def getLabels(self):
    # returns data labels
    return list(self.labels)

  def setFval(self, fval=np.array([])):
    # updates fitted values and residuals after fit
    if(fval.size):
      self.fval = fval
      self.resid = np.array([i-j for i, j in zip(self.y, self.fval)])
      
  def setSecondAxes(self, state=False, redraw=True):
    # moves data between axes
    self.onSecondAxes = state
    # trigger redraw
    self.drawMe(redraw=redraw)

  def setVisibility(self, state=True, redraw=True):
    # toggles visibility of data and error bars
    if(self.visibility == state):
      redraw, changed = False, False
    else:
      changed = True
    self.visibility = state
    if(self.handleData != None):
      self.handleData.set_visible(state)
      self.rememberSetting['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
      if(self.visibility):
        self.handleData.set_label(self.name)
      else:
        self.handleData.set_label('_nolegend_')
    if(self.handleErr != None):
      workstate = state and self.Errorstyle['visible']
      self.handleErr[0].set_visible(workstate)
      for entry in self.handleErr[1]:
        entry.set_visible(workstate)
      for entry in self.handleErr[2]:
        entry.set_visible(workstate)
      self.rememberSettingError['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if(self.handleErrShady != None):
      self.handleErrShady.set_visible(state)
      self.rememberSettingErrorShady['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if(self.handleBar != None):
      for entry in self.handleBar.patches:
        entry.set_visible(state)
      self.rememberSettingBar['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if(self.handleStack != None):
      self.handleStack.set_visible(state)
      self.rememberSettingStack['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if(self.handleStackNeg != None):
      self.handleStackNeg.set_visible(state)
      self.rememberSettingStackNeg['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if(self.handleText != None):
      for entry in self.handleText:
        entry.set_visible(state)
    if(self.handleViolin != None):
      for key in self.handleViolin:
        if((key in self.Violinstyle) and ('visible' in self.Violinstyle[key])):
          modState = self.Violinstyle[key]['visible']
        else:
          modState = True
        if(type(self.handleViolin[key]) == type([])):
          for entry in self.handleViolin[key]:
            entry.set_visible(state and modState)
        else:
          self.handleViolin[key].set_visible(state and modState)
      
    if(self.handleData_div != None):
      self.handleData_div.set_visible(state)
    if(self.handleErr_div != None):
      workstate = state and self.Errorstyle['visible']
      self.handleErr_div[0].set_visible(workstate)
      for entry in self.handleErr_div[1]:
        entry.set_visible(workstate)
      for entry in self.handleErr_div[2]:
        entry.set_visible(workstate)
    if(self.handleErrShady_div != None):
      self.handleErrShady_div.set_visible(state)
    if(self.handleBar_div != None):
      for entry in self.handleBar_div.patches:
        entry.set_visible(state)
    if(self.handleStack_div != None):
      self.handleStack_div.set_visible(state)
    if(self.handleStackNeg_div != None):
      self.handleStackNeg_div.set_visible(state)
    if(self.handleText_div != None):
      for entry in self.handleText_div:
        entry.set_visible(state)
    if(self.handleViolin_div != None):
      for key in self.handleViolin_div:
        if((key in self.Violinstyle) and ('visible' in self.Violinstyle[key])):
          modState = self.Violinstyle[key]['visible']
        else:
          modState = True
        if(type(self.handleViolin_div[key]) == type([])):
          for entry in self.handleViolin_div[key]:
            entry.set_visible(state and modState)
        else:
          self.handleViolin_div[key].set_visible(state and modState)

    # hide caps when error display is only in one direction
    for handleErr in [self.handleErr, self.handleErr_div]:
      if(handleErr != None):
        if(self.Errorstyle['direction'] != 'both'):
          if(self.xerr.size):
            offset = 2
            if(self.Errorstyle['direction'] == 'positive'):
              for entry in handleErr[1][:min(offset - 1, len(handleErr[1]))]:
                entry.set_visible(False)
            elif(self.Errorstyle['direction'] == 'negative'):
              for entry in handleErr[1][1:min(offset, len(handleErr[1]))]:
                entry.set_visible(False)
          else:
            offset = 0
          if(self.yerr.size):
            if(self.Errorstyle['direction'] == 'positive'):
              for entry in handleErr[1][offset:-1]:
                entry.set_visible(False)
            elif(self.Errorstyle['direction'] == 'negative'):
              for entry in handleErr[1][offset + 1:]:
                entry.set_visible(False)      
      
    # update plot
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()
      
    return changed

  def setVisibilityResid(self, state=True, redraw=True):
    # toggles visibility of residuals
    if(self.visibilityResid == state):
      redraw, changed = False, False
    else:
      changed = True
    self.visibilityResid = state
    if(self.handleResid != None):
      self.handleResid.set_visible(state)
      self.rememberSettingResid['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if(self.handleResidBar != None):
      for entry in self.handleResidBar.patches:
        entry.set_visible(state)
      self.rememberSettingResidBar['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if(self.handleResidStack != None):
      self.handleResidStack.set_visible(state)
      self.rememberSettingResidStack['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if(self.handleResidStackNeg != None):
      self.handleResidStackNeg.set_visible(state)
      self.rememberSettingResidStackNeg['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if(self.handleResidText != None):
      for entry in self.handleResidText:
        entry.set_visible(state)
      
    if(self.handleResid_div != None):
      self.handleResid_div.set_visible(state)
    if(self.handleResidBar_div != None):
      for entry in self.handleResidBar_div.patches:
        entry.set_visible(state)
    if(self.handleResidStack_div != None):
      self.handleResidStack_div.set_visible(state)
    if(self.handleResidStackNeg_div != None):
      self.handleResidStackNeg_div.set_visible(state)
    if(self.handleResidText_div != None):
      for entry in self.handleResidText_div:
        entry.set_visible(state)
      
    # update plot
    if(redraw):
      self.parent.plotArea.residplotwidget.myRefresh()
      
    return changed

  def spawned(self, source=None):
    # copies contents of the source object to current object
    if(source != None):
      copyItems = 'x,y,xerr,yerr,style,Errorstyle,ErrorShadystyle,fval,resid,visibility,visibilityResid,Barstyle,Stackstyle,Textstyle,Violinstyle,Residstyle,ResidBarstyle,ResidStackstyle,ResidTextstyle,labels,relativeZOrderError,relativeZOrderBar,relativeZOrderText,onSecondAxes'.split(',')
      for item in copyItems:
        if(hasattr(source, item)):
          sourceItem = deepcopy(getattr(source, item))
          setattr(self, item, sourceItem)
    
  def drawMe(self, redraw=True, rescale=True):
    # causes data to be drawn on canvas
    self.handleData, self.handleErr, self.handleErrShady, self.handleBar, self.handleStack, self.handleStackNeg, self.handleText, self.handleViolin = self.parent.plotArea.plotData(self.value(),\
      dataobject = self, handleData = self.handleData, handleErr = self.handleErr, handleErrShady=self.handleErrShady, handleBar=self.handleBar,\
      handleStack=self.handleStack, handleStackNeg=self.handleStackNeg, handleText=self.handleText, handleViolin=self.handleViolin, redraw=False, rescale=rescale)
    if (self.handleData != None):
      self.handleData.set_visible(self.visibility)
      self.rememberSetting['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleBar != None):
      for entry in self.handleBar.patches:
        entry.set_visible(self.visibility)
      self.rememberSettingBar['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleStack != None):
      self.handleStack.set_visible(self.visibility)
      self.rememberSettingStack['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleStackNeg != None):
      self.handleStackNeg.set_visible(self.visibility)
      self.rememberSettingStackNeg['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleErrShady != None):
      self.handleErrShady.set_visible(self.visibility)
      self.rememberSettingErrorShady['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleErr != None):
      self.rememberSettingError['visibility'] = 'set_visible(' + repr(self.visibility) + ')'
    if (self.handleText != None):
      for entry in self.handleText:
        entry.set_visible(self.visibility)
    if(self.handleViolin != None):
      for key in self.handleViolin:
        if((key in self.Violinstyle) and ('visible' in self.Violinstyle[key])):
          modState = self.Violinstyle[key]['visible']
        else:
          modState = True
        if(type(self.handleViolin[key]) == type([])):
          for entry in self.handleViolin[key]:
            entry.set_visible(self.visibility and modState)
        else:
          self.handleViolin[key].set_visible(self.visibility and modState)

    # causes data to be drawn on canvas
    self.handleData_div, self.handleErr_div, self.handleErrShady_div, self.handleBar_div, self.handleStack_div, self.handleStackNeg_div, self.handleText_div, self.handleViolin_div = self.parent.plotArea.plotData(self.value(),\
      dataobject = self, handleData = self.handleData_div, handleErr = self.handleErr_div, handleErrShady=self.handleErrShady_div, handleBar=self.handleBar_div,\
      handleStack=self.handleStack_div, handleStackNeg=self.handleStackNeg_div, handleText=self.handleText_div, handleViolin=self.handleViolin_div, redraw=False, rescale=rescale, splitX=True)
    # set visibility
    if (self.handleData_div != None):
      self.handleData_div.set_visible(self.visibility)
    if (self.handleBar_div != None):
      for entry in self.handleBar_div.patches:
        entry.set_visible(self.visibility)
    if (self.handleStack_div != None):
      self.handleStack_div.set_visible(self.visibility)
    if (self.handleStackNeg_div != None):
      self.handleStackNeg_div.set_visible(self.visibility)
    if (self.handleErrShady_div != None):
      self.handleErrShady_div.set_visible(self.visibility)
    if (self.handleText_div != None):
      for entry in self.handleText_div:
        entry.set_visible(self.visibility)
    if(self.handleViolin_div != None):
      for key in self.handleViolin_div:
        if((key in self.Violinstyle) and ('visible' in self.Violinstyle[key])):
          modState = self.Violinstyle[key]['visible']
        else:
          modState = True
        if(type(self.handleViolin_div[key]) == type([])):
          for entry in self.handleViolin_div[key]:
            entry.set_visible(self.visibility and modState)
        else:
          self.handleViolin_div[key].set_visible(self.visibility and modState)

    # redraw? -- update legend in this go if required (this is needed to draw stack/bar entries for legend when line/marker invisible)
    value = self.parent.plotArea.legendVisible
    if(value):
      self.parent.plotArea.setLegend(value=value, redraw=False) 
      
    if(redraw and self.visibility):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def drawMeResid(self, redraw=True, rescale=True):
    # causes residuals to be drawn on canvas
    self.handleResid, self.parent.plotArea.handleResidZero, self.handleResidBar, self.handleResidStack, self.handleResidStackNeg, self.handleResidText = self.parent.plotArea.plotResid(\
      dataobject = self, handleResid = self.handleResid, handleResidZero = self.parent.plotArea.handleResidZero,\
      handleResidBar = self.handleResidBar, handleResidStack = self.handleResidStack, handleResidStackNeg = self.handleResidStackNeg,\
       handleResidText = self.handleResidText, redraw=False, rescale=rescale)
    # set visibility
    if (self.handleResid != None):
      self.handleResid.set_visible(self.visibilityResid)
      self.rememberSettingResid['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if (self.handleResidBar != None):
      for entry in self.handleResidBar.patches:
        entry.set_visible(self.visibilityResid)
      self.rememberSettingResidBar['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if (self.handleResidStack != None):
      self.handleResidStack.set_visible(self.visibilityResid)
      self.rememberSettingResidStack['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if (self.handleResidStackNeg != None):
      self.handleResidStackNeg.set_visible(self.visibilityResid)
      self.rememberSettingResidStackNeg['visibility'] = 'set_visible(' + repr(self.visibilityResid) + ')'
    if (self.handleResidText != None):
      for entry in self.handleResidText:
        entry.set_visible(self.visibilityResid)

    # causes residuals to be drawn on canvas
    self.handleResid_div, self.parent.plotArea.handleResidZero_div, self.handleResidBar_div, self.handleResidStack_div, self.handleResidStackNeg_div, self.handleResidText_div = self.parent.plotArea.plotResid(\
      dataobject = self, handleResid = self.handleResid_div, handleResidZero = self.parent.plotArea.handleResidZero_div,\
      handleResidBar = self.handleResidBar_div, handleResidStack = self.handleResidStack_div, handleResidStackNeg = self.handleResidStackNeg_div,\
      handleResidText = self.handleResidText_div, redraw=False, splitX=True, rescale=rescale)
    # set visibility
    if (self.handleResid_div != None):
      self.handleResid_div.set_visible(self.visibilityResid)
    if (self.handleResidBar_div != None):
      for entry in self.handleResidBar_div.patches:
        entry.set_visible(self.visibilityResid)
    if (self.handleResidStack_div != None):
      self.handleResidStack_div.set_visible(self.visibilityResid)
    if (self.handleResidStackNeg_div != None):
      self.handleResidStackNeg_div.set_visible(self.visibilityResid)
    if (self.handleResidText_div != None):
      for entry in self.handleResidText_div:
        entry.set_visible(self.visibilityResid)

    # redraw?
    if(redraw and self.visibilityResid):
      self.parent.plotArea.residplotwidget.myRefresh()

  def getStyle(self):
    # returns the style object
    return self.style
    
  def getTextStyle(self):
    # returns the textstyle object
    return self.Textstyle
    
  def getBarStyle(self):
    # returns the barstyle object
    return self.Barstyle
    
  def getStackStyle(self):
    # returns the stackstyle object
    return self.Stackstyle
    
  def getViolinStyle(self):
    # returns the violinstyle object
    return self.Violinstyle
    
  def getResidStyle(self):
    # returns the residuals style object
    return self.Residstyle
    
  def getResidTextStyle(self):
    # returns the resid textstyle object
    return self.ResidTextstyle
    
  def getResidBarStyle(self):
    # returns the resid barstyle object
    return self.ResidBarstyle
    
  def getResidStackStyle(self):
    # returns the resid stackstyle object
    return self.ResidStackstyle
    
  def setResidStyle(self, key, value, redraw=True):
    # changes the style value
    if(key in self.Residstyle):
      if(self.Residstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Residstyle[key] = value
      # cause plot to be updated
      updateFlag = False
      # special treatment for markerfacecolor
      if((key != 'markerfacecolor') or self.Residstyle['doFill']):
        if(self.handleResid != None):
          method = 'set_'+key
          if (hasattr(self.handleResid, method)):
            method2call = getattr(self.handleResid, method)
            method2call(value)
            updateFlag = True
            self.rememberSettingResid[key] = 'set_' + key + '(' + repr(value) + ')'
            # special treatment for capstyle
            if((key == 'dash_capstyle') and (hasattr(self.handleResid, 'set_solid_capstyle'))):
              method2call = getattr(self.handleResid, 'set_solid_capstyle')
              method2call(value)
              self.rememberSettingResid['solid_capstyle'] = 'set_solid_capstyle(' + repr(value) + ')'
  
        if(self.handleResid_div != None):
          method = 'set_'+key
          if (hasattr(self.handleResid_div, method)):
            method2call = getattr(self.handleResid_div, method)
            method2call(value)
            updateFlag = True
            # special treatment for capstyle
            if((key == 'dash_capstyle') and (hasattr(self.handleResid_div, 'set_solid_capstyle'))):
              method2call = getattr(self.handleResid_div, 'set_solid_capstyle')
              method2call(value)
      else:
        # prevent update of plot
        changed = False

      if(redraw and self.visibilityResid and updateFlag):
        self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.visibilityResid)

  def setResidBarStyle(self, key, value, redraw=True, rescale=True):
    # changes the barstyle value
    if(key in self.ResidBarstyle):
      if(self.ResidBarstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ResidBarstyle[key] = value
      # cause plot to be updated
      if(key in ['showBar', 'offset']):
        self.drawMeResid(redraw=redraw, rescale=rescale)
      elif(key in ['width']):
        if((self.handleResidBar != None) or (self.handleResidBar != None)):
          # have to trigger redraw to avoid recentering of bars
          self.drawMeResid(redraw=redraw)
          self.rememberSettingResidBar[key] = 'set_' + key + '(' + repr(value) + ')'
      else:
        updateFlag = False
        # special treatment for markerfacecolor
        if((key != 'facecolor') or self.ResidBarstyle['doFill']):
          if(self.handleResidBar != None):
            if(key in ['hatch', 'hatchMultiply']):
              key = 'hatch'
              value = self.ResidBarstyle['hatch'] * self.ResidBarstyle['hatchMultiply']
            method = 'set_'+key
            for entry in self.handleResidBar.patches:
              if(key in ['facecolor', 'facecolorAlt']):
                if (hasattr(entry, 'set_facecolor')):
                  if(entry.get_height() >= 0):
                    useValue = self.ResidBarstyle['facecolor']
                  else:
                    useValue = self.ResidBarstyle['facecolorAlt']
                  entry.set_facecolor(useValue)
              elif (hasattr(entry, method)):
                method2call = getattr(entry, method)
                method2call(value)
            updateFlag =True
            if(key == 'facecolorAlt'):
              self.rememberSettingResidBar[key] = 'set_facecolor(' + repr(value) + ')'
            else:
              self.rememberSettingResidBar[key] = 'set_' + key + '(' + repr(value) + ')'
  
          if(self.handleResidBar_div != None):
            if(key in ['hatch', 'hatchMultiply']):
              key = 'hatch'
              value = self.ResidBarstyle['hatch'] * self.ResidBarstyle['hatchMultiply']
            method = 'set_'+key
            for entry in self.handleResidBar_div.patches:
              if(key in ['facecolor', 'facecolorAlt']):
                if (hasattr(entry, 'set_facecolor')):
                  if(entry.get_height() >= 0):
                    useValue = self.ResidBarstyle['facecolor']
                  else:
                    useValue = self.ResidBarstyle['facecolorAlt']
                  entry.set_facecolor(useValue)
              elif (hasattr(entry, method)):
                method2call = getattr(entry, method)
                method2call(value)
            updateFlag =True
        else:
          # prevent update of plot
          changed = False

        if(redraw and self.visibilityResid and updateFlag):
          self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.visibilityResid)

  def setResidStackStyle(self, key, value, redraw=True, rescale=True):
    # changes the stackstyle value
    if(key in self.ResidStackstyle):
      if(self.ResidStackstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ResidStackstyle[key] = value
      # cause plot to be updated
      if(key in ['showStack']):
        self.drawMeResid(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        for handle in [self.handleResidStack, self.handleResidStackNeg, self.handleResidStack_div, self.handleResidStackNeg_div]:
          if(handle != None):
            updateFlag = True
            if(key in ['facecolor', 'facecolorAlt']):
              if (hasattr(handle, 'set_facecolor')):
                if(handle == self.handleResidStack):
                  useValue = self.ResidStackstyle['facecolor']
                else:
                  useValue = self.ResidStackstyle['facecolorAlt']
                handle.set_facecolor(useValue)
            else:
              if(key in ['hatch', 'hatchMultiply']):
                key = 'hatch'
                value = self.ResidStackstyle['hatch'] * self.ResidStackstyle['hatchMultiply']
              method = 'set_'+key
              if (hasattr(handle, method)):
                method2call = getattr(handle, method)
                method2call(value)
  
          if(handle in [self.handleResidStack, self.handleResidStackNeg]):
            if(key.startswith('facecolor')):
              if(key == 'facecolor'):
                self.rememberSettingResidStack[key] = 'set_facecolor(' + repr(value) + ')'
              else:
                self.rememberSettingResidStackNeg[key] = 'set_facecolor(' + repr(value) + ')'
            else:
              self.rememberSettingResidStack[key] = 'set_' + key + '(' + repr(value) + ')'
              self.rememberSettingResidStackNeg[key] = 'set_' + key + '(' + repr(value) + ')'
        
        if(redraw and self.visibilityResid and updateFlag):
          self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.visibilityResid)

  def getResidLineStyle(self):
    # returns the residuals line style object
    return self.ResidLinestyle
    
  def setResidLineStyle(self, key, value, redraw=True):
    # changes the style value
    if(key in self.ResidLinestyle):
      if(self.ResidLinestyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ResidLinestyle[key] = value
      # cause plot to be updated
      updateFlag = False
      for handle in [self.parent.plotArea.handleResidZero, self.parent.plotArea.handleResidZero_div]:
        if(handle != None):
          method = 'set_'+key
          if (hasattr(handle, method)):
            method2call = getattr(handle, method)
            method2call(value)
            # special treatment for capstyle
            if((key == 'dash_capstyle') and (hasattr(handle, 'set_solid_capstyle'))):
              method2call = getattr(handle, 'set_solid_capstyle')
              method2call(value)
          if(handle.get_visible()):
            updateFlag = True

      if(redraw and updateFlag):
        self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.parent.plotArea.handleResidZero.get_visible())

  def setResidTextStyle(self, key, value, redraw=True, rescale=False):
    # changes the residuals textstyle value
    if(key in self.ResidTextstyle):
      if(self.ResidTextstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ResidTextstyle[key] = value
      # cause plot to be updated
      if(key in ['showText', 'skip', 'padX', 'padY', 'type']):
        self.drawMeResid(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        if(self.handleResidText != None):
          method = 'set_' + key
          if (hasattr(self.handleResidText[0], method)):
            safeFont = 'DejaVu Sans'
            updateFlag = True
            for item in self.handleResidText:
              method2call = getattr(item, method)
              method2call(value)
              # special treatment for font type to catch errors
              if(key == 'fontname'):
                _, _, descent = item._get_layout(self.parent.plotArea.matplot.canvas.renderer)
                if(not (descent > 0)):
                  self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                  value = safeFont
                  method2call(value)

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.residplotwidget.myRefresh()
      return (changed and self.visibility)

  def toggleResidMarkerFill(self, value, redraw=True):
    # toggles resid marker fill
    if(self.Residstyle['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.Residstyle['doFill'] = value
    # adjust value
    if(value):
      value = self.Residstyle['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    if(self.handleResid != None):
      self.handleResid.set_markerfacecolor(value)
      self.rememberSettingResid['markerfacecolor'] = 'set_markerfacecolor(' + repr(value) + ')'
      updateFlag = True
    if(self.handleResid_div != None):
      self.handleResid_div.set_markerfacecolor(value)
      updateFlag = True

    if(redraw and self.visibilityResid and updateFlag):
      self.parent.plotArea.residplotwidget.myRefresh()
    return (changed and self.visibilityResid)

  def toggleMarkerFill(self, value, redraw=True):
    # toggles marker fill
    if(self.style['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.style['doFill'] = value
    # adjust value
    if(value):
      value = self.style['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    if(self.handleData != None):
      self.handleData.set_markerfacecolor(value)
      self.rememberSetting['markerfacecolor'] = 'set_markerfacecolor(' + repr(value) + ')'
      updateFlag = True
    if(self.handleData_div != None):
      self.handleData_div.set_markerfacecolor(value)
      updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return (changed and self.visibility)

  def toggleStackFill(self, value, redraw=True):
    # toggles stack fill
    if(self.Stackstyle['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.Stackstyle['doFill'] = value
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(value):
      # call setBarStyle() to reactivate bar filling (have to do it like this b/c of positive/negative coloring)
      tempVal = self.Stackstyle['facecolor']
      self.Stackstyle['facecolor'] = 'tilt'
      self.setStackStyle('facecolor', tempVal, redraw=False, rescale=False)
      updateFlag = True
    else:
      for handleStack in (self.handleStack, self.handleStack_div, self.handleStackNeg, self.handleStackNeg_div):
        if(handleStack != None):
          handleStack.set_facecolor('none')
          updateFlag = True

        if(handleStack in [self.handleStack, self.handleStackNeg]):
          self.rememberSettingStack['facecolor'] = 'set_facecolor(\'none\')'
          self.rememberSettingStackNeg['facecolor'] = 'set_facecolor(\'none\')'

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return (changed and self.visibility)

  def toggleResidStackFill(self, value, redraw=True):
    # toggles resid stack fill
    if(self.ResidStackstyle['doFill'] == value):
      redraw = False

    self.ResidStackstyle['doFill'] = value
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(value):
      # call setResidStackStyle() to reactivate bar filling (have to do it like this b/c of positive/negative coloring)
      tempVal = self.ResidStackstyle['facecolor']
      self.ResidStackstyle['facecolor'] = 'tilt'
      self.setResidStackStyle('facecolor', tempVal, redraw=False, rescale=False)
      updateFlag = True
    else:
      for handleResidStack in (self.handleResidStack, self.handleResidStack_div, self.handleResidStackNeg, self.handleResidStackNeg_div):
        if(handleResidStack != None):
          handleResidStack.set_facecolor('none')
          updateFlag = True

        if(handleResidStack in [self.handleResidStack, self.handleResidStackNeg]):
          self.rememberSettingResidStack['facecolor'] = 'set_facecolor(\'none\')'
          self.rememberSettingResidStackNeg['facecolor'] = 'set_facecolor(\'none\')'

    if(redraw and self.visibilityResid and updateFlag):
      self.parent.plotArea.residplotwidget.myRefresh()

  def toggleBarFill(self, value, redraw=True):
    # toggles bar fill
    if(self.Barstyle['doFill'] == value):
      redraw, changed = False, False
    else:
      changed = True
    self.Barstyle['doFill'] = value
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(value):
      # call setBarStyle() to reactivate bar filling (have to do it like this b/c of positive/negative coloring)
      tempVal = self.Barstyle['facecolor']
      self.Barstyle['facecolor'] = 'tilt'
      self.setBarStyle('facecolor', tempVal, redraw=False, rescale=False)
      updateFlag = True
    else:
      for handleBar in (self.handleBar, self.handleBar_div):
        if(handleBar != None):
          for entry in handleBar.patches:
            entry.set_facecolor('none')
          if(handleBar == self.handleBar):
            self.rememberSettingBar['facecolor'] = 'set_facecolor(\'none\')'
          updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()
    return (changed and self.visibility)

  def toggleResidBarFill(self, value, redraw=True):
    # toggles resid bar fill
    if(self.ResidBarstyle['doFill'] == value):
      redraw = False

    self.ResidBarstyle['doFill'] = value
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(value):
      # call setBarStyle() to reactivate bar filling (have to do it like this b/c of positive/negative coloring)
      tempVal = self.ResidBarstyle['facecolor']
      self.ResidBarstyle['facecolor'] = 'tilt'
      self.setResidBarStyle('facecolor', tempVal, redraw=False, rescale=False)
      updateFlag = True
    else:
      for handleResidBar in (self.handleResidBar, self.handleResidBar_div):
        if(handleResidBar != None):
          for entry in handleResidBar.patches:
            entry.set_facecolor('none')
          if(handleResidBar == self.handleResidBar):
            self.rememberSettingResidBar['facecolor'] = 'set_facecolor(\'none\')'
          updateFlag = True

    if(redraw and self.visibilityResid and updateFlag):
      self.parent.plotArea.residplotwidget.myRefresh()

  def toggleFliersMarkerFill(self, value, redraw=True):
    # toggles fliers marker fill
    if(self.Violinstyle['fliers']['doFill'] == value):
      redraw = False

    self.Violinstyle['fliers']['doFill'] = value
    # adjust value
    if(value):
      value = self.Violinstyle['fliers']['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    if(self.handleViolin != None):
      for entry in self.handleViolin['fliers']:
        entry.set_markerfacecolor(value)
      updateFlag = True
    if(self.handleViolin_div != None):
      for entry in self.handleViolin_div['fliers']:
        entry.set_markerfacecolor(value)
      updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def setStyle(self, key, value, redraw=True):
    # changes the style value
    if(key in self.style):
      if(self.style[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.style[key] = value
      # cause plot to be updated
      updateFlag = False
      # special treatment for markerfacecolor
      if((key != 'markerfacecolor') or self.style['doFill']):
        if(self.handleData != None):
          method = 'set_' + key
          if (hasattr(self.handleData, method)):
            method2call = getattr(self.handleData, method)
            method2call(value)
            updateFlag = True
            self.rememberSetting[key] = 'set_' + key + '(' + repr(value) + ')'
        if(self.handleData_div != None):
          method = 'set_' + key
          if (hasattr(self.handleData_div, method)):
            method2call = getattr(self.handleData_div, method)
            method2call(value)
            updateFlag = True
      else:
        # prevent update of plot
        changed = False

      if(redraw and self.visibility and updateFlag):
        self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def getErrorStyle(self):
    # returns the style object
    return self.Errorstyle
    
  def getErrorShadyStyle(self):
    # returns the style object
    return self.ErrorShadystyle

  def setErrorShadyStyle(self, key, value, redraw=True):
    # changes the errorstyle value
    if(key in self.ErrorShadystyle):
      if(self.ErrorShadystyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.ErrorShadystyle[key] = value
      # cause plot to be updated
      if((key == 'visible') and (value)):
        # if error shading is turned on, we need to issue redraw to generate shading object
        self.drawMe(redraw=redraw, rescale=False)
        self.rememberSettingErrorShady['visible'] = 'set_visible(' + repr(value) + ')'
      else:
        updateFlag = False
        if(self.handleErrShady != None):
          method = 'set_'+key
          if (hasattr(self.handleErrShady, method)):
            method2call = getattr(self.handleErrShady, method)
            method2call(value)
            updateFlag = True
            self.rememberSettingErrorShady[key] = 'set_' + key + '(' + repr(value) + ')'
        if(self.handleErrShady_div != None):
          method = 'set_'+key
          if (hasattr(self.handleErrShady_div, method)):
            method2call = getattr(self.handleErrShady_div, method)
            method2call(value)
            updateFlag = True

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)
    
  def setErrorStyle(self, key, value, redraw=True):
    # changes the errorstyle value
    if(key in self.Errorstyle):
      if(self.Errorstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Errorstyle[key] = value
      # cause plot to be updated
      updateFlag, redrawFlag = False, False
      for handleErr in [self.handleErr, self.handleErr_div]:
        if(handleErr != None):
          if(key in ['marker', 'markerX']):
            # deal w/ x-errors
            if(len(self.xerr)):
              # we have x errors, those should be the first two entries in self.handleErr[1]
              offset = 2
              if(key == 'markerX'):
                for entry in handleErr[1][:min(offset, len(handleErr[1]))]:
                  entry.set_marker(value)
            else:
              offset = 0
            # deal w/ y-errors
            if(len(self.yerr)):
              # we have y errors, those should be the first two entries in self.handleErr[1]
              if(key == 'marker'):
                for entry in handleErr[1][offset:]:
                  entry.set_marker(value)
            if(key == 'marker'):
              self.rememberSettingError['marker'] = 'set_' + key + '(' + repr(value) + ')'
          elif(key in ['errorInFront']):
            self.setZOrderError(state=value, redraw=redraw)
          elif(key in ['direction']):
            if(not redrawFlag):
              # need to handle this by redrawing curve
              self.drawMe(redraw=redraw, rescale=False)
              redraw, redrawFlag = False, True
          else:
            # special treatment for markerfacecolor
            if((key != 'markerfacecolor') or self.Errorstyle['doFill']):
              # extra check for set_visible() -- this prevents error display when entire data set not displayed
              if(key == 'visible'):
                value = value and self.visibility
              method = 'set_'+key
              for entry in handleErr[1]:
                # remember the organization of the error handles
                if (hasattr(entry, method)):
                  method2call = getattr(entry, method)
                  method2call(value)
              for entry in handleErr[2]:
                if (hasattr(entry, method)):
                  method2call = getattr(entry, method)
                  method2call(value)
              self.rememberSettingError[key] = 'set_' + key + '(' + repr(value) + ')'
            else:
              # prevent update of plot
              changed = False

          # don't connect the error bars by line
          for entry in handleErr[1]:
            entry.set_linestyle('None')
          # hide caps when error display is only in one direction
          if(self.Errorstyle['direction'] != 'both'):
            if(self.xerr.size):
              offset = 2
              if(self.Errorstyle['direction'] == 'positive'):
                for entry in handleErr[1][:min(offset - 1, len(handleErr[1]))]:
                  entry.set_visible(False)
              elif(self.Errorstyle['direction'] == 'negative'):
                for entry in handleErr[1][1:min(offset, len(handleErr[1]))]:
                  entry.set_visible(False)
            else:
              offset = 0
            if(self.yerr.size):
              if(self.Errorstyle['direction'] == 'positive'):
                for entry in handleErr[1][offset:-1]:
                  entry.set_visible(False)
              elif(self.Errorstyle['direction'] == 'negative'):
                for entry in handleErr[1][offset + 1:]:
                  entry.set_visible(False)
        
        # to be safe, always update (at some point revisit this)
        updateFlag = True
            
      if(redraw and self.visibility and updateFlag):
        self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def toggleErrorMarkerFill(self, value, redraw=True):
    # toggles marker fill
    if(self.Errorstyle['doFill'] == value):
      redraw = False

    self.Errorstyle['doFill'] = value
    # adjust value
    if(value):
      value = self.Errorstyle['markerfacecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    if(self.handleErr != None):
      for entry in self.handleErr[1]:
        entry.set_markerfacecolor(value)
      updateFlag = True
    if(self.handleErr_div != None):
      for entry in self.handleErr_div[1]:
        entry.set_markerfacecolor(value)
      updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def setBarStyle(self, key, value, redraw=True, rescale=True):
    # changes the barstyle value
    if(key in self.Barstyle):
      if(self.Barstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Barstyle[key] = value
      # cause plot to be updated
      if(key in ['showBar', 'offset']):
        self.drawMe(redraw=redraw, rescale=rescale)
      else:
        updateFlag, redrawFlag = False, False
        # special treatment for markerfacecolor
        if((key != 'facecolor') or self.Barstyle['doFill']):
          for handleBar in [self.handleBar, self.handleBar_div]:
            if(handleBar != None):
              if(key in ['width']):
                if(not redrawFlag):
                  # have to trigger redraw to avoid recentering of bars
                  self.drawMe(redraw=redraw, rescale=False)
                  self.rememberSettingBar[key] = 'set_' + key + '(' + repr(value) + ')'
                  redraw, redrawFlag = False, True
              else:
                if(key in ['hatch', 'hatchMultiply']):
                  key = 'hatch'
                  value = self.Barstyle['hatch'] * self.Barstyle['hatchMultiply']
                method = 'set_'+key
                for entry in handleBar.patches:
                  if(key in ['facecolor', 'facecolorAlt']):
                    if (hasattr(entry, 'set_facecolor')):
                      if(entry.get_height() >= 0):
                        useValue = self.Barstyle['facecolor']
                      else:
                        useValue = self.Barstyle['facecolorAlt']
                      entry.set_facecolor(useValue)
                  elif (hasattr(entry, method)):
                    method2call = getattr(entry, method)
                    method2call(value)
                if(key == 'facecolorAlt'):
                  self.rememberSettingBar[key] = 'set_facecolor(' + repr(value) + ')'
                else:      
                  self.rememberSettingBar[key] = 'set_' + key + '(' + repr(value) + ')'
              updateFlag = True
        else:
          # prevent update of plot
          changed = False

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def setStackStyle(self, key, value, redraw=True, rescale=True):
    # changes the stackstyle value
    if(key in self.Stackstyle):
      if(self.Stackstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Stackstyle[key] = value
      # cause plot to be updated
      if(key in ['showStack']):
        self.drawMe(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        # special treatment for markerfacecolor
        if((key != 'facecolor') or self.Stackstyle['doFill']):
          for handle in [self.handleStack, self.handleStackNeg, self.handleStack_div, self.handleStackNeg_div]:
            if(handle != None):
              updateFlag = True
              if(key in ['facecolor', 'facecolorAlt']):
                if (hasattr(handle, 'set_facecolor')):
                  if(handle in [self.handleStack, self.handleStack_div]):
                    useValue = self.Stackstyle['facecolor']
                  else:
                    useValue = self.Stackstyle['facecolorAlt']
                  handle.set_facecolor(useValue)
              else:
                if(key in ['hatch', 'hatchMultiply']):
                  key = 'hatch'
                  value = self.Stackstyle['hatch'] * self.Stackstyle['hatchMultiply']
                method = 'set_'+key
                if (hasattr(handle, method)):
                  method2call = getattr(handle, method)
                  method2call(value)
    
            if(handle in [self.handleStack, self.handleStackNeg]):
              if(key.startswith('facecolor')):
                if(key == 'facecolor'):
                  self.rememberSettingStack[key] = 'set_facecolor(' + repr(value) + ')'
                else:
                  self.rememberSettingStackNeg[key] = 'set_facecolor(' + repr(value) + ')'
              else:
                self.rememberSettingStack[key] = 'set_' + key + '(' + repr(value) + ')'
                self.rememberSettingStackNeg[key] = 'set_' + key + '(' + repr(value) + ')'
        else:
          # prevent update of plot
          changed = False
  
        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def setTextStyle(self, key, value, redraw=True, rescale=False):
    # changes the textstyle value
    if(key in self.Textstyle):
      if(self.Textstyle[key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Textstyle[key] = value
      # cause plot to be updated
      if(key in ['showText', 'skip', 'padX', 'padY', 'type']):
        self.drawMe(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        if(self.handleText != None):
          method = 'set_' + key
          if (hasattr(self.handleText[0], method)):
            safeFont = 'DejaVu Sans'
            updateFlag = True
            for item in self.handleText:
              method2call = getattr(item, method)
              method2call(value)
              # special treatment for font type to catch errors
              if(key == 'fontname'):
                _, _, descent = item._get_layout(self.parent.plotArea.matplot.canvas.renderer)
                if(not (descent > 0)):
                  self.parent.statusbar.showMessage('Experiencing problems setting font ' + value + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
                  value = safeFont
                  method2call(value)

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def toggleViolinBodyFill(self, value, redraw=True):
    # toggles violin body fill
    if(self.Violinstyle['bodies']['doFill'] == value):
      redraw = False

    self.Violinstyle['bodies']['doFill'] = value
    # adjust value
    if(value):
      value = self.Violinstyle['bodies']['facecolor']
    else:
      value = 'none'
    # cause plot to be updated
    updateFlag = False
    # toggle fill
    if(self.handleViolin != None):
      for entry in self.handleViolin['bodies']:
        entry.set_facecolor(value)
      updateFlag = True
    if(self.handleViolin_div != None):
      for entry in self.handleViolin_div['bodies']:
        entry.set_facecolor(value)
      updateFlag = True

    if(redraw and self.visibility and updateFlag):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def setViolinStyle(self, subtarget, key, value, redraw=True, rescale=True):
    # changes the violinstyle value
    if((subtarget != None) and (subtarget in self.Violinstyle) and (key in self.Violinstyle[subtarget])):
      if(self.Violinstyle[subtarget][key] == value):
        redraw, changed = False, False
      else:
        changed = True
      self.Violinstyle[subtarget][key] = value
      # cause plot to be updated
      if(key in ['width']):
        self.drawMe(redraw=redraw, rescale=rescale)
      else:
        updateFlag = False
        # special treatment for markerfacecolor
        if((key != 'markerfacecolor') or self.Violinstyle['fliers']['doFill']):
          for handleViolin in [self.handleViolin, self.handleViolin_div]:
            if(handleViolin != None):
              if(key == 'boxFill'):
                self.drawMe(redraw=redraw, rescale=False)
                redraw = False
              elif((subtarget == 'boxes') and (key == 'facecolor')):
                # need to redraw here to deal with monkey business related to how filled/unfilled boxes are drawn
                if(self.Violinstyle['boxes']['boxFill']):
                  self.drawMe(redraw=redraw, rescale=False)
                redraw = False
              else:
                if(key in ['hatch', 'hatchMultiply']):
                  key = 'hatch'
                  value = self.Violinstyle[subtarget]['hatch'] * self.Violinstyle[subtarget]['hatchMultiply']
                if((subtarget == 'boxes') and (key == 'edgecolor') and (not self.Violinstyle['boxes']['boxFill'])):
                  # this is ugly -- boxes with no fill respect color instead of edgecolor
                  key = 'color'
                method = 'set_' + key
                if(subtarget in handleViolin):
                  if(type(handleViolin[subtarget]) == type([])):
                    # for time being slave cmins to cmaxes
                    if(subtarget in ['cmaxes', 'cmins']):
                      targetList = handleViolin['cmaxes'] + handleViolin['cmins']
                    elif((subtarget in ['cmeans', 'cmedians']) and (key != 'visible')):
                      targetList = handleViolin['cmeans'] + handleViolin['cmedians']
                    elif((subtarget in ['means', 'medians']) and (key != 'visible')):
                      targetList = handleViolin['means'] + handleViolin['medians']
                    else:
                      targetList = handleViolin[subtarget]
                    for item in targetList:
                      if(hasattr(item, method)):
                        method2call = getattr(item, method)
                        method2call(value)
                      elif((key == 'dash_capstyle') and hasattr(item, 'set_capstyle')):
                        # need this if box is plotted as patch
                        item.set_capstyle(value)
                      # alpha channel of color is somehow ignored -- need to manually set alpha for the entire object though :(
                      if(('color' in key) and (type(value) == type([]))):
                        item.set_alpha(value[-1])
                  else:
                    if(subtarget in ['cmaxes', 'cmins']):
                      targetList = ['cmaxes', 'cmins']
                    elif((subtarget in ['cmeans', 'cmedians']) and (key != 'visible')):
                      targetList = ['cmeans', 'cmedians']
                    elif((subtarget in ['means', 'medians']) and (key != 'visible')):
                      targetList = ['means', 'medians']
                    else:
                      targetList = [subtarget]
                      
                    for target in targetList:
                      if(hasattr(handleViolin[target], method)):
                        method2call = getattr(handleViolin[target], method)
                        method2call(value)
                      elif((key == 'dash_capstyle') and hasattr(handleViolin[target], 'set_capstyle')):
                        # need this if box is plotted as patch
                        handleViolin[target].set_capstyle(value)
              updateFlag = True
        else:
          # prevent update of plot
          changed = False

        if(redraw and self.visibility and updateFlag):
          self.parent.plotArea.dataplotwidget.myRefresh()
      return (changed and self.visibility)

  def setData(self, data=[], roles=[], labels=[]):
    # use this function to change the data value
    # check whether roles have been provided
    if(len(roles)):
      if(('x' in roles) and ('y' in roles)):
        self.x = data[:, roles.index('x')]
        self.y = data[:, roles.index('y')]
        if ('xerr' in roles):
          self.xerr = data[:, roles.index('xerr')]
        else:
          self.xerr = np.array([])
        if ('yerr' in roles):
          self.yerr = data[:, roles.index('yerr')]
        else:
          self.yerr = np.array([])
    else:
      if(len(data)):
        self.xerr = np.array([]); self.yerr = np.array([])
        array_dim = data.shape
        if (len(array_dim)>1 and array_dim[1]>1):
          # okay found valid data, now assign values
          self.x = data[:, 0]
          if (array_dim[1] == 2):
            self.y = data[:, 1]
          elif (array_dim[1] == 3):
            self.y = data[:, 1]
            self.yerr = data[:, 2]
          else:
            self.xerr = data[:, 1]
            self.y = data[:, 2]
            self.yerr = data[:, 3]
    
    # assign labels
    self.labels = labels
            
    # clear fval and resid (need to do this as x values and dimensions probably will have changed)
    self.fval = np.array([])
    self.resid = np.array([])
  
  def value(self):
    # use this function to read out value of data object
    data = {}
    if (len(self.x)):
      data['x'] = self.x
    if (len(self.y)):
      data['y'] = self.y
    if (len(self.xerr)):
      data['xerr'] = self.xerr
    if (len(self.yerr)):
      data['yerr'] = self.yerr
    if (len(self.fval)):
      data['fval'] = self.fval
    if (len(self.resid)):
      data['resid'] = self.resid
      
    return data

class markerStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(markerStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    
    # int and float validators
    self.validInt = MyValidInt()
    self.validFloat = MyValidFloat()

    # valid line styles
    self.markerstyles = []
    self.markerstyles.extend(matplotlib.lines.Line2D.markers)
    # weed out duplicate blank items
    blankItems = [i for i in self.markerstyles if i in ['', ' ', 'None', None]]
    while (len(blankItems) - 1):
      killItem = blankItems[-1]
      self.markerstyles = [i for i in self.markerstyles if i != killItem]
      blankItems = blankItems[:-1]
    self.orderedstyles = ['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+',\
                          'x', 'D', 'd', '|', '_', 'P', 'X', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 'None', None, ' ', '']
    self.orderedstyles = [i for i in self.orderedstyles if (i in self.markerstyles)]

    self.fillstyles = [i for i in matplotlib.lines.Line2D.fillStyles if not i in ['', 'none', 'None', None]]
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidStyle()
      else:
        getStyle = self.target.getStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['markerfacecolor'] = [1.0, 1.0, 1.0, 1.0]
      self.style['markerfacecoloralt'] = [0.0, 1.0, 1.0, 1.0]
      self.style['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
      self.style['markeredgewidth'] = 1.0
      self.style['markersize'] = 8.0
      self.style['marker'] = 'o'
      self.style['fillstyle'] = 'full'
      self.style['markevery'] = 1
      self.style['doFill'] = True
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.markerStyleLabel = QtWidgets.QLabel()
    self.markerStyleLabel.setText('Marker')
    font = self.markerStyleLabel.font()
    font.setBold(True)
    self.markerStyleLabel.setFont(font)
    self.vLayout.addWidget(self.markerStyleLabel)    
    
    # marker size
    self.markerSizeGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerSizeGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.markerSizeGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.markerSizeLabel = QtWidgets.QLabel('Size')
    self.markerSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.markerSizeLabel)
    self.markerSizeEntry = QLineEditClick()
    self.markerSizeEntry.setText(str(self.style['markersize']))
    self.markerSizeEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerSizeEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerSizeEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'markersize', self.markerSizeEntry, 0.0, 100.0, False))
    self.markerSizeEntry.setValidator(self.validFloat)
    self.hLayout.addWidget(self.markerSizeEntry)
    
    # marker facecolor
    self.markerFaceColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerFaceColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.markerFaceColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.markerFaceColorLabel = QPushButtonCheckable()
    self.markerFaceColorLabel.setText('Face')
    self.markerFaceColorLabel.setChecked(self.style['doFill'])
    self.markerFaceColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFaceColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFaceColorLabel.clicked.connect(partial(self.toggleMarkerFill, self.target, self.markerFaceColorLabel))
    self.hLayout2.addWidget(self.markerFaceColorLabel)
    
    self.markerFaceColorButton = QPushButtonMac()
    self.markerFaceColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['markerfacecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerFaceColorButton.setStyleSheet(colorstr)
    self.markerFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerFaceColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markerfacecolor'))
    self.hLayout2.addWidget(self.markerFaceColorButton)
      
    # marker edgecolor
    self.markerEdgeColorLabel = QtWidgets.QLabel('Edge')
    self.markerEdgeColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.markerEdgeColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.markerEdgeColorLabel)

    self.markerEdgeColorButton = QPushButtonMac()
    self.markerEdgeColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['markeredgecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerEdgeColorButton.setStyleSheet(colorstr)
    self.markerEdgeColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerEdgeColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markeredgecolor'))
    self.hLayout2.addWidget(self.markerEdgeColorButton)
      
    # marker edge width
    self.markerEdgeWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerEdgeWidthGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.markerEdgeWidthGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.markerEdgeWidthLabel = QtWidgets.QLabel('Edgewidth')
    self.markerEdgeWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.markerEdgeWidthLabel)
    self.markerEdgeWidthEntry = QLineEditClick()
    self.markerEdgeWidthEntry.setText(str(self.style['markeredgewidth']))
    self.markerEdgeWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'markeredgewidth', self.markerEdgeWidthEntry, 0.0, 100.0, False))
    self.markerEdgeWidthEntry.setValidator(self.validFloat)
    self.hLayout4.addWidget(self.markerEdgeWidthEntry)
    
    # marker style
    self.markerStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerStyleGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.markerStyleGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.markerStyleLabel = QtWidgets.QLabel('Style')
    self.markerStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.markerStyleLabel)
    self.comboStyle = QComboBoxMac()
    for entry in self.orderedstyles:
      self.comboStyle.addItem(str(entry))
    if(self.style['marker'] in self.orderedstyles):
      currindex = self.orderedstyles.index(self.style['marker'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'marker', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.comboStyle)    

    # marker fill style
    self.markerFillStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerFillStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.markerFillStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)

    self.markerFillStyleLabel = QtWidgets.QLabel('Fillstyle')
    self.markerFillStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFillStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.markerFillStyleLabel)
    self.comboFillStyle = QComboBoxMac()
    for entry in self.fillstyles:
      self.comboFillStyle.addItem(str(entry))
    if(self.style['fillstyle'] in self.fillstyles):
      currindex = self.fillstyles.index(self.style['fillstyle'])
    else:
      currindex = 0
    self.comboFillStyle.setCurrentIndex(currindex)
    self.comboFillStyle.activated.connect(partial(self.selectStyle, self.target, 'fillstyle', self.comboFillStyle))
    self.comboFillStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboFillStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboFillStyle)    

    self.markerAltColorButton = QPushButtonMac()
    self.markerAltColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['markerfacecoloralt'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerAltColorButton.setStyleSheet(colorstr)
    self.markerAltColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerAltColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markerfacecoloralt'))
    self.hLayout3.addWidget(self.markerAltColorButton)

    # markevery group
    self.markerEveryGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerEveryGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.markerEveryGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.markerEveryLabel = QtWidgets.QLabel('Mark every')
    self.markerEveryLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEveryLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.markerEveryLabel)
    self.markerEveryEntry = QLineEditClick()
    self.markerEveryEntry.setText(str(self.style['markevery']))
    self.markerEveryEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerEveryEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerEveryEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'markevery', self.markerEveryEntry, 1, None, True))
    self.markerEveryEntry.setValidator(self.validInt)
    self.hLayout6.addWidget(self.markerEveryEntry)
    
  def setColor(self, target = None, key = None):
    if((target != None) and (key != None)):
      # get current color
      if (key in target.style):
        prevColor = [255*i for i in target.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        if(self.residMode):
          target.setResidStyle(key, value, redraw=True)
        else:
          changed = target.setStyle(key, value, redraw=False)
          # update legend if needed
          self.updateLegend(redraw=changed)

  def toggleMarkerFill(self, target = None, entryfield = None):
    # toggles whether to fill markers or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['doFill'] = value
      if(self.residMode):
        target.toggleResidMarkerFill(value, redraw=True)
      else:
        changed = target.toggleMarkerFill(value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)
    
  def selectStyle(self, target = None, key = None, entryfield = None):
    if((target != None) and (key != None)):
      index = entryfield.currentIndex()
      if(key == 'marker'):
        value = self.orderedstyles[index]
      else:
        value = self.fillstyles[index]
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      else:
        changed = target.setStyle(key, value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)

  def changeStyle(self, target = None, key = None, entryfield = None, minval = 0, maxval = 1, integer=False):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        if(integer):
          value = int(entryfield.text())
        else:
          value = float(entryfield.text())
        originalvalue = value
      except:
        if(integer):
          value = 0
          originalvalue = 1
        else:
          value = 0.0
          originalvalue = 1.0
      if(maxval != None):
        if(integer):
          value = min(value, maxval)
        else:
          value = np.min((value, maxval))
      if(minval != None):
        if(integer):
          value = max(value, minval)
        else:
          value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      else:
        changed = target.setStyle(key, value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class lineStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False, residZero=False):
    super(lineStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    self.residZero = residZero
    
    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidStyle()
      else:
        if(self.residZero):
          getStyle = self.parent.parent.parent.data[self.parent.parent.parent.activeData].getResidLineStyle()
        else:
          getStyle = self.target.getStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    
    # set default values
    defaultStyle = {'linewidth': 1.0, 'color': [0, 0, 0, 1], 'linestyle': 'solid', 'dash_capstyle': 'butt'}
    for entry in defaultStyle:
      if(not (entry in self.style)):
        self.style[entry] = defaultStyle[entry]

    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # heading
    self.lineStyleLabel = QtWidgets.QLabel()
    self.lineStyleLabel.setText('Line')
    font = self.lineStyleLabel.font()
    font.setBold(True)
    self.lineStyleLabel.setFont(font)
    self.vLayout.addWidget(self.lineStyleLabel)    
    
    # line width
    self.lineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineWidthGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.lineWidthGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthLabel = QtWidgets.QLabel('Width')
    self.lineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.lineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.lineWidthLabel)
    self.lineWidthEntry = QLineEditClick()
    self.lineWidthEntry.setText(str(self.style['linewidth']))
    self.lineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'linewidth', self.lineWidthEntry, 0.0, 100.0))
    self.lineWidthEntry.setValidator(self.validFloat)
    self.hLayout.addWidget(self.lineWidthEntry)
    
    # line color
    self.lineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.lineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorLabel = QtWidgets.QLabel('Color')
    self.lineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.lineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.lineColorLabel)
      
    self.lineColorButton = QPushButtonMac()
    self.lineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['color'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.lineColorButton.setStyleSheet(colorstr)
    self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'color'))
    self.hLayout2.addWidget(self.lineColorButton)
      
    # line style
    self.lineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleLabel = QtWidgets.QLabel('Style')
    self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.lineStyleLabel)
    self.comboStyle = QComboBoxMac()
    for entry in self.linestyles:
      self.comboStyle.addItem(entry)
    if(self.style['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['linestyle'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'linestyle', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboStyle)
    
    # cap style
    self.lineDashStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineDashStyleGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.lineDashStyleGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.lineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.lineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.lineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.lineDashStyleLabel)
    self.comboDashStyle = QComboBoxMac()
    for entry in self.dashstyles:
      self.comboDashStyle.addItem(entry)
    if(self.style['dash_capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['dash_capstyle'])
    else:
      currindex = 0
    self.comboDashStyle.setCurrentIndex(currindex)
    self.comboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'dash_capstyle', self.comboDashStyle))
    self.comboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.comboDashStyle)

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # get current color
      if (key in self.style):
        prevColor = [255*i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        if(self.residMode):
          target.setResidStyle(key, value, redraw=True)
        elif(self.residZero):
          self.parent.parent.parent.data[self.parent.parent.parent.activeData].setResidLineStyle(key, value, redraw=True)
        else:
          changed = target.setStyle(key, value, redraw=False)
          # update legend if needed
          self.updateLegend(redraw=changed)
    
  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      elif(self.residZero):
        self.parent.parent.parent.data[self.parent.parent.parent.activeData].setResidLineStyle(key, value, redraw=True)
      else:
        changed = target.setStyle(key, value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)
      
  def changeStyle(self, target=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      elif(self.residZero):
        self.parent.parent.parent.data[self.parent.parent.parent.activeData].setResidLineStyle(key, value, redraw=True)
      else:
        changed = target.setStyle(key, value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class barStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(barStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    
    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.linestyles = ['solid', 'dashed', 'dashdot', 'dotted']
    
    # valid hatch styles
    self.hatchstyles = ['None', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*'] # unfortunately none is not interpreted correctly
    self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
    self.dashstyles = ['butt', 'round', 'projecting']
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidBarStyle()
      else:
        getStyle = self.target.getBarStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['linewidth'] = 0.5
      self.style['linestyle'] = 'solid'
      self.style['facecolor'] = [0.8, 0.0, 0.0, 0.5]
      self.style['facecolorAlt'] = [0.3, 0.2, 0.6, 1.0]
      self.style['edgecolor'] = [0.3, 0.3, 0.3, 1.0]
      self.style['width'] = 0.1
      self.style['hatch'] = 'None'
      self.style['hatchMultiply'] = 1
      self.style['showBar'] = False
      self.style['offset'] = 0
      self.style['doFill'] = True
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.displayGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.barStyleLabel = QtWidgets.QLabel()
    self.barStyleLabel.setText('Bar')
    font = self.barStyleLabel.font()
    font.setBold(True)
    self.barStyleLabel.setFont(font)
    self.barStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.barStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.barStyleLabel)    
    
    # display bar?
    self.displayLabel = QPushButtonCheckable()
    self.displayLabel.setText('Show?')
    self.displayLabel.setChecked(self.style['showBar'])
    self.displayLabel.clicked.connect(partial(self.setDisplay, self.target))
    self.displayLabel.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displayLabel.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayLabel)
    
    # line width
    self.lineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineWidthGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.lineWidthGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthLabel = QtWidgets.QLabel('Linewidth')
    self.lineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.lineWidthLabel)
    self.lineWidthEntry = QLineEditClick()
    self.lineWidthEntry.setText(str(self.style['linewidth']))
    self.lineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'linewidth', self.lineWidthEntry, 0.0, 100.0))
    self.lineWidthEntry.setValidator(self.validFloat)
    self.hLayout.addWidget(self.lineWidthEntry)
    
    # line color
    self.lineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.lineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorLabel = QtWidgets.QLabel('Linecolor')
    self.lineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.lineColorLabel)
      
    self.lineColorButton = QPushButtonMac()
    self.lineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['edgecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.lineColorButton.setStyleSheet(colorstr)
    self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'edgecolor'))
    self.hLayout2.addWidget(self.lineColorButton)
      
    # line style
    self.lineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleLabel = QtWidgets.QLabel('Linestyle')
    self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.lineStyleLabel)
    self.comboStyle = QComboBoxMac()
    for entry in self.linestyles:
      self.comboStyle.addItem(entry)
    if(self.style['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['linestyle'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'linestyle', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboStyle)

    # cap style
    self.lineDashStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineDashStyleGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.lineDashStyleGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.lineDashStyleLabel = QtWidgets.QLabel('Linecap')
    self.lineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.lineDashStyleLabel)
    self.comboDashStyle = QComboBoxMac()
    for entry in self.dashstyles:
      self.comboDashStyle.addItem(entry)
    if(self.style['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['capstyle'])
    else:
      currindex = 0
    self.comboDashStyle.setCurrentIndex(currindex)
    self.comboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'capstyle', self.comboDashStyle))
    self.comboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.comboDashStyle)

    # fill color
    self.fillColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.fillColorGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.fillColorGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.fillColorLabel = QPushButtonCheckable()
    self.fillColorLabel.setText('Fillcolor')
    self.fillColorLabel.setChecked(self.style['doFill'])
    self.fillColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorLabel.clicked.connect(partial(self.toggleBarFill, self.target, self.fillColorLabel))
    self.hLayout5.addWidget(self.fillColorLabel)
      
    self.fillColorButton = QPushButtonMac()
    self.fillColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['facecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.fillColorButton.setStyleSheet(colorstr)
    self.fillColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'facecolor'))
    self.hLayout5.addWidget(self.fillColorButton)
      
    self.fillColorButtonAlt = QPushButtonMac()
    self.fillColorButtonAlt.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['facecolorAlt'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.fillColorButtonAlt.setStyleSheet(colorstr)
    self.fillColorButtonAlt.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButtonAlt.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButtonAlt.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorButtonAlt.clicked.connect(partial(self.setColor, target = self.target, key = 'facecolorAlt'))
    self.hLayout5.addWidget(self.fillColorButtonAlt)
      
    # hatch style
    self.hatchStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.hatchStyleGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.hatchStyleGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.hatchStyleLabel = QtWidgets.QLabel('Hatch')
    self.hatchStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hatchStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.hatchStyleLabel)
    self.comboHatchStyle = QComboBoxMac()
    for entry in self.hatchstyles:
      self.comboHatchStyle.addItem(entry)
    if(self.style['hatch'] in self.hatchstyles):
      currindex = self.hatchstyles.index(self.style['hatch'])
    else:
      currindex = 0
    self.comboHatchStyle.setCurrentIndex(currindex)
    self.comboHatchStyle.activated.connect(partial(self.selectStyle, self.target, 'hatch', self.comboHatchStyle))
    self.comboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.comboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.comboHatchStyle)
    self.comboHatchMultiplyStyle = QComboBoxMac()
    for entry in self.hatchMultiplystyles:
      self.comboHatchMultiplyStyle.addItem(str(entry))
    if(str(self.style['hatchMultiply']) in self.hatchMultiplystyles):
      currindex = self.hatchMultiplystyles.index(str(self.style['hatchMultiply']))
    else:
      currindex = 0
    self.comboHatchMultiplyStyle.setCurrentIndex(currindex)
    self.comboHatchMultiplyStyle.activated.connect(partial(self.selectStyle, self.target, 'hatchMultiply', self.comboHatchMultiplyStyle))
    self.comboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.comboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.comboHatchMultiplyStyle)

    # bar width
    self.barWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.barWidthGroup)
    self.hLayout7 = QtWidgets.QHBoxLayout(self.barWidthGroup)
    self.hLayout7.setContentsMargins(0, 0, 0, 0)
    self.hLayout7.setAlignment(QtCore.Qt.AlignLeft)
    self.barWidthLabel = QtWidgets.QLabel('Barwidth')
    self.barWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.barWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout7.addWidget(self.barWidthLabel)
    self.barWidthEntry = QLineEditClick()
    self.barWidthEntry.setText(str(self.style['width']))
    self.barWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.barWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.barWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'width', self.barWidthEntry, 0.0, 1000.0))
    self.barWidthEntry.setValidator(self.validFloat)
    self.hLayout7.addWidget(self.barWidthEntry)
    
    # bar offset
    self.barOffsetGroup = QWidgetMac()
    self.vLayout.addWidget(self.barOffsetGroup)
    self.hLayout8 = QtWidgets.QHBoxLayout(self.barOffsetGroup)
    self.hLayout8.setContentsMargins(0, 0, 0, 0)
    self.hLayout8.setAlignment(QtCore.Qt.AlignLeft)
    self.barOffsetLabel = QtWidgets.QLabel('Offset')
    self.barOffsetLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.barOffsetLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout8.addWidget(self.barOffsetLabel)
    self.barOffsetEntry = QLineEditClick()
    self.barOffsetEntry.setText(str(self.style['offset']))
    self.barOffsetEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.barOffsetEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.barOffsetEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'offset', self.barOffsetEntry, -1000.0, 1000.0))
    self.barOffsetEntry.setValidator(self.validFloat)
    self.hLayout8.addWidget(self.barOffsetEntry)
    
  def setDisplay(self, target=None):
    # toggled display of bar graphics
    if(target != None):
      self.style['showBar'] = self.displayLabel.isChecked()
      if(self.residMode):
        target.toggleResidBar(self.style['showBar'])
      else:
        target.toggleBar(self.style['showBar'])

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # get current color
      if (key in self.style):
        prevColor = [255*i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        if(self.residMode):
          target.setResidBarStyle(key, value, redraw=True)
        else:
          target.setBarStyle(key, value, redraw=True)
        # update legend if needed - not needed as bars do not feature in legend
        #self.updateLegend()
    
  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      #value = str(self.comboStyle.currentText())
      value = str(entryfield.currentText())
      if(key in self.style):
        if(key == 'hatchMultiply'):
          value = int(value)
        self.style[key] = value
      if(self.residMode):
        target.setResidBarStyle(key, value, redraw=True)
      else:
        target.setBarStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()

  def toggleBarFill(self, target = None, entryfield = None):
    # toggles whether to fill bars or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['doFill'] = value
      if(self.residMode):
        target.toggleResidBarFill(value, redraw=True)
      else:
        changed = target.toggleBarFill(value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)
      
  def changeStyle(self, target=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidBarStyle(key, value, redraw=True)
      else:
        target.setBarStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class stackStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(stackStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    
    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.linestyles = ['solid', 'dashed', 'dashdot', 'dotted']
    
    # valid hatch styles
    self.hatchstyles = ['None', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*'] # unfortunately none is not interpreted correctly
    self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
    self.dashstyles = ['butt', 'round', 'projecting']
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidStackStyle()
      else:
        getStyle = self.target.getStackStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['linewidth'] = 0.5
      self.style['linestyle'] = 'solid'
      self.style['facecolor'] = [0.8, 0.0, 0.0, 0.5]
      self.style['facecolorAlt'] = [0.3, 0.2, 0.6, 1.0]
      self.style['edgecolor'] = [0.3, 0.3, 0.3, 1.0]
      self.style['hatch'] = 'None'
      self.style['hatchMultiply'] = 1
      self.style['showStack'] = False
      self.style['doFill'] = True
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.displayGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.stackStyleLabel = QtWidgets.QLabel()
    self.stackStyleLabel.setText('Stack')
    font = self.stackStyleLabel.font()
    font.setBold(True)
    self.stackStyleLabel.setFont(font)
    self.stackStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.stackStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.stackStyleLabel)    
    
    # display stack?
    self.displayLabel = QPushButtonCheckable()
    self.displayLabel.setText('Show?')
    self.displayLabel.setChecked(self.style['showStack'])
    self.displayLabel.clicked.connect(partial(self.setDisplay, self.target))
    self.displayLabel.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displayLabel.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayLabel)
    
    # line width
    self.lineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineWidthGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.lineWidthGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthLabel = QtWidgets.QLabel('Linewidth')
    self.lineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.lineWidthLabel)
    self.lineWidthEntry = QLineEditClick()
    self.lineWidthEntry.setText(str(self.style['linewidth']))
    self.lineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'linewidth', self.lineWidthEntry, 0.0, 100.0))
    self.lineWidthEntry.setValidator(self.validFloat)
    self.hLayout.addWidget(self.lineWidthEntry)
    
    # line color
    self.lineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.lineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorLabel = QtWidgets.QLabel('Linecolor')
    self.lineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.lineColorLabel)
      
    self.lineColorButton = QPushButtonMac()
    self.lineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['edgecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.lineColorButton.setStyleSheet(colorstr)
    self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'edgecolor'))
    self.hLayout2.addWidget(self.lineColorButton)
      
    # line style
    self.lineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleLabel = QtWidgets.QLabel('Linestyle')
    self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.lineStyleLabel)
    self.comboStyle = QComboBoxMac()
    for entry in self.linestyles:
      self.comboStyle.addItem(entry)
    if(self.style['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['linestyle'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'linestyle', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboStyle)

    # fill color
    self.fillColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.fillColorGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.fillColorGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.fillColorLabel = QPushButtonCheckable()
    self.fillColorLabel.setText('Fillcolor')
    self.fillColorLabel.setChecked(self.style['doFill'])
    self.fillColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorLabel.clicked.connect(partial(self.toggleStackFill, self.target, self.fillColorLabel))
    self.hLayout5.addWidget(self.fillColorLabel)
      
    self.fillColorButton = QPushButtonMac()
    self.fillColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['facecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.fillColorButton.setStyleSheet(colorstr)
    self.fillColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'facecolor'))
    self.hLayout5.addWidget(self.fillColorButton)
      
      
    self.fillColorButtonAlt = QPushButtonMac()
    self.fillColorButtonAlt.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['facecolorAlt'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.fillColorButtonAlt.setStyleSheet(colorstr)
    self.fillColorButtonAlt.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButtonAlt.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorButtonAlt.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorButtonAlt.clicked.connect(partial(self.setColor, target = self.target, key = 'facecolorAlt'))
    self.hLayout5.addWidget(self.fillColorButtonAlt)
      
    # hatch style
    self.hatchStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.hatchStyleGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.hatchStyleGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.hatchStyleLabel = QtWidgets.QLabel('Hatch')
    self.hatchStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hatchStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.hatchStyleLabel)
    self.comboHatchStyle = QComboBoxMac()
    for entry in self.hatchstyles:
      self.comboHatchStyle.addItem(entry)
    if(self.style['hatch'] in self.hatchstyles):
      currindex = self.hatchstyles.index(self.style['hatch'])
    else:
      currindex = 0
    self.comboHatchStyle.setCurrentIndex(currindex)
    self.comboHatchStyle.activated.connect(partial(self.selectStyle, self.target, 'hatch', self.comboHatchStyle))
    self.comboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.comboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.comboHatchStyle)
    self.comboHatchMultiplyStyle = QComboBoxMac()
    for entry in self.hatchMultiplystyles:
      self.comboHatchMultiplyStyle.addItem(str(entry))
    if(str(self.style['hatchMultiply']) in self.hatchMultiplystyles):
      currindex = self.hatchMultiplystyles.index(str(self.style['hatchMultiply']))
    else:
      currindex = 0
    self.comboHatchMultiplyStyle.setCurrentIndex(currindex)
    self.comboHatchMultiplyStyle.activated.connect(partial(self.selectStyle, self.target, 'hatchMultiply', self.comboHatchMultiplyStyle))
    self.comboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.comboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.comboHatchMultiplyStyle)
    
  def setDisplay(self, target=None):
    # toggled display of bar graphics
    if(target != None):
      self.style['showStack'] = self.displayLabel.isChecked()
      if(self.residMode):
        target.toggleResidStack(self.style['showStack'])
      else:
        target.toggleStack(self.style['showStack'])

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # get current color
      if (key in self.style):
        prevColor = [255*i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        if(self.residMode):
          target.setResidStackStyle(key, value, redraw=True)
        else:
          target.setStackStyle(key, value, redraw=True)
        # update legend if needed - not needed as bars do not feature in legend
        #self.updateLegend()
    
  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      #value = str(self.comboStyle.currentText())
      value = str(entryfield.currentText())
      if(key in self.style):
        if(key == 'hatchMultiply'):
          value = int(value)
        self.style[key] = value
      if(self.residMode):
        target.setResidStackStyle(key, value, redraw=True)
      else:
        target.setStackStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()
      
  def changeStyle(self, target=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStackStyle(key, value, redraw=True)
      else:
        target.setStackStyle(key, value, redraw=True)
      # update legend if needed - not needed as bars do not feature in legend
      #self.updateLegend()

  def toggleStackFill(self, target = None, entryfield = None):
    # toggles whether to fill stacks or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['doFill'] = value
      if(self.residMode):
        target.toggleResidStackFill(value, redraw=True)
      else:
        changed = target.toggleStackFill(value, redraw=False)
        # update legend if needed
        self.updateLegend(redraw=changed)
      
  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class textStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(textStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode
    
    # float and int validators
    self.validInt = MyValidInt()
    self.validFloat = MyValidFloat()

    # set up initial values
    self.style = {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidTextStyle()
      else:
        getStyle = self.target.getTextStyle()
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['showText'] = False
      self.style['skip'] = 0
      self.style['color'] = [0.2, 0.2, 0.2, 1.0]
      self.style['fontsize'] = 12
      self.style['fontweight'] = 'normal'
      self.style['fontstyle'] = 'normal'
      self.style['fontname'] = 'Dejavu Sans'
      self.style['rotation'] = 0.0
      self.style['padX'] = 0.0
      self.style['padY'] = 0.0
      self.style['type'] = 'y'
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.displayGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.textStyleLabel = QtWidgets.QLabel()
    self.textStyleLabel.setText('Text')
    font = self.textStyleLabel.font()
    font.setBold(True)
    self.textStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textStyleLabel.setFont(font)
    self.hLayout0.addWidget(self.textStyleLabel)    
    
    # display stack?
    self.displayLabel = QPushButtonCheckable()
    self.displayLabel.setText('Show?')
    self.displayLabel.setChecked(self.style['showText'])
    self.displayLabel.clicked.connect(partial(self.setDisplay, self.target))
    self.displayLabel.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displayLabel.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayLabel)
    
    # text skip
    self.textSkipGroup = QWidgetMac()
    self.vLayout.addWidget(self.textSkipGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.textSkipGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.textSkipLabel = QtWidgets.QLabel('Skip')
    self.textSkipLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textSkipLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.textSkipLabel)
    self.textSkipEntry = QLineEditClick()
    self.textSkipEntry.setText(str(self.style['skip']))
    self.textSkipEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.textSkipEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.textSkipEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'skip', self.textSkipEntry, 0, 1000, True))
    self.textSkipEntry.setValidator(self.validInt)
    self.hLayout.addWidget(self.textSkipEntry)

    # text pad
    self.textPadGroup = QWidgetMac()
    self.vLayout.addWidget(self.textPadGroup)
    self.hLayout1 = QtWidgets.QHBoxLayout(self.textPadGroup)
    self.hLayout1.setContentsMargins(0, 0, 0, 0)
    self.hLayout1.setAlignment(QtCore.Qt.AlignLeft)
    self.textXLabel = QtWidgets.QLabel(u'\N{GREEK CAPITAL LETTER DELTA}x')
    self.textXLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textXLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout1.addWidget(self.textXLabel)
    self.textXEntry = QLineEditClick()
    self.textXEntry.setText(str(self.style['padX']))
    self.textXEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.textXEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.textXEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'padX', self.textXEntry, None, None, False))
    self.textXEntry.setValidator(self.validFloat)
    self.hLayout1.addWidget(self.textXEntry)

    self.textYLabel = QtWidgets.QLabel(u'\N{GREEK CAPITAL LETTER DELTA}y')
    self.textYLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.textYLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.hLayout1.addWidget(self.textYLabel)
    self.textYEntry = QLineEditClick()
    self.textYEntry.setText(str(self.style['padY']))
    self.textYEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.textYEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.textYEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'padY', self.textYEntry, None, None, False))
    self.textYEntry.setValidator(self.validFloat)
    self.hLayout1.addWidget(self.textYEntry)

    # text font settings
    self.textFontGroup = QWidgetMac()
    self.vLayout.addWidget(self.textFontGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.textFontGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.textFontLabel = QtWidgets.QLabel('Font')
    self.textFontLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textFontLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.textFontLabel)
      
    self.textColorButton = QPushButtonMac()
    self.textColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['color'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.textColorButton.setStyleSheet(colorstr)
    self.textColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.textColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.textColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.textColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'color'))
    self.hLayout2.addWidget(self.textColorButton)

    self.textSizeEntry = QLineEditClick()
    self.textSizeEntry.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.textSizeEntry.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.textSizeEntry.setText(str(self.style['fontsize']))
    self.textSizeEntry.setValidator(self.validFloat)
    self.textSizeEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'fontsize', self.textSizeEntry, 0.0, 100.0, False))
    self.hLayout2.addWidget(self.textSizeEntry)
      
    self.textBoldButton = QPushButtonCheckable()
    self.textBoldButton.setText('B')
    self.textBoldButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.textBoldButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    if(self.style['fontweight'] == 'bold'):
      self.textBoldButton.setChecked(True)
    useFont = self.textBoldButton.font()
    useFont.setWeight(75)
    self.textBoldButton.setFont(useFont)
    self.textBoldButton.clicked.connect(partial(self.changeFontStyle, self.target, 'fontweight', self.textBoldButton))
    self.hLayout2.addWidget(self.textBoldButton)
    
    self.textItalicButton = QPushButtonCheckable()
    self.textItalicButton.setText('I')
    self.textItalicButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.textItalicButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    if(self.style['fontstyle'] == 'italic'):
      self.textItalicButton.setChecked(True)
    useFont = self.textItalicButton.font()
    useFont.setItalic(True)
    self.textItalicButton.setFont(useFont)
    self.textItalicButton.clicked.connect(partial(self.changeFontStyle, self.target, 'fontstyle', self.textItalicButton))
    self.hLayout2.addWidget(self.textItalicButton)
      
    self.textFontGroup2 = QWidgetMac()
    self.vLayout.addWidget(self.textFontGroup2)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.textFontGroup2)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    spacer = QtWidgets.QLabel('')
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(spacer)

    defaultFont = 'DejaVu Sans'
    self.textFontBox = QComboBoxMac()
    self.textFontBox.addItems(self.parent.parent.parent.fontNames)
    self.textFontBox.setMaximumSize(QtCore.QSize(scaledDPI(140), scaledDPI(BASE_SIZE)))
    self.textFontBox.setMinimumSize(QtCore.QSize(scaledDPI(140), scaledDPI(BASE_SIZE)))
    if(self.style['fontname'] in self.parent.parent.parent.fontNames):
      currindex = self.parent.parent.parent.fontNames.index(self.style['fontname'])
      self.textFontBox.setCurrentIndex(currindex)
    elif(defaultFont in self.parent.parent.parent.fontNames):
      currindex = self.parent.parent.parent.fontNames.index(defaultFont)
      self.textFontBox.setCurrentIndex(currindex)
    else:
      self.textFontBox.setCurrentIndex(0)
    self.textFontBox.activated.connect(partial(self.changeFont, self.target))
    self.hLayout3.addWidget(self.textFontBox)
    
    # text rotation
    self.textAngleGroup = QWidgetMac()
    self.vLayout.addWidget(self.textAngleGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.textAngleGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.textAngleLabel = QtWidgets.QLabel('Angle')
    self.textAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.textAngleLabel)
    self.textAngleEntry = QLineEditClick()
    self.textAngleEntry.setText(str(self.style['rotation']))
    self.textAngleEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.textAngleEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.textAngleEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'rotation', self.textAngleEntry, 0.0, 360.0, False))
    self.textAngleEntry.setValidator(self.validFloat)
    self.hLayout4.addWidget(self.textAngleEntry)    
    
    # text type
    self.textTypeGroup = QWidgetMac()
    self.vLayout.addWidget(self.textTypeGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.textTypeGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.textTypeLabel = QtWidgets.QLabel('Type')
    self.textTypeLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.textTypeLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.textTypeLabel)

    self.textTypes = ['x', 'y', 'labels']
    self.textTypeBox = QComboBoxMac()
    self.textTypeBox.addItems(self.textTypes)
    self.textTypeBox.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.textTypeBox.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    if(self.style['type'] in self.textTypes):
      currindex = self.textTypes.index(self.style['type'])
      self.textTypeBox.setCurrentIndex(currindex)
    else:
      self.textTypeBox.setCurrentIndex(0)
    self.textTypeBox.activated.connect(partial(self.selectStyle, self.target, 'type', self.textTypeBox))
    self.hLayout5.addWidget(self.textTypeBox)

  def setDisplay(self, target=None):
    # toggled display of text graphics
    if(target != None):
      self.style['showText'] = self.displayLabel.isChecked()
      if(self.residMode):
        target.toggleResidText(self.style['showText'])
      else:
        target.toggleText(self.style['showText'])

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # get current color
      if (key in self.style):
        prevColor = [255*i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        if(self.residMode):
          target.setResidTextStyle(key, value, redraw=True)
        else:
          target.setTextStyle(key, value, redraw=True)
        # update legend if needed - not needed as bars do not feature in legend
        #self.updateLegend()

  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidTextStyle(key, value, redraw=True)
      else:
        target.setTextStyle(key, value, redraw=True)
        # update legend if needed - not needed as errors do not feature in legend
        #self.updateLegend(redraw=True)
    
  def changeStyle(self, target=None, key=None, entryfield=None, minval=0, maxval=1, integer=False):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        if(integer):
          value = int(entryfield.text())
        else:
          value = float(entryfield.text())
        originalvalue = value
      except:
        if(integer):
          value = 0
          originalvalue = 1
        else:
          value = 0.0
          originalvalue = 1.0
      if(maxval != None):
        if(integer):
          value = min(value, maxval)
        else:
          value = np.min((value, maxval))
      if(minval != None):
        if(integer):
          value = max(value, minval)
        else:
          value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidTextStyle(key, value, redraw=True)
      else:
        target.setTextStyle(key, value, redraw=True)
      # update legend if needed - not needed as text does not feature in legend
      #self.updateLegend()

  def changeFontStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key in ['fontweight', 'fontstyle']) and (entryfield != None)):
      value = 'normal'
      isChecked = entryfield.isChecked()
      if(key == 'fontweight'):
        if(isChecked):
          value = 'bold'
      else:
        if(isChecked):
          value = 'italic'
      if(self.residMode):
        target.setResidTextStyle(key, value, redraw=True)
      else:
        target.setTextStyle(key, value, redraw=True)
    
  def changeFont(self, target=None):
    if(target != None):
      useFont = str(self.textFontBox.currentText())
      if(self.residMode):
        target.setResidTextStyle('fontname', useFont, redraw=True)
      else:
        target.setTextStyle('fontname', useFont, redraw=True)

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

class errorStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None, residMode=False):
    super(errorStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    self.residMode = residMode

    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.markerstyles = []
    self.markerstyles.extend(matplotlib.lines.Line2D.markers)
    # weed out duplicate blank items
    blankItems = [i for i in self.markerstyles if i in ['', ' ', 'None', None]]
    while (len(blankItems) - 1):
      killItem = blankItems[-1]
      self.markerstyles = [i for i in self.markerstyles if i != killItem]
      blankItems = blankItems[:-1]
    self.orderedstyles = ['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+',\
                          'x', 'D', 'd', '|', '_', 'P', 'X', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 'None', None, ' ', '']
    self.orderedstyles = [i for i in self.orderedstyles if (i in self.markerstyles)]
      
    self.fillstyles = [i for i in matplotlib.lines.Line2D.fillStyles if not i in ['', 'none', 'None', None]]

    # set up initial values
    self.style, self.shadystyle = {}, {}
    if (self.target != None):
      if(self.residMode):
        getStyle = self.target.getResidStyle()
      else:
        getStyle = self.target.getErrorStyle()
        getShadystyle = self.target.getErrorShadyStyle()
        for entry in getShadystyle:
          self.shadystyle[entry] = getShadystyle[entry]
      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        self.style[entry] = getStyle[entry]
    else:
      self.style['color'] = [0.0, 0.0, 0.0, 1.0]
      self.style['linewidth'] = 1.0
      self.style['marker'] = '_'
      self.style['markerX'] = '|'
      self.style['markeredgewidth'] = 1.0
      self.style['markersize'] = 10.0
      self.style['fillstyle'] = 'full'
      self.style['errorInFront'] = False
      self.style['markerfacecolor'] = [1.0, 1.0, 1.0, 1.0]
      self.style['markerfacecoloralt'] = [0.0, 1.0, 1.0, 1.0]
      self.style['markeredgecolor'] = [0.0, 0.0, 0.0, 1.0]
      self.style['fillstyle'] = 'full'
      self.style['doFill'] = True
      
      self.shadystyle = {}
      self.shadystyle['visible'] = True
      self.shadystyle['facecolor'] = [0.8, 0.2, 0.2, 0.5]
      self.shadystyle['edgecolor'] = [0.8, 0.2, 0.2, 1.0]
      self.shadystyle['linestyle'] = 'None'
      self.shadystyle['linewidth'] = 1.0
      
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.hLayout_top = QtWidgets.QHBoxLayout(self)
    self.hLayout_top.setContentsMargins(0, 0, 0, 0)
    self.hLayout_top.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.topGroup1 = QWidgetMac()
    self.hLayout_top.addWidget(self.topGroup1)
    
    self.vLayout = QtWidgets.QVBoxLayout(self.topGroup1)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    # heading
    self.displayGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.errorStyleLabel = QtWidgets.QLabel()
    self.errorStyleLabel.setText('Error')
    font = self.errorStyleLabel.font()
    font.setBold(True)
    self.errorStyleLabel.setFont(font)
    self.errorStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.errorStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.errorStyleLabel)    
    
    # display error?
    self.displayLabel = QPushButtonCheckable()
    self.displayLabel.setText('Show?')
    self.displayLabel.setChecked(self.style['visible'])
    self.displayLabel.clicked.connect(partial(self.setDisplay, self.target))
    self.displayLabel.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displayLabel.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayLabel)
    
    # show bars in which direction?
    self.directionstyles = ['negative', 'both', 'positive']
    self.directionGroup = QWidgetMac()
    self.vLayout.addWidget(self.directionGroup)
    self.hLayout05 = QtWidgets.QHBoxLayout(self.directionGroup)
    self.hLayout05.setContentsMargins(0, 0, 0, 0)
    self.hLayout05.setAlignment(QtCore.Qt.AlignLeft)
    self.directionLabel = QtWidgets.QLabel('Direction')
    self.directionLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.directionLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout05.addWidget(self.directionLabel)
    self.comboDirection = QComboBoxMac()
    for entry in self.directionstyles:
      self.comboDirection.addItem(entry)
    if(self.style['direction'] in self.directionstyles):
      currindex = self.directionstyles.index(self.style['direction'])
    else:
      currindex = 0
    self.comboDirection.setCurrentIndex(currindex)
    self.comboDirection.activated.connect(partial(self.selectStyle, self.target, 'direction', self.comboDirection))
    self.comboDirection.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboDirection.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout05.addWidget(self.comboDirection)

    # line width
    self.lineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineWidthGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.lineWidthGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthLabel = QtWidgets.QLabel('Linewidth')
    self.lineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.lineWidthLabel)
    self.lineWidthEntry = QLineEditClick()
    self.lineWidthEntry.setText(str(self.style['linewidth']))
    self.lineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'linewidth', self.lineWidthEntry, 0.0, 100.0))
    self.lineWidthEntry.setValidator(self.validFloat)
    self.hLayout.addWidget(self.lineWidthEntry)
    
    # line color
    self.lineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.lineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorLabel = QtWidgets.QLabel('Linecolor')
    self.lineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.lineColorLabel)
    
    self.lineColorButton = QPushButtonMac()
    self.lineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['color'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.lineColorButton.setStyleSheet(colorstr)
    self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'color'))
    self.hLayout2.addWidget(self.lineColorButton)

    # line style
    self.lineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.lineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleLabel = QtWidgets.QLabel('Linestyle')
    self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.lineStyleLabel)
    self.comboStyle = QComboBoxMac()
    for entry in self.linestyles:
      self.comboStyle.addItem(entry)
    if(self.style['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['linestyle'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, 'linestyle', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.comboStyle)
    
    # marker in front?
    self.markerZOrderGroup = QWidgetMac()
    self.vLayout.addWidget(self.markerZOrderGroup)
    self.hLayout7 = QtWidgets.QHBoxLayout(self.markerZOrderGroup)
    self.hLayout7.setContentsMargins(0, 0, 0, 0)
    self.hLayout7.setAlignment(QtCore.Qt.AlignLeft)
    self.markerZOrderLabel = QPushButtonCheckable()
    self.markerZOrderLabel.setText('In front?')
    self.markerZOrderLabel.setChecked(self.style['errorInFront'])
    self.markerZOrderLabel.clicked.connect(partial(self.setZOrder, self.target))
    self.markerZOrderLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.markerZOrderLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout7.addWidget(self.markerZOrderLabel)
    
    # set up configuration of cap style
    divider = self.VLine()
    self.hLayout_top.addWidget(divider)
    self.topGroup3 = QWidgetMac()
    self.hLayout_top.addWidget(self.topGroup3)
    
    self.vLayout3 = QtWidgets.QVBoxLayout(self.topGroup3)
    self.vLayout3.setContentsMargins(0, 0, 0, 0)
    self.vLayout3.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout3.setSpacing(scaledDPI(2))

    # heading
    self.errorStyleLabel3 = QtWidgets.QLabel()
    self.errorStyleLabel3.setText('Cap')
    font = self.errorStyleLabel3.font()
    font.setBold(True)
    self.errorStyleLabel3.setFont(font)
    self.vLayout3.addWidget(self.errorStyleLabel3)    

    # marker size
    self.markerSizeGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerSizeGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.markerSizeGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.markerSizeLabel = QtWidgets.QLabel('Size')
    self.markerSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.markerSizeLabel)
    self.markerSizeEntry = QLineEditClick()
    self.markerSizeEntry.setText(str(self.style['markersize']))
    self.markerSizeEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerSizeEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerSizeEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'markersize', self.markerSizeEntry, 0.0, 100.0))
    self.markerSizeEntry.setValidator(self.validFloat)
    self.hLayout6.addWidget(self.markerSizeEntry)

    # marker facecolor
    self.markerFaceColorGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerFaceColorGroup)
    self.hLayout30 = QtWidgets.QHBoxLayout(self.markerFaceColorGroup)
    self.hLayout30.setContentsMargins(0, 0, 0, 0)
    self.hLayout30.setAlignment(QtCore.Qt.AlignLeft)
    self.markerFaceColorLabel = QPushButtonCheckable()
    self.markerFaceColorLabel.setText('Face')
    self.markerFaceColorLabel.setChecked(self.style['doFill'])
    self.markerFaceColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFaceColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFaceColorLabel.clicked.connect(partial(self.toggleMarkerFill, self.target, self.markerFaceColorLabel))
    self.hLayout30.addWidget(self.markerFaceColorLabel)
    
    self.markerFaceColorButton = QPushButtonMac()
    self.markerFaceColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['markerfacecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerFaceColorButton.setStyleSheet(colorstr)
    self.markerFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerFaceColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markerfacecolor'))
    self.hLayout30.addWidget(self.markerFaceColorButton)
      
    # marker edgecolor
    self.markerEdgeColorLabel = QtWidgets.QLabel('Edge')
    self.markerEdgeColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.markerEdgeColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.hLayout30.addWidget(self.markerEdgeColorLabel)

    self.markerEdgeColorButton = QPushButtonMac()
    self.markerEdgeColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['markeredgecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerEdgeColorButton.setStyleSheet(colorstr)
    self.markerEdgeColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerEdgeColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markeredgecolor'))
    self.hLayout30.addWidget(self.markerEdgeColorButton)

    # marker edge width
    self.markerEdgeWidthGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerEdgeWidthGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.markerEdgeWidthGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.markerEdgeWidthLabel = QtWidgets.QLabel('Edgewidth')
    self.markerEdgeWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.markerEdgeWidthLabel)
    self.markerEdgeWidthEntry = QLineEditClick()
    self.markerEdgeWidthEntry.setText(str(self.style['markeredgewidth']))
    self.markerEdgeWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'markeredgewidth', self.markerEdgeWidthEntry, 0.0, 100.0))
    self.markerEdgeWidthEntry.setValidator(self.validFloat)
    self.hLayout5.addWidget(self.markerEdgeWidthEntry)

    # marker style
    self.markerTypeGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerTypeGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.markerTypeGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.markerTypeLabel = QtWidgets.QLabel('Style')
    self.markerTypeLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerTypeLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.markerTypeLabel)
    self.markerType = QComboBoxMac()
    for entry in self.orderedstyles:
      self.markerType.addItem(str(entry))
    if(self.style['marker'] in self.orderedstyles):
      currindex = self.orderedstyles.index(self.style['marker'])
    else:
      currindex = 0
    self.markerType.setCurrentIndex(currindex)
    self.markerType.activated.connect(partial(self.selectStyle, self.target, 'marker', self.markerType))
    self.markerType.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerType.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.markerType)
    
    # marker styleX
    self.markerTypeXGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerTypeXGroup)
    self.hLayout41 = QtWidgets.QHBoxLayout(self.markerTypeXGroup)
    self.hLayout41.setContentsMargins(0, 0, 0, 0)
    self.hLayout41.setAlignment(QtCore.Qt.AlignLeft)
    self.markerTypeXLabel = QtWidgets.QLabel('StyleX')
    self.markerTypeXLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerTypeXLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout41.addWidget(self.markerTypeXLabel)
    self.markerTypeX = QComboBoxMac()
    # need to exclude certain styles that make matplotlib crash -- this is quite ugly
    excludeStyles = [0, 5, 6, 7, 9, 10, 11]
    self.okayStyles = [i for i in self.orderedstyles if (not i in excludeStyles)]
    for entry in self.okayStyles:
      self.markerTypeX.addItem(str(entry))
    if(self.style['markerX'] in self.okayStyles):
      currindex = self.okayStyles.index(self.style['markerX'])
    else:
      currindex = 0
    self.markerTypeX.setCurrentIndex(currindex)
    self.markerTypeX.activated.connect(partial(self.selectStyle, self.target, 'markerX', self.markerTypeX))
    self.markerTypeX.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerTypeX.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout41.addWidget(self.markerTypeX)
    
    # marker fill style
    self.markerFillStyleGroup = QWidgetMac()
    self.vLayout3.addWidget(self.markerFillStyleGroup)
    self.hLayout31 = QtWidgets.QHBoxLayout(self.markerFillStyleGroup)
    self.hLayout31.setContentsMargins(0, 0, 0, 0)
    self.hLayout31.setAlignment(QtCore.Qt.AlignLeft)

    self.markerFillStyleLabel = QtWidgets.QLabel('Fillstyle')
    self.markerFillStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.markerFillStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout31.addWidget(self.markerFillStyleLabel)
    self.comboFillStyle = QComboBoxMac()
    for entry in self.fillstyles:
      self.comboFillStyle.addItem(str(entry))
    if(self.style['fillstyle'] in self.fillstyles):
      currindex = self.fillstyles.index(self.style['fillstyle'])
    else:
      currindex = 0
    self.comboFillStyle.setCurrentIndex(currindex)
    self.comboFillStyle.activated.connect(partial(self.selectStyle, self.target, 'fillstyle', self.comboFillStyle))
    self.comboFillStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboFillStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout31.addWidget(self.comboFillStyle)    

    self.markerAltColorButton = QPushButtonMac()
    self.markerAltColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['markerfacecoloralt'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerAltColorButton.setStyleSheet(colorstr)
    self.markerAltColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerAltColorButton.clicked.connect(partial(self.setColor, target = self.target, key = 'markerfacecoloralt'))
    self.hLayout31.addWidget(self.markerAltColorButton)

    # set up configuration of error shading
    divider = self.VLine()
    self.hLayout_top.addWidget(divider)
    self.topGroup2 = QWidgetMac()
    self.hLayout_top.addWidget(self.topGroup2)
    
    self.vLayout2 = QtWidgets.QVBoxLayout(self.topGroup2)
    self.vLayout2.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout2.setSpacing(scaledDPI(2))

    # heading
    self.displayShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.displayShadyGroup)
    self.hLayout20 = QtWidgets.QHBoxLayout(self.displayShadyGroup)
    self.hLayout20.setContentsMargins(0, 0, 0, 0)
    self.hLayout20.setAlignment(QtCore.Qt.AlignLeft)
    self.errorStyleLabel2 = QtWidgets.QLabel()
    self.errorStyleLabel2.setText('Shading')
    font = self.errorStyleLabel2.font()
    font.setBold(True)
    self.errorStyleLabel2.setFont(font)
    self.errorStyleLabel2.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.errorStyleLabel2.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout20.addWidget(self.errorStyleLabel2)    

    self.displayShadyCheck = QPushButtonCheckable()
    self.displayShadyCheck.setText('Show?')
    self.displayShadyCheck.setChecked(self.shadystyle['visible'])
    self.displayShadyCheck.clicked.connect(partial(self.setShadyDisplay, self.target))
    self.displayShadyCheck.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displayShadyCheck.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout20.addWidget(self.displayShadyCheck)

    # line width
    self.lineWidthShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.lineWidthShadyGroup)
    self.hLayout21 = QtWidgets.QHBoxLayout(self.lineWidthShadyGroup)
    self.hLayout21.setContentsMargins(0, 0, 0, 0)
    self.hLayout21.setAlignment(QtCore.Qt.AlignLeft)
    self.lineWidthShadyLabel = QtWidgets.QLabel('Linewidth')
    self.lineWidthShadyLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineWidthShadyLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout21.addWidget(self.lineWidthShadyLabel)
    self.lineWidthShadyEntry = QLineEditClick()
    self.lineWidthShadyEntry.setText(str(self.shadystyle['linewidth']))
    self.lineWidthShadyEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthShadyEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.lineWidthShadyEntry.editingFinished.connect(partial(self.changeShadyStyle, self.target, 'linewidth', self.lineWidthShadyEntry, 0.0, 100.0))
    self.lineWidthShadyEntry.setValidator(self.validFloat)
    self.hLayout21.addWidget(self.lineWidthShadyEntry)
    
    # line color
    self.lineColorShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.lineColorShadyGroup)
    self.hLayout22 = QtWidgets.QHBoxLayout(self.lineColorShadyGroup)
    self.hLayout22.setContentsMargins(0, 0, 0, 0)
    self.hLayout22.setAlignment(QtCore.Qt.AlignLeft)
    self.lineColorShadyLabel = QtWidgets.QLabel('Linecolor')
    self.lineColorShadyLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineColorShadyLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout22.addWidget(self.lineColorShadyLabel)
    
    self.lineColorShadyButton = QPushButtonMac()
    self.lineColorShadyButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.shadystyle['edgecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.lineColorShadyButton.setStyleSheet(colorstr)
    self.lineColorShadyButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorShadyButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.lineColorShadyButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.lineColorShadyButton.clicked.connect(partial(self.setShadyColor, target = self.target, key = 'edgecolor'))
    self.hLayout22.addWidget(self.lineColorShadyButton)

    # line style
    self.shadylinestyles = [i for i in self.linestyles if (i != 'None')]
    self.lineStyleShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.lineStyleShadyGroup)
    self.hLayout23 = QtWidgets.QHBoxLayout(self.lineStyleShadyGroup)
    self.hLayout23.setContentsMargins(0, 0, 0, 0)
    self.hLayout23.setAlignment(QtCore.Qt.AlignLeft)
    self.lineStyleShadyLabel = QtWidgets.QLabel('Linestyle')
    self.lineStyleShadyLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.lineStyleShadyLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout23.addWidget(self.lineStyleShadyLabel)
    self.comboShadyStyle = QComboBoxMac()
    for entry in self.shadylinestyles:
      self.comboShadyStyle.addItem(entry)
    if(self.shadystyle['linestyle'] in self.shadylinestyles):
      currindex = self.shadylinestyles.index(self.shadystyle['linestyle'])
    else:
      currindex = 0
    self.comboShadyStyle.setCurrentIndex(currindex)
    self.comboShadyStyle.activated.connect(partial(self.selectShadyStyle, self.target, 'linestyle', self.comboShadyStyle))
    self.comboShadyStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboShadyStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayout23.addWidget(self.comboShadyStyle)
    
    # fill color
    self.fillColorShadyGroup = QWidgetMac()
    self.vLayout2.addWidget(self.fillColorShadyGroup)
    self.hLayout24 = QtWidgets.QHBoxLayout(self.fillColorShadyGroup)
    self.hLayout24.setContentsMargins(0, 0, 0, 0)
    self.hLayout24.setAlignment(QtCore.Qt.AlignLeft)
    self.fillColorShadyLabel = QtWidgets.QLabel('Fillcolor')
    self.fillColorShadyLabel.setMaximumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.fillColorShadyLabel.setMinimumSize(QtCore.QSize(scaledDPI(52), scaledDPI(BASE_SIZE)))
    self.hLayout24.addWidget(self.fillColorShadyLabel)
      
    self.fillColorShadyButton = QPushButtonMac()
    self.fillColorShadyButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.shadystyle['facecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.fillColorShadyButton.setStyleSheet(colorstr)
    self.fillColorShadyButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorShadyButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.fillColorShadyButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.fillColorShadyButton.clicked.connect(partial(self.setShadyColor, target = self.target, key = 'facecolor'))
    self.hLayout24.addWidget(self.fillColorShadyButton)

  def setShadyDisplay(self, target=None):
    # toggled display of error bars
    if(target != None):
      self.shadystyle['visible'] = self.displayShadyCheck.isChecked()
      target.setErrorShadyStyle('visible', self.shadystyle['visible'], redraw=True)

  def setDisplay(self, target=None):
    # toggled display of error bars
    if(target != None):
      self.style['visible'] = self.displayLabel.isChecked()
      target.setErrorStyle('visible', self.style['visible'], redraw=True)

  def setZOrder(self, target=None):
    # toggle relative z order of error bars
    state = self.markerZOrderLabel.isChecked()
    self.style['errorInFront'] = state
    if(target != None):
      target.setZOrderError(state, redraw=True)

  def setColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # get current color
      if (key in self.style):
        prevColor = [255*i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        if(self.residMode):
          target.setResidStyle(key, value, redraw=True)
        else:
          target.setErrorStyle(key, value, redraw=True)
    
  def setShadyColor(self, target=None, key=None):
    if((target != None) and (key != None)):
      # get current color
      if (key in self.shadystyle):
        prevColor = [255*i for i in self.shadystyle[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        target.setErrorShadyStyle(key, value, redraw=True)
          
  def selectStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      if(key == 'marker'):
        value = self.orderedstyles[entryfield.currentIndex()]
      elif(key == 'markerX'):
        value = self.okayStyles[entryfield.currentIndex()]
      else:
        value = str(entryfield.currentText())
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      else:
        target.setErrorStyle(key, value, redraw=True)
        # update legend if needed - not needed as errors do not feature in legend
        #self.updateLegend(redraw=True)
      
  def selectShadyStyle(self, target=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key in self.shadystyle):
        self.shadystyle[key] = value
      target.setErrorShadyStyle(key, value, redraw=True)
      # update legend if needed - not needed as errors do not feature in legend
      #self.updateLegend(redraw=True)

  def toggleMarkerFill(self, target = None, entryfield = None):
    # toggles whether to fill markers or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['doFill'] = value
      if(self.residMode):
        target.toggleResidMarkerFill(value, redraw=True)
      else:
        target.toggleErrorMarkerFill(value, redraw=True)
      
  def changeStyle(self, target=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
      if(self.residMode):
        target.setResidStyle(key, value, redraw=True)
      else:
        target.setErrorStyle(key, value, redraw=True)

  def changeShadyStyle(self, target=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.shadystyle):
        self.shadystyle[key] = value
      target.setErrorShadyStyle(key, value, redraw=True)

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.parent.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.parent.parent.plotArea.setLegend(value=value, redraw=redraw)

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

class ObjectsArea(QWidgetMac):
  def __init__(self, parent = None):
    super(ObjectsArea, self).__init__()
    self.parent = parent
    
    # control display of config menu
    self.displayBarConfig, self.displayErrorConfig, self.displayTextConfig, self.displayLineConfig = False, False, False, True
    self.displayDeclusterConfig, self.displayViolinConfig, self.displayIntervalConfig = False, False, False
    self.declusterTolX, self.declusterTolY = 0.1, 0.1
    
    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)

    self.dataSetContainer = QWidgetMac()
    self.hLayout00 = QtWidgets.QHBoxLayout(self.dataSetContainer)
    self.hLayout00.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.dataSetContainer)
    self.dataSetLabel = QtWidgets.QLabel()
    useFont = self.dataSetLabel.font()
    useFont.setBold(True)
    self.dataSetLabel.setFont(useFont)
    self.dataSetLabel.setText('Data Sets')
    self.hLayout00.addWidget(self.dataSetLabel)
    self.dataSetCreateButton = QPushButtonMac()
    self.dataSetCreateButton.setText('Add Data Set')
    self.dataSetCreateButton.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
    self.dataSetCreateButton.setMaximumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
    self.dataSetCreateButton.clicked.connect(self.dataSetCreate)
    self.hLayout00.addWidget(self.dataSetCreateButton)
    self.hLayout00.addStretch()

    self.dataSetTable = QtWidgets.QTableWidget()
    self.dataSetTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.vLayout.addWidget(self.dataSetTable)
    self.refreshDataTable()

    self.curvesContainer = QWidgetMac()
    self.hLayout0 = QtWidgets.QHBoxLayout(self.curvesContainer)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.curvesContainer)
    self.curvesLabel = QtWidgets.QLabel()
    useFont = self.curvesLabel.font()
    useFont.setBold(True)
    self.curvesLabel.setFont(useFont)
    self.curvesLabel.setText('Curves')
    self.hLayout0.addWidget(self.curvesLabel)
    self.curvesCreateButton = QPushButtonMac()
    self.curvesCreateButton.setText('Add Curve')
    self.curvesCreateButton.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.curvesCreateButton.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.curvesCreateButton.clicked.connect(self.curveCreate)
    self.hLayout0.addWidget(self.curvesCreateButton)
    self.hLayout0.addStretch()

    self.curvesTable = QtWidgets.QTableWidget()
    self.curvesTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.vLayout.addWidget(self.curvesTable)
    self.refreshCurvesTable()
    
    self.extrasContainer = QWidgetMac()
    self.hLayout = QtWidgets.QHBoxLayout(self.extrasContainer)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.addWidget(self.extrasContainer)
    #
    self.extrasLabel = QtWidgets.QLabel()
    useFont = self.extrasLabel.font()
    useFont.setBold(True)
    self.extrasLabel.setFont(useFont)
    self.extrasLabel.setText('Extras')
    self.hLayout.addWidget(self.extrasLabel)
    self.extrasCreateLineButton = QPushButtonMac()
    self.extrasCreateLineButton.setText('Add Line')
    self.extrasCreateLineButton.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateLineButton.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateLineButton.clicked.connect(partial(self.extrasCreate, 'line'))
    self.hLayout.addWidget(self.extrasCreateLineButton)
    self.extrasCreateShapeButton = QPushButtonMac()
    self.extrasCreateShapeButton.setText('Add Shape')
    self.extrasCreateShapeButton.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateShapeButton.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateShapeButton.clicked.connect(partial(self.extrasCreate, 'shape'))
    self.hLayout.addWidget(self.extrasCreateShapeButton)
    self.extrasCreateTextButton = QPushButtonMac()
    self.extrasCreateTextButton.setText('Add Text')
    self.extrasCreateTextButton.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateTextButton.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.extrasCreateTextButton.clicked.connect(partial(self.extrasCreate, 'text'))
    self.hLayout.addWidget(self.extrasCreateTextButton)
    self.extrasCreateAnnotationButton = QPushButtonMac()
    self.extrasCreateAnnotationButton.setText('Add Annotation')
    self.extrasCreateAnnotationButton.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.extrasCreateAnnotationButton.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.extrasCreateAnnotationButton.clicked.connect(partial(self.extrasCreate, 'annotation'))
    self.hLayout.addWidget(self.extrasCreateAnnotationButton)
    self.hLayout.addStretch()
    
    self.extrasTable = QtWidgets.QTableWidget()
    self.extrasTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.vLayout.addWidget(self.extrasTable)
    self.refreshExtrasTable()
    
    self.residLabel = QtWidgets.QLabel()
    useFont = self.residLabel.font()
    useFont.setBold(True)
    self.residLabel.setFont(useFont)
    self.residLabel.setText('Residuals')
    self.vLayout.addWidget(self.residLabel)
    self.residTable = QtWidgets.QTableWidget()
    self.residTable.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.vLayout.addWidget(self.residTable)
    self.refreshResidTable()

  def reportState(self):
    # reports contents for saveState function
    retv = {}
    retv['activeFit'] = self.parent.activeFit
    retv['activeData'] = self.parent.activeData
    retv['visibilityData'] = [i.visibility for i in self.parent.data]
    retv['visibilityFit'] = [i.visibility for i in self.parent.fit]
    retv['visibilityExtras'] = [i.visibility for i in self.parent.extras]
    retv['visibilityResid'] = [i.visibilityResid for i in self.parent.data]
    
    retstring = ''
    for entry in retv:
      retstring += '>>>' + entry + '\n'
      retstring += repr(retv[entry]) + '\n'
    
    return retstring
  
  def restoreState(self, data, zoffsetData=0, zoffsetCurve=0, zoffsetExtras=0, zoffsetResid=0):
    # restores contents for loadState function
    # set visibility of objects
    if('visibilityData' in data):
      for index, entry in enumerate(data['visibilityData']):
        if(index + zoffsetData < len(self.parent.data)):
          self.parent.data[index + zoffsetData].setVisibility(entry, redraw=False)
    if('visibilityFit' in data):
      for index, entry in enumerate(data['visibilityFit']):
        if(index + zoffsetCurve < len(self.parent.fit)):
          self.parent.fit[index + zoffsetCurve].setVisibility(entry, redraw=False)
    if('visibilityExtras' in data):
      for index, entry in enumerate(data['visibilityExtras']):
        if(index + zoffsetExtras < len(self.parent.extras)):
          self.parent.extras[index + zoffsetExtras].setVisibility(entry, redraw=False)
    if('visibilityResid' in data):
      for index, entry in enumerate(data['visibilityResid']):
        if(index + zoffsetResid < len(self.parent.data)):
          self.parent.data[index + zoffsetResid].setVisibilityResid(entry, redraw=False)
    
    # fix possible gaps/duplications in zorder
    self.sanityCheckZOrder()
    
    # update tables
    self.refreshDataTable()
    self.refreshResidTable()
    self.refreshCurvesTable()
    self.parent.globalarea.updateDataSetTable()
        
    # set active data set and curve
    if('activeData' in data):
      # check whether new object to be selected exists (can arise from edits in state file)
      if(zoffsetData + data['activeData'] < len(self.parent.data)):
        # turn off previous radio button
        prevActive = self.parent.activeData
        widget = self.dataSetTable.cellWidget(prevActive, 1)
        widget.blockSignals(True)
        widget.setChecked(False)
        widget.blockSignals(False)
        self.residTable.cellWidget(prevActive + 1, 1).setChecked(False)
        
        widget = self.dataSetTable.cellWidget(zoffsetData + data['activeData'], 1)
        widget.setChecked(True)
        self.residTable.cellWidget(zoffsetData + data['activeData'] + 1, 1).setChecked(True)
      
    if('activeFit' in data):
      # check whether new object to be selected exists (can arise from edits in state file)
      if(zoffsetCurve + data['activeFit'] < len(self.parent.fit)):
        # turn off previous radio button
        prevActive = self.parent.activeFit
        widget = self.curvesTable.cellWidget(prevActive, 1)
        widget.blockSignals(True)
        widget.setChecked(False)
        widget.blockSignals(False)
        
        widget = self.curvesTable.cellWidget(zoffsetCurve + data['activeFit'], 1)
        if(widget != None):
          # in case sth. went wrong with the state file
          widget.blockSignals(True)
          widget.setChecked(True)
          widget.blockSignals(False)
          self.changeActiveCurve(zoffsetCurve + data['activeFit'], redraw=False)

  def extrasCreate(self, extrasType='text'):
    # generate extras element
    self.parent.extras.append(ExtrasObject(self.parent))
    # x values
    if(self.parent.plotArea.modeX == 'linear'):
      x = (self.parent.plotArea.minX + self.parent.plotArea.maxX) / 2.0
      arrow__x = (self.parent.plotArea.minX + 2 * self.parent.plotArea.maxX) / 3.0
    else:
      x = np.exp((np.log(self.parent.plotArea.minX) + np.log(self.parent.plotArea.maxX)) / 2.0)
      arrow__x = np.exp((np.log(self.parent.plotArea.minX) + 2 * np.log(self.parent.plotArea.maxX)) / 3.0)
    arrow__x_alt = abs((self.parent.plotArea.minX - self.parent.plotArea.maxX) / 2.0)
    # y values
    if(self.parent.plotArea.modeY == 'linear'):
      y = (self.parent.plotArea.minY + self.parent.plotArea.maxY) / 2.0
      arrow__y = y
    else:
      y = np.exp((np.log(self.parent.plotArea.minY) + np.log(self.parent.plotArea.maxY)) / 2.0)
      arrow__y = y
    arrow__y_alt = abs((self.parent.plotArea.minY - self.parent.plotArea.maxY) / 2.0)
    # process and report
    if(extrasType == 'shape'):
      arrow__x, arrow__y = arrow__x_alt, arrow__y_alt
    x, y, arrow__x, arrow__y = self.roundNumber(x), self.roundNumber(y), self.roundNumber(arrow__x), self.roundNumber(arrow__y)
    x2, y2 = arrow__x, arrow__y
    labeltext = extrasType.capitalize()
    valueDict = {'x': x, 'y': y, 'labeltext': labeltext, 'extrasType': extrasType,\
                 'arrow__x': arrow__x, 'arrow__y': arrow__y, 'x2': x2, 'y2': y2}
    self.parent.extras[-1].setValues(valueDict, redraw=True)
    
    # update extras table
    self.refreshExtrasTable()
    self.refreshCurvesTable()
    self.refreshDataTable()
      
  def refreshExtrasTable(self):
    # updates extras table
    number_extrasEntry = len(self.parent.extras)
    self.extrasTable.setRowCount(number_extrasEntry)
    self.extrasTable.setColumnCount(7)
    for index, label in enumerate(['vis', 'z', 'text', '', 'action', '', '2nd']):
      self.extrasTable.setHorizontalHeaderItem(index, QtWidgets.QTableWidgetItem(label))
    # set row height and prevent from resizing
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.extrasTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    hheader = self.extrasTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)

    for index in range(number_extrasEntry):
      vheader.setSectionResizeMode(index, QtWidgets.QHeaderView.Fixed)

      visibilityExtra = QPushButtonCheckable()
      visibilityExtra.setText('vis')
      visibilityExtra.setChecked(self.parent.extras[index].visibility)
      visibilityExtra.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      visibilityExtra.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      visibilityExtra.clicked.connect(partial(self.toggleVisibilityExtras, index))
      self.extrasTable.setCellWidget(index, 0, visibilityExtra)
      
      spinselector = QtWidgets.QSpinBox()
      spinselector.setAlignment(QtCore.Qt.AlignRight)
      spinselector.setMinimum(1)
      spinselector.setMaximum(self.parent.zcount)
      spinselector.setValue(self.parent.extras[index].zorder)
      spinselector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.valueChanged.connect(partial(self.changeZOrder, group = 'extras', index = index))
      self.extrasTable.setCellWidget(index, 1, spinselector)

      entryField = QLineEditClick(str(self.parent.extras[index].labeltext))
      entryField.setAlignment(QtCore.Qt.AlignLeft)
      entryField.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.editingFinished.connect(partial(self.editNameExtra, index))
      self.extrasTable.setCellWidget(index, 2, entryField)
      
      extrasButton = QPushButtonMac()
      extrasButton.setText('Conf \u25be')
      extrasButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.clicked.connect(partial(self.changeStyleExtra, index, extrasButton))
      self.extrasTable.setCellWidget(index, 3, extrasButton)

      extrasButton = QPushButtonMac()
      extrasButton.setText('Copy')
      extrasButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.clicked.connect(partial(self.copyExtra, index))
      self.extrasTable.setCellWidget(index, 4, extrasButton)
        
      extrasButton = QPushButtonMac()
      extrasButton.setText('Del')
      extrasButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      extrasButton.clicked.connect(partial(self.deleteExtra, index, True))
      self.extrasTable.setCellWidget(index, 5, extrasButton)
    
      extrasSecondAxes = QPushButtonCheckable()
      extrasSecondAxes.setText('2nd')
      extrasSecondAxes.setChecked(self.parent.extras[index].onSecondAxes)
      extrasSecondAxes.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      extrasSecondAxes.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      extrasSecondAxes.clicked.connect(partial(self.toggleSecondAxesExtras, index))
      self.extrasTable.setCellWidget(index, 6, extrasSecondAxes)
      
    # resize columns
    self.extrasTable.resizeColumnsToContents()

  def sanityCheckZOrder(self):    
    # checks for inconsistencies in zorder (can happen upon restoration/deletion of entries)
    # refresh tables is probably necessary but should be done outside this function
    # data sets and curves
    zorders = {}
    for entry in self.parent.data:
      key = entry.zorder
      while(key in zorders):
        key += 0.001
      zorders[key] = entry
    for entry in self.parent.fit:
      key = entry.zorder
      while(key in zorders):
        key += 0.001
      zorders[key] = entry
    for entry in self.parent.extras:
      key = entry.zorder
      while(key in zorders):
        key += 0.001
      zorders[key] = entry
    
    # reassign zorder values
    keys = sorted(list(zorders.keys()))
    index = 1
    for entry in keys:
      zorders[entry].setZOrder(index, redraw=False)
      index +=1
      
    # residuals
    zordersResid = {}
    # populate with resid zero line
    zordersResid[self.parent.plotArea.zorderResidLine] = 'zero_line'
    for entry in self.parent.data:
      key = entry.zorderResid
      while(key in zordersResid):
        key += 0.001
      zordersResid[key] = entry
    
    # reassign zorderResid values
    keys = sorted(list(zordersResid.keys()))
    index = 1
    for entry in keys:
      if(zordersResid[entry] == 'zero_line'):
        self.parent.plotArea.setZOrderResidLine(index, redraw=False)
      else:
        zordersResid[entry].setZOrderResid(index, redraw=False)
      index +=1
      
  def refreshResidTable(self):
    # updates resid table
    number_residEntry = len(self.parent.data)
    self.residTable.setRowCount(number_residEntry+1)
    self.residTable.setColumnCount(5)
    #self.residTable.horizontalHeader().hide()
    for index, label in enumerate(['vis', 'act', 'z', 'name', 'action']):
      self.residTable.setHorizontalHeaderItem(index, QtWidgets.QTableWidgetItem(label))
    # set row height and prevent from resizing
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.residTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    hheader = self.residTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    # set up group box for active curve selection
    self.activeResidBox = QtWidgets.QGroupBox()

    for index in range(number_residEntry+1):
      vheader.setSectionResizeMode(index, QtWidgets.QHeaderView.Fixed)

      visibilityResid = QPushButtonCheckable()
      visibilityResid.setText('vis')
      if(index):
        visibilityResid.setChecked(self.parent.data[index-1].visibilityResid)
      else:
        visibilityResid.setChecked(self.parent.plotArea.visibilityResidLine)
      visibilityResid.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      visibilityResid.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      visibilityResid.clicked.connect(partial(self.toggleVisibilityResid, index))
      self.residTable.setCellWidget(index, 0, visibilityResid)

      if(index):
        radiobutton = QtWidgets.QRadioButton(self.activeResidBox)
        radiobutton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        radiobutton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
        radiobutton.setChecked(index-1 == self.parent.activeData)
        radiobutton.setText('')
        radiobutton.setEnabled(False)
        self.residTable.setCellWidget(index, 1, radiobutton)

      spinselector = QtWidgets.QSpinBox()
      spinselector.setAlignment(QtCore.Qt.AlignRight)
      spinselector.setMinimum(1)
      spinselector.setMaximum(len(self.parent.data)+1)
      if(index):
        spinselector.setValue(self.parent.data[index-1].zorderResid)
      else:
        spinselector.setValue(self.parent.plotArea.zorderResidLine)
      spinselector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.valueChanged.connect(partial(self.changeZOrderResid, index = index))
      self.residTable.setCellWidget(index, 2, spinselector)

      if(index):
        entryField = QLineEditClick(str(self.parent.data[index-1].nameResid))
        entryField.editingFinished.connect(partial(self.editNameResid, self.parent.data[index-1], index))
      else:
        entryField = QLineEditClick('zero line')
      entryField.setAlignment(QtCore.Qt.AlignLeft)
      entryField.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.residTable.setCellWidget(index, 3, entryField)
      
      residButton = QPushButtonMac()
      residButton.setText('Conf \u25b4')
      residButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      residButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      if(index):
        residButton.clicked.connect(partial(self.changeStyle, self.parent.data[index-1], False, True, residButton))
      else:
        residButton.clicked.connect(partial(self.changeResidZeroStyle, residButton))
      self.residTable.setCellWidget(index, 4, residButton)
        
    # resize columns
    self.residTable.resizeColumnsToContents()

  def refreshCurvesTable(self):
    # updates curves table
    number_curveEntry = len(self.parent.fit)
    self.curvesTable.setRowCount(number_curveEntry)
    self.curvesTable.setColumnCount(8)
    for index, label in enumerate(['vis', 'act', 'z', 'name', '', 'action', '', '2nd']):
      self.curvesTable.setHorizontalHeaderItem(index, QtWidgets.QTableWidgetItem(label))
    # set row height and prevent from resizing
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.curvesTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    hheader = self.curvesTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    # set up group box for active curve selection
    self.activeCurveBox = QtWidgets.QGroupBox()

    for index in range(number_curveEntry):
      vheader.setSectionResizeMode(index, QtWidgets.QHeaderView.Fixed)

      visibilityCurve = QPushButtonCheckable()
      visibilityCurve.setText('vis')
      visibilityCurve.setChecked(self.parent.fit[index].visibility)
      visibilityCurve.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      visibilityCurve.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      visibilityCurve.clicked.connect(partial(self.toggleVisibilityCurve, index))
      self.curvesTable.setCellWidget(index, 0, visibilityCurve)
      
      radiobutton = QtWidgets.QRadioButton(self.activeCurveBox)
      radiobutton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      radiobutton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      radiobutton.setChecked(index == self.parent.activeFit)
      radiobutton.toggled.connect(partial(self.changeActiveCurve, index))
      radiobutton.setText('')
      self.curvesTable.setCellWidget(index, 1, radiobutton)

      spinselector = QtWidgets.QSpinBox()
      spinselector.setAlignment(QtCore.Qt.AlignRight)
      spinselector.setMinimum(1)
      spinselector.setMaximum(self.parent.zcount)
      spinselector.setValue(self.parent.fit[index].zorder)
      spinselector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.valueChanged.connect(partial(self.changeZOrder, group = 'curve', index = index))
      self.curvesTable.setCellWidget(index, 2, spinselector)

      entryField = QLineEditClick(str(self.parent.fit[index].name))
      entryField.setAlignment(QtCore.Qt.AlignLeft)
      entryField.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.editingFinished.connect(partial(self.editNameCurve, self.parent.fit[index], index))
      self.curvesTable.setCellWidget(index, 3, entryField)
      
      curveButton = QPushButtonMac()
      curveButton.setText('Conf \u25be')
      curveButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.clicked.connect(partial(self.changeStyle, self.parent.fit[index], False, False, curveButton))
      self.curvesTable.setCellWidget(index, 4, curveButton)

      curveButton = QPushButtonMac()
      curveButton.setText('Copy')
      curveButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.clicked.connect(partial(self.copyFit, index))
      self.curvesTable.setCellWidget(index, 5, curveButton)
        
      curveButton = QPushButtonMac()
      curveButton.setText('Del')
      curveButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      curveButton.clicked.connect(partial(self.deleteCurve, index, True))
      self.curvesTable.setCellWidget(index, 6, curveButton)
    
      curveSecondAxes = QPushButtonCheckable()
      curveSecondAxes.setText('2nd')
      curveSecondAxes.setChecked(self.parent.fit[index].onSecondAxes)
      curveSecondAxes.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      curveSecondAxes.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      curveSecondAxes.clicked.connect(partial(self.toggleSecondAxesCurve, index))
      self.curvesTable.setCellWidget(index, 7, curveSecondAxes)
      
    # resize columns
    self.curvesTable.resizeColumnsToContents()

  def refreshDataTable(self):
    # updates data table
    number_dataEntry = len(self.parent.data)
    self.dataSetTable.setRowCount(number_dataEntry)
    self.dataSetTable.setColumnCount(8)
    for index, label in enumerate(['vis', 'act', 'z', 'name', '', 'action', '', '2nd']):
      self.dataSetTable.setHorizontalHeaderItem(index, QtWidgets.QTableWidgetItem(label))
    # set row height and prevent from resizing
    self.rowHeight = scaledDPI(BASE_SIZE + 2)
    vheader = self.dataSetTable.verticalHeader()
    vheader.setDefaultSectionSize(self.rowHeight)
    hheader = self.dataSetTable.horizontalHeader()
    hheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
    # set up group box for active curve selection
    self.activeDataSetBox = QtWidgets.QGroupBox()

    for index in range(number_dataEntry):
      vheader.setSectionResizeMode(index, QtWidgets.QHeaderView.Fixed)

      visibilityData = QPushButtonCheckable()
      visibilityData.setText('vis')
      visibilityData.setChecked(self.parent.data[index].visibility)
      visibilityData.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      visibilityData.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      visibilityData.clicked.connect(partial(self.toggleVisibilityData, index))
      self.dataSetTable.setCellWidget(index, 0, visibilityData)

      radiobutton = QtWidgets.QRadioButton(self.activeDataSetBox)
      radiobutton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      radiobutton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE), scaledDPI(BASE_SIZE)))
      radiobutton.setChecked(index == self.parent.activeData)
      radiobutton.toggled.connect(partial(self.changeActiveDataSet, index))
      radiobutton.setText('')
      self.dataSetTable.setCellWidget(index, 1, radiobutton)

      spinselector = QtWidgets.QSpinBox()
      spinselector.setAlignment(QtCore.Qt.AlignRight)
      spinselector.setMinimum(1)
      spinselector.setMaximum(self.parent.zcount)
      spinselector.setValue(self.parent.data[index].zorder)
      spinselector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      spinselector.valueChanged.connect(partial(self.changeZOrder, group = 'data', index = index))
      self.dataSetTable.setCellWidget(index, 2, spinselector)

      entryField = QLineEditClick(str(self.parent.data[index].name))
      entryField.setAlignment(QtCore.Qt.AlignLeft)
      entryField.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      entryField.editingFinished.connect(partial(self.editNameData, self.parent.data[index], index))
      self.dataSetTable.setCellWidget(index, 3, entryField)

      dataButton = QPushButtonMac()
      dataButton.setText('Conf \u25be')
      dataButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.clicked.connect(partial(self.changeStyle, self.parent.data[index], True, False, dataButton))
      self.dataSetTable.setCellWidget(index, 4, dataButton)

      dataButton = QPushButtonMac()
      dataButton.setText('Copy')
      dataButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.clicked.connect(partial(self.copyData, index))
      self.dataSetTable.setCellWidget(index, 5, dataButton)
        
      dataButton = QPushButtonMac()
      dataButton.setText('Del')
      dataButton.setMinimumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.setMaximumSize(QtCore.QSize(scaledDPI(45), scaledDPI(BASE_SIZE)))
      dataButton.clicked.connect(partial(self.deleteDataSet, index, True))
      self.dataSetTable.setCellWidget(index, 6, dataButton)
    
      dataSecondAxes = QPushButtonCheckable()
      dataSecondAxes.setText('2nd')
      dataSecondAxes.setChecked(self.parent.data[index].onSecondAxes)
      dataSecondAxes.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      dataSecondAxes.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      dataSecondAxes.clicked.connect(partial(self.toggleSecondAxesData, index))
      self.dataSetTable.setCellWidget(index, 7, dataSecondAxes)
      
    # resize columns
    self.dataSetTable.resizeColumnsToContents()

  def deleteExtra(self, index, redraw=True):
    # deletes extra
    killObject = self.parent.extras[index]
    
    # delete from plot
    if(killObject.handle != None):
      killObject.handle.remove()
    if(killObject.handle_div != None):
      killObject.handle_div.remove()

    # delete from self.parent.fit
    nuList = [self.parent.extras[i] for i in range(len(self.parent.extras)) if (i != index)]
    self.parent.extras = nuList

    # destroy object
    del killObject
    
    # adjust zorders etc.
    self.parent.zcount -= 1
    self.sanityCheckZOrder()
    self.refreshDataTable()
    self.refreshCurvesTable()
    self.refreshExtrasTable()
    self.checkSecondAxes()

    # update plot?
    if(redraw):
      self.parent.plotArea.dataplotwidget.myRefresh()

  def deleteCurve(self, index, redraw=True):
    # deletes curve
    if(len(self.parent.fit) == 1):
      self.parent.statusbar.showMessage('Cannot delete last and only curve!', self.parent.STATUS_TIME)
    else:
      killObject = self.parent.fit[index]
      
      # delete from plot
      if((hasattr(killObject, 'handlePlot')) and (killObject.handlePlot != None)):
        killObject.handlePlot.remove()
      if((hasattr(killObject, 'handlePlot_div')) and (killObject.handlePlot_div != None)):
        killObject.handlePlot_div.remove()

      # delete from self.parent.fit
      nuList = [self.parent.fit[i] for i in range(len(self.parent.fit)) if (i != index)]
      self.parent.fit = nuList

      if(index == self.parent.activeFit):
        # our active fit was deleted, too bad
        if(self.parent.activeFit):
          self.parent.activeFit -= 1
        # activate new function
        self.parent.fit[self.parent.activeFit].retired = False
        # change fit formula
        parameters, formula, values, active, fitresults, confidence, confidence_apriori = self.parent.fit[self.parent.activeFit].retrieveInfo()
        self.parent.fitarea.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=False)
      elif((index < self.parent.activeFit) and (self.parent.activeFit > 0)):
        # need to shift number of activeFit
        self.parent.activeFit -= 1
      
      # destroy object
      del killObject
      
      # adjust zorders etc.
      self.parent.zcount -= 1
      self.sanityCheckZOrder()
      self.refreshDataTable()
      self.refreshCurvesTable()
      self.refreshExtrasTable()
      self.parent.globalarea.updateDataSetTable()
      self.checkSecondAxes()

      # update legend
      self.updateLegend(redraw=redraw)

  def deleteDataSet(self, index, redraw=True):
    # deletes data set
    if(len(self.parent.data) == 1):
      self.parent.statusbar.showMessage('Cannot delete last and only data set!', self.parent.STATUS_TIME)
    else:
      killObject = self.parent.data[index]
      
      # delete from plot
      items = 'handleData,handleErr,handleErrShady,handleBar,handleStack,handleStackNeg,handleText,handleViolin,handleResid,handleResidBar,handleResidStack,handleResidStackNeg'.split(',')
      items.extend('handleData_div,handleErr_div,handleErrShady_div,handleBar_div,handleStack_div,handleStackNeg_div,handleText_div,handleViolin_div,handleResid_div,handleResidBar_div,handleResidStack_div,handleResidStackNeg_div'.split(','))
      for entry in items:
        # need to catch this in case previous data import caused problems
        try:
          if((hasattr(killObject, entry)) and (killObject.__dict__[entry] != None)):
            if(entry in ['handleText', 'handleText_div']):
              for item in killObject.__dict__[entry]:
                item.remove()
            elif(entry in ['handleViolin', 'handleViolin_div']):
              for entry2 in killObject.__dict__[entry]:
                if(type(killObject.__dict__[entry][entry2]) == type([])):
                  for item in killObject.__dict__[entry][entry2]:
                    item.remove()
                else:
                  killObject.__dict__[entry][entry2].remove()
                
            elif(not (entry in ['handleErr', 'handleErr_div'])):
              killObject.__dict__[entry].remove()
            else:
              killObject.__dict__[entry][0].remove()
              for entry2 in killObject.__dict__[entry][1]:
                entry2.remove()
              for entry2 in killObject.__dict__[entry][2]:
                entry2.remove()
        except:
          pass

      # delete from self.parent.data
      nuList = [self.parent.data[i] for i in range(len(self.parent.data)) if (i != index)]
      self.parent.data = nuList

      if(index == self.parent.activeData):
        # our active data set was deleted, too bad
        if(self.parent.activeData):
          self.parent.activeData -= 1
      elif((index < self.parent.activeData) and (self.parent.activeData > 0)):
        # need to shift number of activeFit
        self.parent.activeData -= 1

      # update results table
      self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData, maxIndex=len(self.parent.data) - 1)
      
      # destroy object
      del killObject
      
      # adjust zorders etc.
      self.parent.zcount -= 1
      self.sanityCheckZOrder()
      self.refreshDataTable()
      self.refreshCurvesTable()
      self.refreshResidTable()
      self.refreshExtrasTable()
      self.parent.globalarea.updateDataSetTable()
      self.checkSecondAxes()

      # update legend
      self.updateLegend(redraw=redraw)
      if(redraw):
        self.parent.plotArea.residplotwidget.myRefresh()

  def changeActiveCurve(self, index=0, redraw=True):
    # changes active curve 
    if(len(self.parent.fit) - 1):
      prevActive = self.parent.activeFit
      if(prevActive != index):
        # update active fit function
        self.parent.activeFit = index
        # stuff to do
        # 1. retire previous function
        self.parent.fit[prevActive].retired = True
        #self.parent.fit[prevActive].retireMe()
        # 2. activate new function
        self.parent.fit[self.parent.activeFit].retired = False
        # change fit formula
        parameters, formula, values, active, fitresults, confidence, confidence_apriori = self.parent.fit[self.parent.activeFit].retrieveInfo()
        self.parent.fitarea.restoreFfunc(parameters, formula, values, active, fitresults, confidence, confidence_apriori, redraw=redraw)
        # change fit parameter table
        # change last fit results
    else:
      # have to set button to checked to prevent turning off
      widget = self.curvesTable.cellWidget(0, 1)
      widget.blockSignals(True)
      widget.setChecked(True)
      widget.blockSignals(False)
  
  def changeActiveDataSet(self, index=0, setCheck=True):
    # changes active data set
    if(len(self.parent.data) - 1):
      prevActive = self.parent.activeData
      if(prevActive != index):
        # update active data set and residuals
        self.parent.activeData = index
        if(setCheck):
          self.residTable.cellWidget(index + 1, 1).setChecked(True)
        # update results table
        self.parent.resultsarea.setDataSet(currIndex=self.parent.activeData, maxIndex=len(self.parent.data) - 1)
    else:
      # have to set button to checked to prevent turning off
      widget = self.dataSetTable.cellWidget(0, 1)
      widget.blockSignals(True)
      widget.setChecked(True)
      widget.blockSignals(False)
  
  def changeZOrderResid(self, index=0):
    # updates z-order of plot items
    source_index = index
    new_zorder = self.residTable.cellWidget(index, 2).value()
    if(source_index):
      sourceItem = self.parent.data[source_index-1]
      orig_zorder = sourceItem.zorderResid
    else:
      sourceItem = self.parent.plotArea
      orig_zorder = sourceItem.zorderResidLine

    # hunt for the item that needs to be swapped in z-order
    flag = False
    # parse data sets
    for index in range(len(self.parent.data) + 1):
      if(index == 0):
        if(self.parent.plotArea.zorderResidLine == new_zorder):
          target_index = index
          flag = True
      elif(self.parent.data[index-1].zorderResid == new_zorder):
        # we found the guy
        target_index = index
        flag = True

    # now swap the z-order values
    if (flag):
      dest_qspin = self.residTable.cellWidget(target_index, 2)
      # have to temporarily disable event logging
      dest_qspin.blockSignals(True)
      dest_qspin.setValue(orig_zorder)
      dest_qspin.blockSignals(False)
      # update z-order in source object
      if(source_index):
        sourceItem.setZOrderResid(new_zorder, redraw=False)
      else:
        sourceItem.setZOrderResidLine(new_zorder, redraw=False)
      # update z-order in destination object
      if(target_index):
        self.parent.data[target_index-1].setZOrderResid(orig_zorder, redraw=False)
      else:
        self.parent.plotArea.setZOrderResidLine(orig_zorder, redraw=False)

      # trigger redrawing of objects
      self.parent.plotArea.residplotwidget.myRefresh()

  def changeZOrder(self, group='data', index=0):
    # updates z-order of plot items
    if(group in ['data', 'curve', 'extras']):
      # determine field that triggered event
      if (group == 'data'):
        sourceItem = self.parent.data[index]
        new_zorder = self.dataSetTable.cellWidget(index, 2).value()
      elif(group == 'curve'):
        sourceItem = self.parent.fit[index]
        new_zorder = self.curvesTable.cellWidget(index, 2).value()
      else:
        sourceItem = self.parent.extras[index]
        new_zorder = self.extrasTable.cellWidget(index, 1).value()
      orig_zorder = sourceItem.zorder
      
      # hunt for the item that needs to be swapped in z-order
      flag = False
      # parse data sets
      for index in range(len(self.parent.data)):
        if(self.parent.data[index].zorder == new_zorder):
          # we found the guy
          flag = True
          dest_qspin = self.dataSetTable.cellWidget(index, 2)
          # have to temporarily disable event logging
          dest_qspin.blockSignals(True)
          dest_qspin.setValue(orig_zorder)
          dest_qspin.blockSignals(False)
          destItem = self.parent.data[index]
          index = len(self.parent.data)+1
      # parse curves
      if (not flag):
        for index in range(len(self.parent.fit)):
          if(self.parent.fit[index].zorder == new_zorder):
            # we found the guy
            flag = True
            dest_qspin = self.curvesTable.cellWidget(index, 2)
            # have to temporarily disable event logging
            dest_qspin.blockSignals(True)
            dest_qspin.setValue(orig_zorder)
            dest_qspin.blockSignals(False)
            destItem = self.parent.fit[index]
            index = len(self.parent.fit)+1
      # parse extras
      if (not flag):
        for index in range(len(self.parent.extras)):
          if(self.parent.extras[index].zorder == new_zorder):
            # we found the guy
            flag = True
            dest_qspin = self.extrasTable.cellWidget(index, 1)
            # have to temporarily disable event logging
            dest_qspin.blockSignals(True)
            dest_qspin.setValue(orig_zorder)
            dest_qspin.blockSignals(False)
            destItem = self.parent.extras[index]
            index = len(self.parent.extras)+1
            
      # now swap the z-order values
      if (flag):
        # set z-order in objects to new values
        sourceItem.setZOrder(new_zorder, redraw=False)
        destItem.setZOrder(orig_zorder, redraw=False)
        
        # update legend if needed
        self.updateLegend(redraw=True)
        
  def checkSecondAxes(self):
    # checks whether at least one item slaved to the second axes
    state = False
    for entry in self.parent.data:
      state = state or entry.onSecondAxes
    for entry in self.parent.fit:
      state = state or entry.onSecondAxes
    for entry in self.parent.extras:
      state = state or entry.onSecondAxes
    # control display of axes controls
    self.parent.plotArea.toggleSecondAxes(state)
        
  def toggleVisibilityExtras(self, index=0):
    visibilityExtra = self.extrasTable.cellWidget(index, 0)
    if (visibilityExtra.isChecked()):
      self.parent.extras[index].setVisibility(True, redraw=False)
      # need to check for bad fonts here
      if(self.parent.extras[index].extrasType in ['text', 'annotation']):
        safeFont = 'DejaVu Sans'
        _, _, descent = self.parent.extras[index].handle._get_layout(self.parent.plotArea.matplot.canvas.renderer)
        if(not (descent > 0)):
          self.parent.statusbar.showMessage('Experiencing problems setting font ' + self.parent.extras[index].fontname + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.parent.extras[index].fontname = safeFont
          self.parent.extras[index].handle.set_fontname(safeFont)
    else:
      self.parent.extras[index].setVisibility(False, redraw=False)
    # update plot
    self.parent.plotArea.dataplotwidget.myRefresh()

  def toggleSecondAxesExtras(self, index=0):
    extrasSecondAxes = self.extrasTable.cellWidget(index, 6)
    if (extrasSecondAxes.isChecked()):
      self.parent.extras[index].setSecondAxes(True, redraw=False)
      # need to check for bad fonts here
      if(self.parent.extras[index].extrasType in ['text', 'annotation']):
        safeFont = 'DejaVu Sans'
        _, _, descent = self.parent.extras[index].handle_div._get_layout(self.parent.plotArea.matplot.canvas.renderer)
        if(not (descent > 0)):
          self.parent.statusbar.showMessage('Experiencing problems setting font ' + self.parent.extras[index].fontname + ' -- reverting to ' + safeFont, self.parent.STATUS_TIME)
          self.parent.extras[index].fontname = safeFont
          self.parent.extras[index].handle_div.set_fontname(safeFont)
    else:
      self.parent.extras[index].setSecondAxes(False, redraw=False)
    # update plot
    self.parent.plotArea.dataplotwidget.myRefresh()
    self.checkSecondAxes()

  def toggleSecondAxesCurve(self, index=0):
    curveSecondAxes = self.curvesTable.cellWidget(index, 7)
    if (curveSecondAxes.isChecked()):
      self.parent.fit[index].setSecondAxes(True, redraw=False)
    else:
      self.parent.fit[index].setSecondAxes(False, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)
    self.checkSecondAxes()

  def toggleSecondAxesData(self, index=0):
    dataSecondAxes = self.dataSetTable.cellWidget(index, 7)
    if (dataSecondAxes.isChecked()):
      self.parent.data[index].setSecondAxes(True, redraw=False)
    else:
      self.parent.data[index].setSecondAxes(False, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)
    self.checkSecondAxes()

  def toggleVisibilityCurve(self, index=0):
    visibilityCurve = self.curvesTable.cellWidget(index, 0)
    if (visibilityCurve.isChecked()):
      self.parent.fit[index].setVisibility(True, redraw=False)
    else:
      self.parent.fit[index].setVisibility(False, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)

  def toggleVisibilityData(self, index=0):
    visibilityData = self.dataSetTable.cellWidget(index, 0)
    if (visibilityData.isChecked()):
      self.parent.data[index].setVisibility(True, redraw=False)
    else:
      self.parent.data[index].setVisibility(False, redraw=False)
    # update legend if needed
    self.updateLegend(redraw=True)

  def toggleVisibilityResid(self, index=0):
    visibilityResid = self.residTable.cellWidget(index, 0)
    if(index):
      index -= 1
      method = self.parent.data[index].setVisibilityResid
    else:
      method = self.parent.plotArea.setVisibilityResidLine
    if (visibilityResid.isChecked()):
      method(True)
    else:
      method(False)

  def editNameExtra(self, targetIndex=None):
    if (targetIndex != None):
      entryField = self.extrasTable.cellWidget(targetIndex, 2)
      nuName = str(entryField.text())
      prevName = self.parent.extras[targetIndex].labeltext
      valueDict = {'labeltext': nuName}
      # update label if needed
      if(prevName != nuName):
        self.parent.extras[targetIndex].setValues(valueDict, redraw=True)
 
  def editNameCurve(self, target=None, index=0):
    if (target != None):
      entryField = self.curvesTable.cellWidget(index, 3)
      nuName = str(entryField.text())
      prevName = target.name
      target.setName(nuName)
      # update legend and global tab if needed
      if(prevName != nuName):
        self.updateLegend(redraw=True)
        self.parent.globalarea.updateDataSetTable()
 
  def editNameData(self, target=None, index=0):
    if (target != None):
      entryField = self.dataSetTable.cellWidget(index, 3)
      nuName = str(entryField.text())
      prevName = target.name
      target.setName(nuName)
      # update legend and global tab if needed
      if(prevName != nuName):
        self.updateLegend(redraw=True)
        self.parent.globalarea.updateDataSetTable()
 
  def editNameResid(self, target=None, index=0):
    if (target != None):
      entryField = self.residTable.cellWidget(index, 3)
      nuName = str(entryField.text())
      target.setNameResid(nuName)
 
  def changeResidZeroStyle(self, callButton=None):
    # display menu at current mouse pointer
    if(callButton == None):
      # dissociated menu => display name of item
      displayName = True
    else:
      displayName = False
    self.menu = ConfigMenu(self, target=self.parent.plotArea, residMode=False, residZero=True, displayName=displayName)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)
    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())
    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuX += callButton.geometry().width() / 2
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()
      menuX -= self.menu.width() / 2

    menuY -= self.menu.height()
    menuX, menuY = max(menuX, 0), max(menuY, 0)
    menuPos = QtCore.QPoint(menuX, menuY)
    self.menu.move(menuPos)

  def changeStyle(self, target=None, errorbar=False, residMode=False, callButton=None):
    # display menu at current mouse pointer
    if(callButton == None):
      # dissociated menu => display name of item
      displayName = True
    else:
      displayName = False
    self.menu = ConfigMenu(self, target, residMode, displayName=displayName)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())

    # adjust window position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuX += callButton.geometry().width() / 2
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()
      menuX -= self.menu.width() / 2

    if(residMode):
      # bottom align position of QMenu
      # now move window to new position
      menuY -= self.menu.height()
      menuX, menuY = max(menuX, 0), max(menuY, 0)
      self.menu.move(QtCore.QPoint(menuX, menuY))
    else:
      if(callButton != None):
        menuY += callButton.geometry().height()
      menuX, menuY = max(menuX, 0), max(menuY, 0)
      self.menu.move(QtCore.QPoint(menuX, menuY))
    
  def changeStyleExtra(self, targetIndex=None, callButton=None):
    # display menu at current mouse pointer
    if(callButton == None):
      # dissociated menu => display name of item
      displayName = True
    else:
      displayName = False
    self.menu = ConfigMenuExtra(self, targetIndex, displayName=displayName)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # adjust window position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuY += callButton.geometry().height()
      menuX += callButton.geometry().width() / 2
      self.menu.popup(QtCore.QPoint(menuX, menuY))
    else:
      # first need to display QMenu to get reliable size (even sizeHint fails)
      self.menu.popup(QtGui.QCursor.pos())
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()
      menuX -= self.menu.width() / 2
      menuX, menuY = max(menuX, 0), max(menuY, 0)
      self.menu.move(QtCore.QPoint(menuX, menuY))
    
  def copyData(self, source=0):
    # this routine copies the current data set
    sourceData = self.parent.data[source].value()
    if('x' in sourceData):
      # would need some kind of deep copy to make this work ...
      # ... but deepcopy produces an error due to matplotlib links, so do it manually
      self.parent.data.append(DataObject(self.parent))
      self.parent.data[-1].setName('Data_'+str(len(self.parent.data)-1))
      # need to copy contents of original object
      self.parent.data[-1].spawned(self.parent.data[source])
      # set new data object as active
      #self.parent.activeData = (len(self.parent.data) - 1)
      self.changeActiveDataSet(len(self.parent.data) - 1, setCheck=False)
      # cause data to be drawn
      self.parent.data[-1].drawMe(redraw=False)
      self.refreshDataTable()
      self.dataSetTable.scrollToBottom()
      # also create a new resid object
      self.parent.data[-1].drawMeResid()
      self.refreshResidTable()
      self.residTable.scrollToBottom()
      # also refresh curves table to account for increased total number of items
      self.refreshCurvesTable()
      self.refreshExtrasTable()
      self.parent.globalarea.updateDataSetTable()
      # update results table
      self.parent.resultsarea.setDataSet(currIndex=len(self.parent.data) - 1, maxIndex=len(self.parent.data) - 1)
      # update legend if needed
      self.updateLegend(redraw=True)
    else:
      self.parent.statusbar.showMessage('Data object is empty, will not copy!', self.parent.STATUS_TIME)

  def copyFit(self, source=0):
    # this routine copies the current curve
    self.parent.fit.append(FitObject(self.parent))
    self.parent.fit[-1].setName('Curve_'+str(len(self.parent.fit)-1))
    self.parent.fit[-1].retired = True
    # need to copy contents of original object
    self.parent.fit[-1].spawned(self.parent.fit[source])
    # set new curve object as active
    #self.parent.activeFit = (len(self.parent.fit) - 1)
    self.changeActiveCurve(len(self.parent.fit) - 1, redraw=False)
    # cause fxn to be drawn
    self.parent.fit[-1].drawMe(redraw=False)
    self.refreshCurvesTable()
    self.curvesTable.scrollToBottom()
    # also refresh data set table to account for increased total number of items
    self.refreshDataTable()
    self.refreshExtrasTable()
    self.parent.globalarea.updateDataSetTable()
    # update legend if needed
    self.updateLegend(redraw=True)
    
  def curveCreate(self):
    # generates a new curve with default settings (vs. copying the fit)
    self.parent.fit.append(FitObject(self.parent))
    self.parent.fit[-1].setName('Curve_'+str(len(self.parent.fit)-1))
    self.parent.fit[-1].retired = True
    # need to initialize object with default settings
    self.parent.fit[-1].initialize()
    # set new curve object as active
    self.changeActiveCurve(len(self.parent.fit) - 1, redraw=False)
    # cause fxn to be drawn
    self.parent.fit[-1].drawMe(redraw=False)
    self.refreshCurvesTable()
    self.curvesTable.scrollToBottom()
    # also refresh data set table to account for increased total number of items
    self.refreshDataTable()
    self.refreshExtrasTable()
    self.parent.globalarea.updateDataSetTable()
    # update legend if needed
    self.updateLegend(redraw=True)

  def dataSetCreate(self):
    # generates a new, emtpy data set with default settings
    self.parent.data.append(DataObject(self.parent))
    self.parent.data[-1].setName('Data_'+str(len(self.parent.data)-1))
    # set new data object as active
    self.changeActiveDataSet(len(self.parent.data) - 1, setCheck=False)
    # do not need to draw data as it is empty
    ###self.parent.data[-1].drawMe(redraw=False)
    self.refreshDataTable()
    self.dataSetTable.scrollToBottom()
    # also create a new resid object
    ###self.parent.data[-1].drawMeResid()
    self.refreshResidTable()
    self.residTable.scrollToBottom()
    # also refresh curves table to account for increased total number of items
    self.refreshCurvesTable()
    self.refreshExtrasTable()
    self.parent.globalarea.updateDataSetTable()
    # update results table
    self.parent.resultsarea.setDataSet(currIndex=len(self.parent.data) - 1, maxIndex=len(self.parent.data) - 1)
    # update legend if needed (no redraw as newly generated data set is empty)
    self.updateLegend(redraw=False)
    
  def copyExtra(self, source=0):
    # this routine copies the current extra
    self.parent.extras.append(ExtrasObject(self.parent))
    # need to copy contents of original object
    self.parent.extras[-1].spawned(self.parent.extras[source])
    # cause fxn to be drawn
    self.parent.extras[-1].drawMe(redraw=False)
    self.refreshExtrasTable()
    self.extrasTable.scrollToBottom()
    # also refresh data set table to account for increased total number of items
    self.refreshDataTable()
    self.refreshCurvesTable()
    # update legend if needed
    self.parent.plotArea.dataplotwidget.myRefresh()

  def updateLegend(self, redraw=True):
    # does legend need to be updated?
    value = self.parent.plotArea.legendVisible
    if(value or redraw):
      self.parent.plotArea.setLegend(value=value, redraw=redraw)

  def roundNumber(self, number, places=3):
    # formats number for output
    NUMBER_SWITCH = 1e3
    FORMAT_DECIMAL = '{:.' + str(places) + 'f}'
    FORMAT_SCIENTIFIC = '{:.' + str(places) + 'e}'
    # determine return string
    if((np.abs(number) > NUMBER_SWITCH) or (np.abs(number) < 1.0/NUMBER_SWITCH)):
      numberstr = FORMAT_SCIENTIFIC.format(number)
    else:
      numberstr = FORMAT_DECIMAL.format(number)

    return float(numberstr)

class ConfigMenuExtra(KuhMenu):
  def __init__(self, parent = None, targetIndex = None, displayName=False):
    super(ConfigMenuExtra, self).__init__()
    self.parent = parent
    self.targetIndex = targetIndex
    self.displayName = displayName
    self.extrasType = self.parent.parent.extras[targetIndex].extrasType
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.linestyles = ['solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.hatchStyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
    self.shapetypes = ['rect', 'circle', 'poly', 'star']
      
    # float validator
    self.validFloat = MyValidFloat()
    # int validator
    self.validInt = MyValidInt()

    # set up initial values (needs to be much expanded)
    if (self.targetIndex != None):
      self.style = self.parent.parent.extras[targetIndex].getStyle()
    else:
      self.style = {'x': 1, 'y': 1, 'color': [0.0, 0.0, 0.0, 1.0], 'fontsize': 12, 'fontname': 'DejaVu Sans',\
                    'rotation': 0.0, 'horizontalalignment': 'center', 'verticalalignment': 'center',\
                    'fontweight': 'normal', 'fontstyle': 'normal'}

    # initialize drag values
    self.startPos = None
      
    # set up GUI
    self.buildRessource()

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(self.underMouse()):
      if(self.displayName and (event.button() == QtCore.Qt.LeftButton)):
        self.startPos = event.globalPos()
    else:
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def mouseMoveEvent(self, event):
    if((event.buttons() == QtCore.Qt.LeftButton) and (self.startPos != None)):
      currentPos = event.globalPos()
      menuPos = self.mapToGlobal(self.pos()) + (currentPos - self.startPos)
      menuPos = self.mapFromGlobal(menuPos)
      self.move(menuPos)
      self.startPos = currentPos
    
  def mouseReleaseEvent(self, event):
    # turn off tracking
    if(event.button() == QtCore.Qt.LeftButton):
      self.startPos = None

  def buildRessource(self):
    # build outer gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[scaledDPI(4)]*4)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # display name of item?
    if(self.displayName):
      self.topContainer = QWidgetMac(self)
      self.vLayout.addWidget(self.topContainer)
      self.LayoutTopContainer = QtWidgets.QHBoxLayout(self.topContainer)
      self.LayoutTopContainer.setContentsMargins(0, 0, 0, 0)

      leader = 'Extra ' + str(self.targetIndex)
      self.targetLabel = QtWidgets.QLabel()
      self.targetLabel.setText(leader)
      font = self.targetLabel.font()
      font.setBold(True)
      self.targetLabel.setFont(font)
      self.LayoutTopContainer.addWidget(self.targetLabel)
      
      # create entry field to edit name
      name = self.parent.parent.extras[self.targetIndex].labeltext
      if(name != None):
        name = name.replace('\n', '\\n')
        name = name.replace('\t', '\\t')
        self.entryField = QLineEditClick(name)
        self.entryField.setAlignment(QtCore.Qt.AlignLeft)
        self.entryField.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.entryField.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.entryField.editingFinished.connect(partial(self.setField, self.targetIndex))
        self.LayoutTopContainer.addWidget(self.entryField)

      # put controls for altering z position
      self.LayoutTopContainer.addStretch()
      self.zLabel = QtWidgets.QLabel('z')
      self.LayoutTopContainer.addWidget(self.zLabel)

      self.innerContainer = QWidgetMac(self)
      self.LayoutTopContainer.addWidget(self.innerContainer)
      self.LayoutInnerContainer = QtWidgets.QHBoxLayout(self.innerContainer)
      self.LayoutInnerContainer.setContentsMargins(0, 0, 0, 0)
      self.LayoutInnerContainer.setSpacing(0)

      self.zDownButton = QPushButtonMac()
      self.zDownButton.setText('\u25be')
      self.zDownButton.setAutoRepeat(True)
      self.zDownButton.setMaximumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zDownButton.setMinimumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zDownButton.clicked.connect(partial(self.alterZ, self.targetIndex, -1))
      self.LayoutInnerContainer.addWidget(self.zDownButton)

      self.zUpButton = QPushButtonMac()
      self.zUpButton.setText('\u25b4')
      self.zUpButton.setAutoRepeat(True)
      self.zUpButton.setMaximumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zUpButton.setMinimumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zUpButton.clicked.connect(partial(self.alterZ, self.targetIndex, 1))
      self.LayoutInnerContainer.addWidget(self.zUpButton)
      
      # call alterZ to initiate button disabling
      self.alterZ(self.targetIndex, 0)
     
      blah = self.HLine()
      self.vLayout.addWidget(blah)

    self.upperRow = QWidgetMac()
    self.vLayout.addWidget(self.upperRow)

    self.hLayout0 = QtWidgets.QHBoxLayout(self.upperRow)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)

    # handle line separately -- too different from the other objects
    if(self.extrasType in ['line', 'shape']):
      # build gui for line formatting
      self.formatLine = QWidgetMac()    
      self.vLayout = QtWidgets.QVBoxLayout(self.formatLine)
      self.vLayout.setContentsMargins(0, 0, 0, 0)
      self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
      self.vLayout.setSpacing(scaledDPI(2))
      self.hLayout0.addWidget(self.formatLine)
      
      # heading
      self.extrasStyleLabel = QtWidgets.QLabel()
      if(self.extrasType == 'line'):
        self.extrasStyleLabel.setText('Line')
      else:
        self.extrasStyleLabel.setText('Shape')
      font = self.extrasStyleLabel.font()
      font.setBold(True)
      self.extrasStyleLabel.setFont(font)
      self.vLayout.addWidget(self.extrasStyleLabel)    
      
      # configure shape type
      if(self.extrasType == 'shape'):
        self.shapeTypeGroup = QWidgetMac()
        self.vLayout.addWidget(self.shapeTypeGroup)
        self.hLayout0 = QtWidgets.QHBoxLayout(self.shapeTypeGroup)
        self.hLayout0.setContentsMargins(0, 0, 0, 0)
        self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
        self.shapeTypeLabel = QtWidgets.QLabel('Type')
        self.shapeTypeLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.shapeTypeLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayout0.addWidget(self.shapeTypeLabel)
  
        self.shapeType = QComboBoxMac()
        for entry in self.shapetypes:
          self.shapeType.addItem(entry)
        if(self.style['shape__type'] in self.shapetypes):
          currindex = self.shapetypes.index(self.style['shape__type'])
        else:
          currindex = 0
        self.shapeType.setCurrentIndex(currindex)
        self.shapeType.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'shape__type', self.shapeType))
        self.shapeType.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.shapeType.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.hLayout0.addWidget(self.shapeType)
        
        self.spokeNumberSpinBox = QtWidgets.QSpinBox()
        self.spokeNumberSpinBox.setAlignment(QtCore.Qt.AlignRight)
        self.spokeNumberSpinBox.setMinimum(3)
        self.spokeNumberSpinBox.setMaximum(30)
        self.spokeNumberSpinBox.setValue(self.style['shape__numSpokes'])
        self.spokeNumberSpinBox.setMinimumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
        self.spokeNumberSpinBox.setMaximumSize(scaledDPI(50), scaledDPI(BASE_SIZE))
        self.spokeNumberSpinBox.valueChanged.connect(partial(self.changeSpokeNumber, self.targetIndex, 'shape__numSpokes', self.spokeNumberSpinBox))
        self.hLayout0.addWidget(self.spokeNumberSpinBox)
        
        if(self.style['shape__type'] in ['poly', 'star']):
          self.spokeNumberSpinBox.show()
        else:
          self.spokeNumberSpinBox.hide()
        
        # spikiness of spokes
        self.spikySpokeGroup = QWidgetMac()
        self.vLayout.addWidget(self.spikySpokeGroup)
        self.hLayout0A = QtWidgets.QHBoxLayout(self.spikySpokeGroup)
        self.hLayout0A.setContentsMargins(0, 0, 0, 0)
        self.hLayout0A.setAlignment(QtCore.Qt.AlignLeft)
        self.spikySpokeLabel = QtWidgets.QLabel('Spiky')
        self.spikySpokeLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.spikySpokeLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayout0A.addWidget(self.spikySpokeLabel)
        
        self.spikySpokeEntry = QLineEditClick()
        self.spikySpokeEntry.setText(str(self.style['shape__spikiness']))
        self.spikySpokeEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.spikySpokeEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.spikySpokeEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'shape__spikiness', self.spikySpokeEntry, 0, 3))
        self.spikySpokeEntry.setValidator(self.validFloat)
        self.hLayout0A.addWidget(self.spikySpokeEntry)

        if(self.style['shape__type'] == 'star'):
          self.spikySpokeGroup.show()
        else:
          self.spikySpokeGroup.hide()

      # line position x
      self.labelXGroup = QWidgetMac()
      self.vLayout.addWidget(self.labelXGroup)
      self.hLayout = QtWidgets.QHBoxLayout(self.labelXGroup)
      self.hLayout.setContentsMargins(0, 0, 0, 0)
      self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
      self.labelXLabel = QtWidgets.QLabel('x')
      self.labelXLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.labelXLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout.addWidget(self.labelXLabel)
  
      self.labelXEntry = QLineEditClick()
      self.labelXEntry.setText(str(self.style['x']))
      self.labelXEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelXEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelXEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'x', self.labelXEntry, None, None))
      self.labelXEntry.setValidator(self.validFloat)
      self.hLayout.addWidget(self.labelXEntry)
  
      # line position y
      self.labelYGroup = QWidgetMac()
      self.vLayout.addWidget(self.labelYGroup)
      self.labelYLabel = QtWidgets.QLabel('y')
      self.labelYLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.labelYLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout.addWidget(self.labelYLabel)
  
      self.labelYEntry = QLineEditClick()
      self.labelYEntry.setText(str(self.style['y']))
      self.labelYEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelYEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelYEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'y', self.labelYEntry, None, None))
      self.labelYEntry.setValidator(self.validFloat)
      self.hLayout.addWidget(self.labelYEntry)

      # line position x2
      self.labelXGroup2 = QWidgetMac()
      self.vLayout.addWidget(self.labelXGroup2)
      self.hLayout1 = QtWidgets.QHBoxLayout(self.labelXGroup2)
      self.hLayout1.setContentsMargins(0, 0, 0, 0)
      self.hLayout1.setAlignment(QtCore.Qt.AlignLeft)
      if(self.extrasType == 'shape'):
        self.labelXLabel2 = QtWidgets.QLabel('width')
      else:
        self.labelXLabel2 = QtWidgets.QLabel('x2')
      self.labelXLabel2.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.labelXLabel2.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout1.addWidget(self.labelXLabel2)
  
      self.labelXEntry2 = QLineEditClick()
      self.labelXEntry2.setText(str(self.style['x2']))
      self.labelXEntry2.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelXEntry2.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      if(self.extrasType == 'shape'):
        self.labelXEntry2.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'x2', self.labelXEntry2, 0, None))
      else:
        self.labelXEntry2.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'x2', self.labelXEntry2, None, None))
      self.labelXEntry2.setValidator(self.validFloat)
      self.hLayout1.addWidget(self.labelXEntry2)
  
      # line position y
      self.labelYGroup2 = QWidgetMac()
      self.vLayout.addWidget(self.labelYGroup2)
      if(self.extrasType == 'shape'):
        self.labelYLabel2 = QtWidgets.QLabel('height')
      else:
        self.labelYLabel2 = QtWidgets.QLabel('y2')
      self.labelYLabel2.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.labelYLabel2.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout1.addWidget(self.labelYLabel2)
  
      self.labelYEntry2 = QLineEditClick()
      self.labelYEntry2.setText(str(self.style['y2']))
      self.labelYEntry2.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelYEntry2.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      if(self.extrasType == 'shape'):
        self.labelYEntry2.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'y2', self.labelYEntry2, 0, None))
      else:
        self.labelYEntry2.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'y2', self.labelYEntry2, None, None))
      self.labelYEntry2.setValidator(self.validFloat)
      self.hLayout1.addWidget(self.labelYEntry2)
      
      # line style
      self.linePropsGroup = QWidgetMac()
      self.vLayout.addWidget(self.linePropsGroup)
      self.hLayout2 = QtWidgets.QHBoxLayout(self.linePropsGroup)
      self.hLayout2.setContentsMargins(0, 0, 0, 0)
      self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
      self.linePropsLabel = QtWidgets.QLabel('Line')
      self.linePropsLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.linePropsLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout2.addWidget(self.linePropsLabel)
  
      self.lineWidthEntry = QLineEditClick()
      self.lineWidthEntry.setText(str(self.style['line__linewidth']))
      self.lineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.lineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.lineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'line__linewidth', self.lineWidthEntry, 0.0, 100.0))
      self.lineWidthEntry.setValidator(self.validFloat)
      self.hLayout2.addWidget(self.lineWidthEntry)
    
      # line color
      self.lineColorButton = QPushButtonMac()
      self.lineColorButton.setAutoFillBackground(False)
      colorvalue = [int(i * 255.0) for i in self.style['line__color'][0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.lineColorButton.setStyleSheet(colorstr)
      self.lineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.lineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.lineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.lineColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'line__color'))
      self.hLayout2.addWidget(self.lineColorButton)

      # line style
      self.lineStyleGroup = QWidgetMac()
      self.vLayout.addWidget(self.lineStyleGroup)
      self.hLayout3 = QtWidgets.QHBoxLayout(self.lineStyleGroup)
      self.hLayout3.setContentsMargins(0, 0, 0, 0)
      self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
      self.lineStyleLabel = QtWidgets.QLabel('Style')
      self.lineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.lineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayout3.addWidget(self.lineStyleLabel)

      self.lineStyle = QComboBoxMac()
      for entry in self.linestyles:
        self.lineStyle.addItem(entry)
      if(self.style['line__linestyle'] in self.linestyles):
        currindex = self.linestyles.index(self.style['line__linestyle'])
      else:
        currindex = 0
      self.lineStyle.setCurrentIndex(currindex)
      self.lineStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'line__linestyle', self.lineStyle))
      self.lineStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.lineStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.hLayout3.addWidget(self.lineStyle)
 
      # cap style
      self.comboDashStyle = QComboBoxMac()
      for entry in self.dashstyles:
        self.comboDashStyle.addItem(entry)
      if(self.style['line__dash_capstyle'] in self.dashstyles):
        currindex = self.dashstyles.index(self.style['line__dash_capstyle'])
      else:
        currindex = 0
      self.comboDashStyle.setCurrentIndex(currindex)
      self.comboDashStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'line__dash_capstyle', self.comboDashStyle))
      self.comboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.comboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.hLayout3.addWidget(self.comboDashStyle)
      
      # now add some extra attributes for shapes
      if(self.extrasType == 'shape'):
        # shape colors
        self.shapeColorGroup = QWidgetMac()
        self.vLayout.addWidget(self.shapeColorGroup)
        self.hLayout4 = QtWidgets.QHBoxLayout(self.shapeColorGroup)
        self.hLayout4.setContentsMargins(0, 0, 0, 0)
        self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
        self.shapeColorLabel = QPushButtonCheckable()
        self.shapeColorLabel.setText('Fill')
        self.shapeColorLabel.setChecked(self.style['shape__doFill'])
        self.shapeColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.shapeColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.shapeColorLabel.clicked.connect(partial(self.toggleShapeFill, self.targetIndex, 'shape__doFill', self.shapeColorLabel))
        self.hLayout4.addWidget(self.shapeColorLabel)
    
        self.shapeFaceColorButton = QPushButtonMac()
        self.shapeFaceColorButton.setAutoFillBackground(False)
        colorvalue = [int(i*255.0) for i in self.style['shape__facecolor'][0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.shapeFaceColorButton.setStyleSheet(colorstr)
        self.shapeFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.shapeFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.shapeFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
        self.shapeFaceColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'shape__facecolor'))
        self.hLayout4.addWidget(self.shapeFaceColorButton)    
    
        self.comboShapeHatch = QComboBoxMac()
        for entry in self.hatchStyles:
          self.comboShapeHatch.addItem(entry)
        if(self.style['shape__hatch'] in self.hatchStyles):
          currindex = self.hatchStyles.index(self.style['shape__hatch'])
        else:
          currindex = 0
        self.comboShapeHatch.setCurrentIndex(currindex)
        self.comboShapeHatch.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'shape__hatch', self.comboShapeHatch))
        self.comboShapeHatch.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.comboShapeHatch.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.hLayout4.addWidget(self.comboShapeHatch)
        self.comboShapeHatchMultiply = QComboBoxMac()
        for entry in self.hatchMultiplystyles:
          self.comboShapeHatchMultiply.addItem(str(entry))
        if(str(self.style['shape__hatchMultiply']) in self.hatchMultiplystyles):
          currindex = self.hatchMultiplystyles.index(str(self.style['shape__hatchMultiply']))
        else:
          currindex = 0
        self.comboShapeHatchMultiply.setCurrentIndex(currindex)
        self.comboShapeHatchMultiply.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'shape__hatchMultiply', self.comboShapeHatchMultiply))
        self.comboShapeHatchMultiply.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.comboShapeHatchMultiply.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.hLayout4.addWidget(self.comboShapeHatchMultiply)

        # shape angle
        self.configAngleGroup = QWidgetMac()
        self.vLayout.addWidget(self.configAngleGroup)
        self.hLayout5 = QtWidgets.QHBoxLayout(self.configAngleGroup)
        self.hLayout5.setContentsMargins(0, 0, 0, 0)
        self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)    
        self.configAngleLabel = QtWidgets.QLabel('Angle')
        self.configAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.configAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayout5.addWidget(self.configAngleLabel)
    
        self.configAngle = QLineEditClick()
        self.configAngle.setText(str(self.style['rotation']))
        self.configAngle.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configAngle.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configAngle.setValidator(self.validFloat)
        self.configAngle.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'rotation', self.configAngle, 0.0, 360.0))
        self.hLayout5.addWidget(self.configAngle)
    else:
      # build gui for label formatting
      self.formatLabel = QWidgetMac()    
      self.vLayout = QtWidgets.QVBoxLayout(self.formatLabel)
      self.vLayout.setContentsMargins(0, 0, 0, 0)
      self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
      self.vLayout.setSpacing(scaledDPI(2))
      self.hLayout0.addWidget(self.formatLabel)
      
      # heading
      self.extrasStyleLabel = QtWidgets.QLabel()
      self.extrasStyleLabel.setText('Text')
      font = self.extrasStyleLabel.font()
      font.setBold(True)
      self.extrasStyleLabel.setFont(font)
      self.vLayout.addWidget(self.extrasStyleLabel)    
      
      # label position x
      self.labelXGroup = QWidgetMac()
      self.vLayout.addWidget(self.labelXGroup)
      self.hLayout = QtWidgets.QHBoxLayout(self.labelXGroup)
      self.hLayout.setContentsMargins(0, 0, 0, 0)
      self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
      self.labelXLabel = QtWidgets.QLabel('x')
      self.labelXLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.labelXLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout.addWidget(self.labelXLabel)
  
      self.labelXEntry = QLineEditClick()
      self.labelXEntry.setText(str(self.style['x']))
      self.labelXEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelXEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelXEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'x', self.labelXEntry, None, None))
      self.labelXEntry.setValidator(self.validFloat)
      self.hLayout.addWidget(self.labelXEntry)
  
      # label position y
      self.labelYGroup = QWidgetMac()
      self.vLayout.addWidget(self.labelYGroup)
      self.labelYLabel = QtWidgets.QLabel('y')
      self.labelYLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.labelYLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout.addWidget(self.labelYLabel)
  
      self.labelYEntry = QLineEditClick()
      self.labelYEntry.setText(str(self.style['y']))
      self.labelYEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelYEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.labelYEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'y', self.labelYEntry, None, None))
      self.labelYEntry.setValidator(self.validFloat)
      self.hLayout.addWidget(self.labelYEntry)
      
      # label text style
      self.configSizeGroup = QWidgetMac()
      self.vLayout.addWidget(self.configSizeGroup)
      self.hLayout1 = QtWidgets.QHBoxLayout(self.configSizeGroup)
      self.hLayout1.setContentsMargins(0, 0, 0, 0)
      self.hLayout1.setAlignment(QtCore.Qt.AlignLeft)
      self.configSizeLabel = QtWidgets.QLabel('Font')
      self.configSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout1.addWidget(self.configSizeLabel)
  
      self.configColorLabelButton = QPushButtonMac()
      self.configColorLabelButton.setAutoFillBackground(False)
      colorvalue = [int(i*255.0) for i in self.style['color'][0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configColorLabelButton.setStyleSheet(colorstr)
      self.configColorLabelButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configColorLabelButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configColorLabelButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.configColorLabelButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'color'))
      self.hLayout1.addWidget(self.configColorLabelButton)
  
      self.configLabelSize = QLineEditClick()
      self.configLabelSize.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLabelSize.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLabelSize.setText(str(self.style['fontsize']))
      self.configLabelSize.setValidator(self.validFloat)
      self.configLabelSize.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'fontsize', self.configLabelSize, 0.0, 100.0))
      self.hLayout1.addWidget(self.configLabelSize)
      
      self.configLabelBold = QPushButtonCheckable()
      self.configLabelBold.setText('B')
      self.configLabelBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLabelBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      if(self.style['fontweight'] == 'bold'):
        self.configLabelBold.setChecked(True)
      useFont = self.configLabelBold.font()
      useFont.setWeight(75)
      self.configLabelBold.setFont(useFont)
      self.configLabelBold.clicked.connect(partial(self.changeLabelFontStyle, self.targetIndex, 'fontweight', self.configLabelBold))
      self.hLayout1.addWidget(self.configLabelBold)
      
      self.configLabelItalic = QPushButtonCheckable()
      self.configLabelItalic.setText('I')
      self.configLabelItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLabelItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      if(self.style['fontstyle'] == 'italic'):
        self.configLabelItalic.setChecked(True)
      useFont = self.configLabelItalic.font()
      useFont.setItalic(True)
      self.configLabelItalic.setFont(useFont)
      self.configLabelItalic.clicked.connect(partial(self.changeLabelFontStyle, self.targetIndex, 'fontstyle', self.configLabelItalic))
      self.hLayout1.addWidget(self.configLabelItalic)
      
      self.configSizeGroup2 = QWidgetMac()
      self.vLayout.addWidget(self.configSizeGroup2)
      self.hLayout2 = QtWidgets.QHBoxLayout(self.configSizeGroup2)
      self.hLayout2.setContentsMargins(0, 0, 0, 0)
      self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
      spacer = QtWidgets.QLabel('')
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout2.addWidget(spacer)
  
      defaultFont = 'DejaVu Sans'
      self.configLabelFont = QComboBoxMac()
      self.configLabelFont.addItems(self.parent.parent.fontNames)
      self.configLabelFont.setMaximumSize(QtCore.QSize(scaledDPI(140), scaledDPI(BASE_SIZE)))
      self.configLabelFont.setMinimumSize(QtCore.QSize(scaledDPI(140), scaledDPI(BASE_SIZE)))
      if(self.style['fontname'] in self.parent.parent.fontNames):
        currindex = self.parent.parent.fontNames.index(self.style['fontname'])
        self.configLabelFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.parent.fontNames):
        currindex = self.parent.parent.fontNames.index(defaultFont)
        self.configLabelFont.setCurrentIndex(currindex)
      else:
        self.configLabelFont.setCurrentIndex(0)
      self.configLabelFont.activated.connect(partial(self.changeLabelFont, self.targetIndex))
      self.hLayout2.addWidget(self.configLabelFont)
  
      # label angle
      self.configAngleGroup = QWidgetMac()
      self.vLayout.addWidget(self.configAngleGroup)
      self.hLayout3 = QtWidgets.QHBoxLayout(self.configAngleGroup)
      self.hLayout3.setContentsMargins(0, 0, 0, 0)
      self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)    
      self.configAngleLabel = QtWidgets.QLabel('Angle')
      self.configAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout3.addWidget(self.configAngleLabel)
  
      self.configAngle = QLineEditClick()
      self.configAngle.setText(str(self.style['rotation']))
      self.configAngle.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configAngle.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configAngle.setValidator(self.validFloat)
      self.configAngle.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'rotation', self.configAngle, 0.0, 360.0))
      self.hLayout3.addWidget(self.configAngle)
      
      # label alignment
      self.configAlignmentGroup = QWidgetMac()
      self.vLayout.addWidget(self.configAlignmentGroup)
      self.hLayout4 = QtWidgets.QHBoxLayout(self.configAlignmentGroup)
      self.hLayout4.setContentsMargins(0, 0, 0, 0)
      self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)    
      self.configAlignmentLabel = QtWidgets.QLabel('Align')
      self.configAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout4.addWidget(self.configAlignmentLabel)
  
      self.alignHorizontal = ['left', 'center', 'right']
      self.configAlignment = QComboBoxMac()
      self.configAlignment.addItems(self.alignHorizontal)
      if(self.style['horizontalalignment'] in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.style['horizontalalignment'])
        self.configAlignment.setCurrentIndex(currindex)
      else:
        self.configAlignment.setCurrentIndex(0)
      self.configAlignment.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configAlignment.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configAlignment.activated.connect(partial(self.changeLabelAlignment, self.targetIndex))
      self.hLayout4.addWidget(self.configAlignment)
      
      self.alignVertical = ['top', 'center', 'bottom', 'baseline']
      self.configAlignmentVertical = QComboBoxMac()
      self.configAlignmentVertical.addItems(self.alignVertical)
      if(self.style['verticalalignment'] in self.alignVertical):
        currindex = self.alignVertical.index(self.style['verticalalignment'])
        self.configAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configAlignmentVertical.setCurrentIndex(0)
      self.configAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.configAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.configAlignmentVertical.activated.connect(partial(self.changeLabelAlignmentVertical, self.targetIndex))
      self.hLayout4.addWidget(self.configAlignmentVertical)
 
      # checkbox for display of bbox
      self.bboxShowGroup = QWidgetMac()
      self.vLayout.addWidget(self.bboxShowGroup)
      self.hLayout5 = QtWidgets.QHBoxLayout(self.bboxShowGroup)
      self.hLayout5.setContentsMargins(0, 0, 0, 0)
      self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)    
      self.bboxShowLabel = QPushButtonCheckable()
      self.bboxShowLabel.setText('Box?')
      self.bboxShowLabel.setChecked(self.style['bbox__show'])
      self.bboxShowLabel.clicked.connect(partial(self.toggleBbox, self.targetIndex))
      self.bboxShowLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.bboxShowLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.hLayout5.addWidget(self.bboxShowLabel)
  
      # bbox config menu
      self.divider = self.VLine()
      self.hLayout0.addWidget(self.divider)
      # build gui for label formatting
      self.formatBbox = QWidgetMac()    
      self.vLayoutA1 = QtWidgets.QVBoxLayout(self.formatBbox)
      self.vLayoutA1.setContentsMargins(0, 0, 0, 0)
      self.vLayoutA1.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
      self.vLayoutA1.setSpacing(scaledDPI(2))
      self.hLayout0.addWidget(self.formatBbox)
        
      # heading
      self.extrasBboxLabel = QtWidgets.QLabel()
      self.extrasBboxLabel.setText('Box')
      font = self.extrasBboxLabel.font()
      font.setBold(True)
      self.extrasBboxLabel.setFont(font)
      self.vLayoutA1.addWidget(self.extrasBboxLabel)
      
      # bbox line style
      self.bboxLineGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxLineGroup)
      self.hLayoutA2 = QtWidgets.QHBoxLayout(self.bboxLineGroup)
      self.hLayoutA2.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA2.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxLineLabel = QtWidgets.QLabel('Line')
      self.bboxLineLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxLineLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA2.addWidget(self.bboxLineLabel)
  
      self.bboxLineWidthEntry = QLineEditClick()
      self.bboxLineWidthEntry.setText(str(self.style['bbox__linewidth']))
      self.bboxLineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.bboxLineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.bboxLineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'bbox__linewidth', self.bboxLineWidthEntry, 0.0, 100.0))
      self.bboxLineWidthEntry.setValidator(self.validFloat)
      self.hLayoutA2.addWidget(self.bboxLineWidthEntry)
    
      self.comboBboxLineStyle = QComboBoxMac()
      for entry in self.linestyles:
        self.comboBboxLineStyle.addItem(entry)
      if(self.style['bbox__linestyle'] in self.linestyles):
        currindex = self.linestyles.index(self.style['bbox__linestyle'])
      else:
        currindex = 0
      self.comboBboxLineStyle.setCurrentIndex(currindex)
      self.comboBboxLineStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__linestyle', self.comboBboxLineStyle))
      self.comboBboxLineStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.comboBboxLineStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.hLayoutA2.addWidget(self.comboBboxLineStyle)
      
      # cap style
      self.bboxLineGroup2 = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxLineGroup2)
      self.hLayoutA22 = QtWidgets.QHBoxLayout(self.bboxLineGroup2)
      self.hLayoutA22.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA22.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxLineLabel2 = QtWidgets.QLabel('')
      self.bboxLineLabel2.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxLineLabel2.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA22.addWidget(self.bboxLineLabel2)

      self.comboBboxDashStyle = QComboBoxMac()
      for entry in self.dashstyles:
        self.comboBboxDashStyle.addItem(entry)
      if(self.style['bbox__dash_capstyle'] in self.dashstyles):
        currindex = self.dashstyles.index(self.style['bbox__dash_capstyle'])
      else:
        currindex = 0
      self.comboBboxDashStyle.setCurrentIndex(currindex)
      self.comboBboxDashStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__dash_capstyle', self.comboBboxDashStyle))
      self.comboBboxDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.comboBboxDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.hLayoutA22.addWidget(self.comboBboxDashStyle)      
  
      self.bboxLineColorButton = QPushButtonMac()
      self.bboxLineColorButton.setAutoFillBackground(False)
      colorvalue = [int(i*255.0) for i in self.style['bbox__edgecolor'][0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.bboxLineColorButton.setStyleSheet(colorstr)
      self.bboxLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.bboxLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.bboxLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.bboxLineColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'bbox__edgecolor'))
      self.hLayoutA22.addWidget(self.bboxLineColorButton)

      # bbox colors
      self.bboxColorGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxColorGroup)
      self.hLayoutA3 = QtWidgets.QHBoxLayout(self.bboxColorGroup)
      self.hLayoutA3.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA3.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxColorLabel = QPushButtonCheckable()
      self.bboxColorLabel.setText('Fill')
      self.bboxColorLabel.setChecked(self.style['bbox__doFill'])
      self.bboxColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxColorLabel.clicked.connect(partial(self.toggleShapeFill, self.targetIndex, 'bbox__doFill', self.bboxColorLabel))
      self.hLayoutA3.addWidget(self.bboxColorLabel)
  
      self.bboxFaceColorButton = QPushButtonMac()
      self.bboxFaceColorButton.setAutoFillBackground(False)
      colorvalue = [int(i*255.0) for i in self.style['bbox__facecolor'][0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.bboxFaceColorButton.setStyleSheet(colorstr)
      self.bboxFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.bboxFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.bboxFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.bboxFaceColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'bbox__facecolor'))
      self.hLayoutA3.addWidget(self.bboxFaceColorButton)    
  
      self.comboBboxHatch = QComboBoxMac()
      for entry in self.hatchStyles:
        self.comboBboxHatch.addItem(entry)
      if(self.style['bbox__hatch'] in self.hatchStyles):
        currindex = self.hatchStyles.index(self.style['bbox__hatch'])
      else:
        currindex = 0
      self.comboBboxHatch.setCurrentIndex(currindex)
      self.comboBboxHatch.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__hatch', self.comboBboxHatch))
      self.comboBboxHatch.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
      self.comboBboxHatch.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
      self.hLayoutA3.addWidget(self.comboBboxHatch)
      self.comboBboxHatchMultiply = QComboBoxMac()
      for entry in self.hatchMultiplystyles:
        self.comboBboxHatchMultiply.addItem(str(entry))
      if(str(self.style['bbox__hatchMultiply']) in self.hatchMultiplystyles):
        currindex = self.hatchMultiplystyles.index(str(self.style['bbox__hatchMultiply']))
      else:
        currindex = 0
      self.comboBboxHatchMultiply.setCurrentIndex(currindex)
      self.comboBboxHatchMultiply.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__hatchMultiply', self.comboBboxHatchMultiply))
      self.comboBboxHatchMultiply.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
      self.comboBboxHatchMultiply.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
      self.hLayoutA3.addWidget(self.comboBboxHatchMultiply)
      
      # bbox boxstyle
      self.bboxBoxStyleGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxBoxStyleGroup)
      self.hLayoutA4 = QtWidgets.QHBoxLayout(self.bboxBoxStyleGroup)
      self.hLayoutA4.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA4.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxBoxStyleLabel = QtWidgets.QLabel('Style')
      self.bboxBoxStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxBoxStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA4.addWidget(self.bboxBoxStyleLabel)
  
      self.boxStyles = list(matplotlib.patches.BoxStyle.get_styles().keys())
      self.comboBboxBoxStyle = QComboBoxMac()
      for entry in self.boxStyles:
        self.comboBboxBoxStyle.addItem(entry)
      if(self.style['bbox__boxstyle'] in self.boxStyles):
        currindex = self.boxStyles.index(self.style['bbox__boxstyle'])
      else:
        currindex = 0
      self.comboBboxBoxStyle.setCurrentIndex(currindex)
      self.comboBboxBoxStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'bbox__boxstyle', self.comboBboxBoxStyle))
      self.comboBboxBoxStyle.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.comboBboxBoxStyle.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.hLayoutA4.addWidget(self.comboBboxBoxStyle)
      
      # bbox pad
      self.bboxPadGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxPadGroup)
      self.hLayoutA5 = QtWidgets.QHBoxLayout(self.bboxPadGroup)
      self.hLayoutA5.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA5.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxPadLabel = QtWidgets.QLabel('Pad')
      self.bboxPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA5.addWidget(self.bboxPadLabel)
  
      self.bboxPadEntry = QLineEditClick()
      self.bboxPadEntry.setText(str(self.style['bbox__pad']))
      self.bboxPadEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.bboxPadEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.bboxPadEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'bbox__pad', self.bboxPadEntry, 0.0, 100.0))
      self.bboxPadEntry.setValidator(self.validFloat)
      self.hLayoutA5.addWidget(self.bboxPadEntry)
  
      # bbox tooth and round
      self.bboxMiscGroup = QWidgetMac()
      self.vLayoutA1.addWidget(self.bboxMiscGroup)
      self.hLayoutA6 = QtWidgets.QHBoxLayout(self.bboxMiscGroup)
      self.hLayoutA6.setContentsMargins(0, 0, 0, 0)
      self.hLayoutA6.setAlignment(QtCore.Qt.AlignLeft)
      self.bboxToothLabel = QtWidgets.QLabel('Tooth')
      self.bboxToothLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxToothLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA6.addWidget(self.bboxToothLabel)
      self.bboxToothEntry = QLineEditClick()
      self.bboxToothEntry.setText(str(self.style['bbox__tooth_size']))
      self.bboxToothEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.bboxToothEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.bboxToothEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'bbox__tooth_size', self.bboxToothEntry, 0.0, 100.0))
      self.bboxToothEntry.setValidator(self.validFloat)
      self.hLayoutA6.addWidget(self.bboxToothEntry)
  
      self.bboxRoundingLabel = QtWidgets.QLabel('Round')
      self.bboxRoundingLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.bboxRoundingLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.hLayoutA6.addWidget(self.bboxRoundingLabel)
      self.bboxRoundingEntry = QLineEditClick()
      self.bboxRoundingEntry.setText(str(self.style['bbox__rounding_size']))
      self.bboxRoundingEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.bboxRoundingEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.bboxRoundingEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'bbox__rounding_size', self.bboxRoundingEntry, 0.0, 100.0))
      self.bboxRoundingEntry.setValidator(self.validFloat)
      self.hLayoutA6.addWidget(self.bboxRoundingEntry)
  
      # annotation arrow menu
      if(self.extrasType == 'annotation'):
        blah = self.VLine()
        self.hLayout0.addWidget(blah)
        # build gui for label formatting
        self.formatArrow = QWidgetMac()    
        self.vLayoutB1 = QtWidgets.QVBoxLayout(self.formatArrow)
        self.vLayoutB1.setContentsMargins(0, 0, 0, 0)
        self.vLayoutB1.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.vLayoutB1.setSpacing(scaledDPI(2))
        self.hLayout0.addWidget(self.formatArrow)
        
        # heading
        self.extrasArrowLabel = QtWidgets.QLabel()
        self.extrasArrowLabel.setText('Arrow')
        font = self.extrasArrowLabel.font()
        font.setBold(True)
        self.extrasArrowLabel.setFont(font)
        self.vLayoutB1.addWidget(self.extrasArrowLabel)    
  
        # arrow tip position x
        self.arrowXGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowXGroup)
        self.hLayoutB1 = QtWidgets.QHBoxLayout(self.arrowXGroup)
        self.hLayoutB1.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB1.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowXLabel = QtWidgets.QLabel('x')
        self.arrowXLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowXLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB1.addWidget(self.arrowXLabel)
        
        self.arrowXEntry = QLineEditClick()
        self.arrowXEntry.setText(str(self.style['arrow__x']))
        self.arrowXEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowXEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowXEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__x', self.arrowXEntry, None, None))
        self.arrowXEntry.setValidator(self.validFloat)
        self.hLayoutB1.addWidget(self.arrowXEntry)
    
        # label position y
        self.arrowYGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowYGroup)
        self.arrowYLabel = QtWidgets.QLabel('y')
        self.arrowYLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowYLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB1.addWidget(self.arrowYLabel)
    
        self.arrowYEntry = QLineEditClick()
        self.arrowYEntry.setText(str(self.style['arrow__y']))
        self.arrowYEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowYEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowYEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__y', self.arrowYEntry, None, None))
        self.arrowYEntry.setValidator(self.validFloat)
        self.hLayoutB1.addWidget(self.arrowYEntry)
      
        # arrow line style
        self.arrowLineGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowLineGroup)
        self.hLayoutB2 = QtWidgets.QHBoxLayout(self.arrowLineGroup)
        self.hLayoutB2.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB2.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowLineLabel = QtWidgets.QLabel('Line')
        self.arrowLineLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowLineLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB2.addWidget(self.arrowLineLabel)
  
        self.arrowLineWidthEntry = QLineEditClick()
        self.arrowLineWidthEntry.setText(str(self.style['arrow__linewidth']))
        self.arrowLineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowLineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowLineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__linewidth', self.arrowLineWidthEntry, 0.0, 100.0))
        self.arrowLineWidthEntry.setValidator(self.validFloat)
        self.hLayoutB2.addWidget(self.arrowLineWidthEntry)
    
        self.comboArrowLineStyle = QComboBoxMac()
        for entry in self.linestyles:
          self.comboArrowLineStyle.addItem(entry)
        if(self.style['arrow__linestyle'] in self.linestyles):
          currindex = self.linestyles.index(self.style['arrow__linestyle'])
        else:
          currindex = 0
        self.comboArrowLineStyle.setCurrentIndex(currindex)
        self.comboArrowLineStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__linestyle', self.comboArrowLineStyle))
        self.comboArrowLineStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.comboArrowLineStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.hLayoutB2.addWidget(self.comboArrowLineStyle)

        self.arrowLineColorButton = QPushButtonMac()
        self.arrowLineColorButton.setAutoFillBackground(False)
        colorvalue = [int(i*255.0) for i in self.style['arrow__edgecolor'][0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.arrowLineColorButton.setStyleSheet(colorstr)
        self.arrowLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.arrowLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.arrowLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
        self.arrowLineColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'arrow__edgecolor'))
        self.hLayoutB2.addWidget(self.arrowLineColorButton)
    
        # arrow colors
        self.arrowColorGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowColorGroup)
        self.hLayoutB3 = QtWidgets.QHBoxLayout(self.arrowColorGroup)
        self.hLayoutB3.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB3.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowColorLabel = QPushButtonCheckable()
        self.arrowColorLabel.setText('Fill')
        self.arrowColorLabel.setChecked(self.style['arrow__doFill'])
        self.arrowColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowColorLabel.clicked.connect(partial(self.toggleShapeFill, self.targetIndex, 'arrow__doFill', self.arrowColorLabel))
        self.hLayoutB3.addWidget(self.arrowColorLabel)

        self.arrowFaceColorButton = QPushButtonMac()
        self.arrowFaceColorButton.setAutoFillBackground(False)
        colorvalue = [int(i*255.0) for i in self.style['arrow__facecolor'][0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.arrowFaceColorButton.setStyleSheet(colorstr)
        self.arrowFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.arrowFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.arrowFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
        self.arrowFaceColorButton.clicked.connect(partial(self.changeLabelColor, self.targetIndex, 'arrow__facecolor'))
        self.hLayoutB3.addWidget(self.arrowFaceColorButton)
        
        self.hatchStyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
        self.comboArrowHatch = QComboBoxMac()
        for entry in self.hatchStyles:
          self.comboArrowHatch.addItem(entry)
        if(self.style['arrow__hatch'] in self.hatchStyles):
          currindex = self.hatchStyles.index(self.style['arrow__hatch'])
        else:
          currindex = 0
        self.comboArrowHatch.setCurrentIndex(currindex)
        self.comboArrowHatch.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__hatch', self.comboArrowHatch))
        self.comboArrowHatch.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.comboArrowHatch.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.hLayoutB3.addWidget(self.comboArrowHatch)
        self.comboArrowHatchMultiply = QComboBoxMac()
        for entry in self.hatchMultiplystyles:
          self.comboArrowHatchMultiply.addItem(str(entry))
        if(str(self.style['arrow__hatchMultiply']) in self.hatchMultiplystyles):
          currindex = self.hatchMultiplystyles.index(str(self.style['arrow__hatchMultiply']))
        else:
          currindex = 0
        self.comboArrowHatchMultiply.setCurrentIndex(currindex)
        self.comboArrowHatchMultiply.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__hatchMultiply', self.comboArrowHatchMultiply))
        self.comboArrowHatchMultiply.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.comboArrowHatchMultiply.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.hLayoutB3.addWidget(self.comboArrowHatchMultiply)
      
        # arrow shrink
        self.arrowShrinkGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowShrinkGroup)
        self.hLayoutB4 = QtWidgets.QHBoxLayout(self.arrowShrinkGroup)
        self.hLayoutB4.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB4.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowShrinkALabel = QtWidgets.QLabel('ShrinkA')
        self.arrowShrinkALabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowShrinkALabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB4.addWidget(self.arrowShrinkALabel)
  
        self.arrowShrinkAEntry = QLineEditClick()
        self.arrowShrinkAEntry.setText(str(self.style['arrow__shrinkA']))
        self.arrowShrinkAEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowShrinkAEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowShrinkAEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__shrinkA', self.arrowShrinkAEntry, 0.0, 1000.0))
        self.arrowShrinkAEntry.setValidator(self.validFloat)
        self.hLayoutB4.addWidget(self.arrowShrinkAEntry)
        
        self.arrowShrinkBLabel = QtWidgets.QLabel('ShrinkB')
        self.arrowShrinkBLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowShrinkBLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB4.addWidget(self.arrowShrinkBLabel)
  
        self.arrowShrinkBEntry = QLineEditClick()
        self.arrowShrinkBEntry.setText(str(self.style['arrow__shrinkB']))
        self.arrowShrinkBEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowShrinkBEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowShrinkBEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__shrinkB', self.arrowShrinkBEntry, 0.0, 1000.0))
        self.arrowShrinkBEntry.setValidator(self.validFloat)
        self.hLayoutB4.addWidget(self.arrowShrinkBEntry)
        
        # arrow style
        self.arrowStyleGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowStyleGroup)
        self.hLayoutB5 = QtWidgets.QHBoxLayout(self.arrowStyleGroup)
        self.hLayoutB5.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB5.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowStyleLabel = QtWidgets.QLabel('Style')
        self.arrowStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB5.addWidget(self.arrowStyleLabel)
  
        self.arrowStyles = list(matplotlib.patches.ArrowStyle.get_styles().keys())
        self.comboArrowStyle = QComboBoxMac()
        for entry in self.arrowStyles:
          self.comboArrowStyle.addItem(entry)
        if(self.style['arrow__arrowstyle'] in self.arrowStyles):
          currindex = self.arrowStyles.index(self.style['arrow__arrowstyle'])
        else:
          currindex = 0
        self.comboArrowStyle.setCurrentIndex(currindex)
        self.comboArrowStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__arrowstyle', self.comboArrowStyle))
        self.comboArrowStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.comboArrowStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.hLayoutB5.addWidget(self.comboArrowStyle)
        
        # connection style
        self.arrowConnectGroup = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowConnectGroup)
        self.hLayoutB6 = QtWidgets.QHBoxLayout(self.arrowConnectGroup)
        self.hLayoutB6.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB6.setAlignment(QtCore.Qt.AlignLeft)
        self.arrowConnectLabel = QtWidgets.QLabel('Connect')
        self.arrowConnectLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowConnectLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB6.addWidget(self.arrowConnectLabel)
  
        self.connectStyles = list(matplotlib.patches.ConnectionStyle.get_styles().keys())
        if(('arc' in self.connectStyles) and ('arc3' in self.connectStyles)):
          self.connectStyles.remove('arc')
        if(('angle' in self.connectStyles) and ('angle3' in self.connectStyles)):
          self.connectStyles.remove('angle')
        self.comboConnectStyle = QComboBoxMac()
        for entry in self.connectStyles:
          self.comboConnectStyle.addItem(entry)
        if(self.style['arrow__connector'] in self.connectStyles):
          currindex = self.connectStyles.index(self.style['arrow__connector'])
        else:
          currindex = 0
        self.comboConnectStyle.setCurrentIndex(currindex)
        self.comboConnectStyle.activated.connect(partial(self.changeLineStyle, self.targetIndex, 'arrow__connector', self.comboConnectStyle))
        self.comboConnectStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.comboConnectStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
        self.hLayoutB6.addWidget(self.comboConnectStyle)
  
        # arrow configuration encore
        self.arrowParamGroup1 = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowParamGroup1)
        self.hLayoutB7 = QtWidgets.QHBoxLayout(self.arrowParamGroup1)
        self.hLayoutB7.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB7.setAlignment(QtCore.Qt.AlignLeft)
  
        self.arrowLengthALabel = QtWidgets.QLabel('LengthA')
        self.arrowLengthALabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowLengthALabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB7.addWidget(self.arrowLengthALabel)
        self.arrowLengthAEntry = QLineEditClick()
        self.arrowLengthAEntry.setText(str(self.style['arrow__lengthA']))
        self.arrowLengthAEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowLengthAEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowLengthAEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__lengthA', self.arrowLengthAEntry, 0.0, 500.0))
        self.arrowLengthAEntry.setValidator(self.validFloat)
        self.hLayoutB7.addWidget(self.arrowLengthAEntry)
  
        self.arrowWidthALabel = QtWidgets.QLabel('WidthA')
        self.arrowWidthALabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowWidthALabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB7.addWidget(self.arrowWidthALabel)
        self.arrowWidthAEntry = QLineEditClick()
        self.arrowWidthAEntry.setText(str(self.style['arrow__widthA']))
        self.arrowWidthAEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowWidthAEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowWidthAEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__widthA', self.arrowWidthAEntry, 0.0, 500.0))
        self.arrowWidthAEntry.setValidator(self.validFloat)
        self.hLayoutB7.addWidget(self.arrowWidthAEntry)
  
        self.arrowParamGroup2 = QWidgetMac()
        self.vLayoutB1.addWidget(self.arrowParamGroup2)
        self.hLayoutB8 = QtWidgets.QHBoxLayout(self.arrowParamGroup2)
        self.hLayoutB8.setContentsMargins(0, 0, 0, 0)
        self.hLayoutB8.setAlignment(QtCore.Qt.AlignLeft)
  
        self.arrowLengthBLabel = QtWidgets.QLabel('LengthB')
        self.arrowLengthBLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowLengthBLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB8.addWidget(self.arrowLengthBLabel)
        self.arrowLengthBEntry = QLineEditClick()
        self.arrowLengthBEntry.setText(str(self.style['arrow__lengthB']))
        self.arrowLengthBEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowLengthBEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowLengthBEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__lengthB', self.arrowLengthBEntry, 0.0, 500.0))
        self.arrowLengthBEntry.setValidator(self.validFloat)
        self.hLayoutB8.addWidget(self.arrowLengthBEntry)
  
        self.arrowWidthBLabel = QtWidgets.QLabel('WidthB')
        self.arrowWidthBLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.arrowWidthBLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
        self.hLayoutB8.addWidget(self.arrowWidthBLabel)
        self.arrowWidthBEntry = QLineEditClick()
        self.arrowWidthBEntry.setText(str(self.style['arrow__widthB']))
        self.arrowWidthBEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowWidthBEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.arrowWidthBEntry.editingFinished.connect(partial(self.changeStyle, self.targetIndex, 'arrow__widthB', self.arrowWidthBEntry, 0.0, 500.0))
        self.arrowWidthBEntry.setValidator(self.validFloat)
        self.hLayoutB8.addWidget(self.arrowWidthBEntry)
        
      # finally update display of bbox config
      self.toggleBbox(self.targetIndex)
    
    self.setFocus()
    self.focusNextChild()

  def toggleBbox(self, targetIndex=None):
    # toggles display of bbox
    if(targetIndex != None):
      state = self.bboxShowLabel.isChecked()
      self.style['bbox__show'] = state
      self.parent.parent.extras[targetIndex].setStyle('bbox__show', state, redraw=True)
      # toggle display of bbox config menu
      if(state):
        self.formatBbox.show()
        self.divider.show()
      else:
        self.formatBbox.hide()
        self.divider.hide()
      self.upperRow.adjustSize()
      self.adjustSize()

  def changeLabelAlignment(self, targetIndex=None):
    if(targetIndex != None):
      useAlignment = str(self.configAlignment.currentText())
      self.parent.parent.extras[targetIndex].setStyle('horizontalalignment', useAlignment, redraw=True)
    
  def changeLabelAlignmentVertical(self, targetIndex=None):
    if(targetIndex != None):
      useAlignment = str(self.configAlignmentVertical.currentText())
      self.parent.parent.extras[targetIndex].setStyle('verticalalignment', useAlignment, redraw=True)
    
  def changeLabelFont(self, targetIndex=None):
    if(targetIndex != None):
      useFont = str(self.configLabelFont.currentText())
      self.parent.parent.extras[targetIndex].setStyle('fontname', useFont, redraw=True)
    
  def changeLabelFontStyle(self, targetIndex=None, key=None, entryfield=None):
    if((targetIndex != None) and (key in ['fontweight', 'fontstyle']) and (entryfield != None)):
      value = 'normal'
      isChecked = entryfield.isChecked()
      if(key == 'fontweight'):
        if(isChecked):
          value = 'bold'
      else:
        if(isChecked):
          value = 'italic'
      self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)
    
  def changeLabelColor(self, targetIndex=None, key=None):
    # colors the text element
    if((targetIndex != None) and (key in self.style)):
      # get current color
      prevColor = [255*i for i in self.style[key]]
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def changeStyle(self, targetIndex=None, key=None, entryfield=None, minval=0, maxval=1):
    if((targetIndex != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      if(maxval != None):
        value = np.min((value, maxval))
      if(minval != None):
        value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if(key in self.style):
        self.style[key] = value
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def changeSpokeNumber(self, targetIndex=None, key=None, entryfield=None):
    if((targetIndex != None) and (key != None)):
      # get current value
      value = entryfield.value()
      if(key in self.style):
        self.style[key] = value
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def changeLineStyle(self, targetIndex=None, key=None, entryfield=None, minval=0, maxval=1):
    if((targetIndex != None) and (key != None)):
      # check paramter boundaries
      value = str(entryfield.currentText())
      if(key in self.style):
        if('__hatchMultiply' in key):
          value = int(value)
        self.style[key] = value
        if(key == 'line__dash_capstyle'):
          self.parent.parent.extras[targetIndex].setStyle('line__solid_capstyle', value, redraw=False)
        self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)
        
      # update config menu?
      if(key == 'shape__type'):
        if(self.style['shape__type'] in ['poly', 'star']):
          self.spokeNumberSpinBox.show()
        else:
          self.spokeNumberSpinBox.hide()
        #
        if(self.style['shape__type'] == 'star'):
          self.spikySpokeGroup.show()
        else:
          self.spikySpokeGroup.hide()
        self.formatLine.adjustSize()
        self.adjustSize()
        
  def alterZ(self, index, direction):
    field = None
    if(hasattr(self.parent.parent.objectsarea, 'extrasTable')):
      field = self.parent.parent.objectsarea.extrasTable.cellWidget(index, 1)
    if(field != None):
      value, minimum, maximum = field.value(), field.minimum(), field.maximum()
      newValue = value + direction
      newValue = max(minimum, newValue)
      newValue = min(maximum, newValue)
      # set new value
      if(newValue != value):
        field.setValue(newValue)
      # (in)activate control buttons
      if(newValue == minimum):
        self.zDownButton.setEnabled(False)
      else:
        self.zDownButton.setEnabled(True)
      if(newValue == maximum):
        self.zUpButton.setEnabled(False)
      else:
        self.zUpButton.setEnabled(True)

  def setField(self, index):
    text = self.entryField.text()
    if(hasattr(self.parent.parent.objectsarea, 'extrasTable')):
      field = self.parent.parent.objectsarea.extrasTable.cellWidget(index, 2)
      field.setText(text)
      field.editingFinished.emit()

  def toggleShapeFill(self, targetIndex=None, key=None, entryfield=None):
    # toggles whether shape elements are filled or not
    if((targetIndex != None) and (key != None)):
      value = entryfield.isChecked()
      self.style[key] = value
      self.parent.parent.extras[targetIndex].setStyle(key, value, redraw=True)

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

class violinBoxMenu(QWidgetMac):
  def __init__(self, parent=None, target=None):
    super(violinBoxMenu, self).__init__(parent)
    self.parent = parent
    self.target = target
    
    # set up mode
    getStyle = self.target.getViolinStyle()
    if('mode' in getStyle):
      self.mode = getStyle['mode']
    else:
      self.mode = 0

    # set up GUI
    self.buildRessource()

  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))

    self.topContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.topContainer)
    self.hLayout = QtWidgets.QHBoxLayout(self.topContainer)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.hLayout.setSpacing(scaledDPI(2))
    
    # the main violin/box plot selector
    self.violinSelectorGroupBox = QtWidgets.QGroupBox()
    self.violinSelectorGroupBox.setMinimumHeight(scaledDPI(BASE_SIZE + 4))
    self.violinSelectorGroupBox.setMaximumHeight(scaledDPI(BASE_SIZE + 4))
    self.hLayout.addWidget(self.violinSelectorGroupBox)
    self.violinSelectorLayout = QtWidgets.QHBoxLayout(self.violinSelectorGroupBox)
    self.violinSelectorLayout.setContentsMargins(scaledDPI(1), 0, 0, 0)

    self.violinSelectorGroup = QtWidgets.QButtonGroup()
    self.violinSelectorButtons = []
    self.violinSelectorButtons.append(QtWidgets.QRadioButton())
    self.violinSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(44), scaledDPI(BASE_SIZE)))
    self.violinSelectorButtons[-1].setChecked(self.mode == 0)
    self.violinSelectorButtons[-1].toggled.connect(partial(self.toggleViolin, 0))
    self.violinSelectorButtons[-1].setText('none')  

    self.violinSelectorButtons.append(QtWidgets.QRadioButton())
    self.violinSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.violinSelectorButtons[-1].setChecked(self.mode == 1)
    self.violinSelectorButtons[-1].toggled.connect(partial(self.toggleViolin, 1))
    self.violinSelectorButtons[-1].setText('violin')
    
    self.violinSelectorButtons.append(QtWidgets.QRadioButton())
    self.violinSelectorButtons[-1].setGeometry(QtCore.QRect(scaledDPI(2), scaledDPI(2), scaledDPI(100), scaledDPI(BASE_SIZE)))
    self.violinSelectorButtons[-1].setChecked(self.mode == 2)
    self.violinSelectorButtons[-1].toggled.connect(partial(self.toggleViolin, 2))
    self.violinSelectorButtons[-1].setText('box')
    
    for entry in self.violinSelectorButtons:
      self.violinSelectorLayout.addWidget(entry)
      self.violinSelectorGroup.addButton(entry)
    self.hLayout.addStretch()
     
    # put the menus
    self.violinContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.violinContainer)
    self.vLayout1 = QtWidgets.QVBoxLayout(self.violinContainer)
    self.vLayout1.setContentsMargins(0, 0, 0, 0)
    self.vLayout1.setAlignment(QtCore.Qt.AlignTop)
    self.vLayout1.setSpacing(scaledDPI(0))
    self.violinStyleMenu = violinStyleMenu(self.parent, self.target)
    self.vLayout1.addWidget(self.violinStyleMenu)
    
    self.boxContainer = QWidgetMac(self)
    self.vLayout.addWidget(self.boxContainer)
    self.vLayout2 = QtWidgets.QVBoxLayout(self.boxContainer)
    self.vLayout2.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.setAlignment(QtCore.Qt.AlignTop)
    self.vLayout2.setSpacing(scaledDPI(0))
    self.boxStyleMenu = boxStyleMenu(self.parent, self.target)
    self.vLayout2.addWidget(self.boxStyleMenu)
    
    # initialize menus
    self.setMenuDisplay()
    
  def setMenuDisplay(self):
    # sets display of menus
    if(self.mode == 1):
      self.violinContainer.show()
    else:
      self.violinContainer.hide()
    if(self.mode == 2):
      self.boxContainer.show()
    else:
      self.boxContainer.hide()
      
    # resize to contents
    self.adjustSize()
    self.parent.violinRow.adjustSize()
    self.parent.adjustSize()

  def toggleViolin(self, mode=0):
    # toggles on/off violin plot
    # only trigger event for button that was turned on
    if(self.violinSelectorButtons[mode].isChecked()):
      self.mode = mode
      self.setMenuDisplay()
        
      if(self.target != None):
        self.target.toggleViolin(mode, redraw=True)

class violinStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None):
    super(violinStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target

    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.hatchstyles = ['None', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*'] # unfortunately none is not interpreted correctly
    self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      getStyle = self.target.getViolinStyle()

      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        if(type(getStyle[entry]) == type({})):
          # have to deepcopy inner dicts to prevent inadvertent overwriting of values
          self.style[entry] = deepcopy(getStyle[entry])
        else:
          self.style[entry] = getStyle[entry]
    
    # set default values
    defaultStyle = {}
    defaultStyle['mode'] = 0
    defaultStyle['bodies'] = {'facecolor': [0.8, 0.8, 0.9, 1.0], 'edgecolor': [0.2, 0.2, 0.2, 1.0], 'linestyle': 'solid', 'linewidth': 1.0,\
                'capstyle': 'butt', 'hatch': '', 'hatchMultiply': 1, 'visible': True, 'width': 0.5, 'doFill': True}
    defaultStyle['cmaxes'] = {'linestyle': 'solid', 'linewidth': 1.0, 'color': [0.2, 0.2, 0.2, 1.0], 'capstyle': 'butt', 'visible': True}
    for slaved in ['cbars', 'cmeans']:
      defaultStyle[slaved] = {}
      defaultStyle[slaved].update(defaultStyle['cmaxes'])
    defaultStyle['cmedians'] = {'visible': False}
    defaultStyle['cmins'] = {'visible': True}
    for entry in defaultStyle:
      if(not (entry in self.style)):
        self.style[entry] = defaultStyle[entry]

    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.hLayout = QtWidgets.QHBoxLayout(self)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.hLayout.setSpacing(scaledDPI(2))
    
    # bodies
    self.bodiesContainer = QWidgetMac(self)
    self.hLayout.addWidget(self.bodiesContainer)
    self.vLayout = QtWidgets.QVBoxLayout(self.bodiesContainer)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
      
    self.displayBodiesGroup = QWidgetMac()
    self.vLayout.addWidget(self.displayBodiesGroup)
    self.hLayout0 = QtWidgets.QHBoxLayout(self.displayBodiesGroup)
    self.hLayout0.setContentsMargins(0, 0, 0, 0)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesStyleLabel = QtWidgets.QLabel()
    self.bodiesStyleLabel.setText('Bodies')
    font = self.bodiesStyleLabel.font()
    font.setBold(True)
    self.bodiesStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesStyleLabel.setFont(font)
    self.hLayout0.addWidget(self.bodiesStyleLabel)    
    
    # display bodies?
    self.displayBodiesLabel = QPushButtonCheckable()
    self.displayBodiesLabel.setText('Show?')
    self.displayBodiesLabel.setChecked(self.style['bodies']['visible'])
    self.displayBodiesLabel.clicked.connect(partial(self.setDisplay, self.target, 'bodies', self.displayBodiesLabel))
    self.displayBodiesLabel.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displayBodiesLabel.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout0.addWidget(self.displayBodiesLabel)

    # line width
    self.bodiesLineWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesLineWidthGroup)
    self.hLayout1 = QtWidgets.QHBoxLayout(self.bodiesLineWidthGroup)
    self.hLayout1.setContentsMargins(0, 0, 0, 0)
    self.hLayout1.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesLineWidthLabel = QtWidgets.QLabel('Width')
    self.bodiesLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout1.addWidget(self.bodiesLineWidthLabel)
    self.bodiesLineWidthEntry = QLineEditClick()
    self.bodiesLineWidthEntry.setText(str(self.style['bodies']['linewidth']))
    self.bodiesLineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.bodiesLineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.bodiesLineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'bodies', 'linewidth', self.bodiesLineWidthEntry, 0.0, 100.0))
    self.bodiesLineWidthEntry.setValidator(self.validFloat)
    self.hLayout1.addWidget(self.bodiesLineWidthEntry)
    
    # line color
    self.bodiesLineColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesLineColorGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.bodiesLineColorGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesLineColorLabel = QtWidgets.QLabel('Color')
    self.bodiesLineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesLineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.bodiesLineColorLabel)
      
    self.bodiesLineColorButton = QPushButtonMac()
    self.bodiesLineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['bodies']['edgecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.bodiesLineColorButton.setStyleSheet(colorstr)
    self.bodiesLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.bodiesLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.bodiesLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.bodiesLineColorButton.clicked.connect(partial(self.setColor, self.target, 'bodies', 'edgecolor'))
    self.hLayout2.addWidget(self.bodiesLineColorButton)
      
    # line style
    self.bodiesLineStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesLineStyleGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.bodiesLineStyleGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesLineStyleLabel = QtWidgets.QLabel('Style')
    self.bodiesLineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesLineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.bodiesLineStyleLabel)
    self.bodiesComboStyle = QComboBoxMac()
    for entry in self.linestyles:
      self.bodiesComboStyle.addItem(entry)
    if(self.style['bodies']['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['bodies']['linestyle'])
    else:
      currindex = 0
    self.bodiesComboStyle.setCurrentIndex(currindex)
    self.bodiesComboStyle.activated.connect(partial(self.selectStyle, self.target, 'bodies', 'linestyle', self.bodiesComboStyle))
    self.bodiesComboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.bodiesComboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.bodiesComboStyle)

    # cap style
    self.bodiesLineDashStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesLineDashStyleGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.bodiesLineDashStyleGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesLineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.bodiesLineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesLineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.bodiesLineDashStyleLabel)
    self.bodiesComboDashStyle = QComboBoxMac()
    for entry in self.dashstyles:
      self.bodiesComboDashStyle.addItem(entry)
    if(self.style['bodies']['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['bodies']['capstyle'])
    else:
      currindex = 0
    self.bodiesComboDashStyle.setCurrentIndex(currindex)
    self.bodiesComboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'bodies', 'capstyle', self.bodiesComboDashStyle))
    self.bodiesComboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.bodiesComboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.bodiesComboDashStyle)

    # fill color
    self.bodiesFillColorGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesFillColorGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.bodiesFillColorGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesFillColorLabel = QPushButtonCheckable()
    self.bodiesFillColorLabel.setText('Fill')
    self.bodiesFillColorLabel.setChecked(self.style['bodies']['doFill'])
    self.bodiesFillColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesFillColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesFillColorLabel.clicked.connect(partial(self.toggleBodyFill, self.target, self.bodiesFillColorLabel))
    self.hLayout5.addWidget(self.bodiesFillColorLabel)
      
    self.bodiesFillColorButton = QPushButtonMac()
    self.bodiesFillColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['bodies']['facecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.bodiesFillColorButton.setStyleSheet(colorstr)
    self.bodiesFillColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.bodiesFillColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.bodiesFillColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.bodiesFillColorButton.clicked.connect(partial(self.setColor, self.target, 'bodies', 'facecolor'))
    self.hLayout5.addWidget(self.bodiesFillColorButton)
      
    # hatch style
    self.bodiesHatchStyleGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesHatchStyleGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.bodiesHatchStyleGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesHatchStyleLabel = QtWidgets.QLabel('Hatch')
    self.bodiesHatchStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesHatchStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.bodiesHatchStyleLabel)
    self.bodiesComboHatchStyle = QComboBoxMac()
    for entry in self.hatchstyles:
      self.bodiesComboHatchStyle.addItem(entry)
    if(self.style['bodies']['hatch'] in self.hatchstyles):
      currindex = self.hatchstyles.index(self.style['bodies']['hatch'])
    else:
      currindex = 0
    self.bodiesComboHatchStyle.setCurrentIndex(currindex)
    self.bodiesComboHatchStyle.activated.connect(partial(self.selectStyle, self.target, 'bodies', 'hatch', self.bodiesComboHatchStyle))
    self.bodiesComboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.bodiesComboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.bodiesComboHatchStyle)
    self.bodiesComboHatchMultiplyStyle = QComboBoxMac()
    for entry in self.hatchMultiplystyles:
      self.bodiesComboHatchMultiplyStyle.addItem(str(entry))
    if(str(self.style['bodies']['hatchMultiply']) in self.hatchMultiplystyles):
      currindex = self.hatchMultiplystyles.index(str(self.style['bodies']['hatchMultiply']))
    else:
      currindex = 0
    self.bodiesComboHatchMultiplyStyle.setCurrentIndex(currindex)
    self.bodiesComboHatchMultiplyStyle.activated.connect(partial(self.selectStyle, self.target, 'bodies', 'hatchMultiply', self.bodiesComboHatchMultiplyStyle))
    self.bodiesComboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.bodiesComboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.bodiesComboHatchMultiplyStyle)

    # body width
    self.bodiesWidthGroup = QWidgetMac()
    self.vLayout.addWidget(self.bodiesWidthGroup)
    self.hLayout05 = QtWidgets.QHBoxLayout(self.bodiesWidthGroup)
    self.hLayout05.setContentsMargins(0, 0, 0, 0)
    self.hLayout05.setAlignment(QtCore.Qt.AlignLeft)
    self.bodiesWidthLabel = QtWidgets.QLabel('BWid')
    self.bodiesWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.bodiesWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout05.addWidget(self.bodiesWidthLabel)
    self.bodiesWidthEntry = QLineEditClick()
    self.bodiesWidthEntry.setText(str(self.style['bodies']['width']))
    self.bodiesWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.bodiesWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.bodiesWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'bodies', 'width', self.bodiesWidthEntry, 0.0, 100.0))
    self.bodiesWidthEntry.setValidator(self.validFloat)
    self.hLayout05.addWidget(self.bodiesWidthEntry)
    
    # cmaxes/cmins
    blah = self.VLine()
    self.hLayout.addWidget(blah)

    self.cmaxesContainer = QWidgetMac(self)
    self.hLayout.addWidget(self.cmaxesContainer)
    self.vLayout2 = QtWidgets.QVBoxLayout(self.cmaxesContainer)
    self.vLayout2.setContentsMargins(0, 0, 0, 0)
    self.vLayout2.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout2.setSpacing(scaledDPI(2))
      
    self.displayCmaxesGroup = QWidgetMac()
    self.vLayout2.addWidget(self.displayCmaxesGroup)
    self.hLayout8 = QtWidgets.QHBoxLayout(self.displayCmaxesGroup)
    self.hLayout8.setContentsMargins(0, 0, 0, 0)
    self.hLayout8.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesStyleLabel = QtWidgets.QLabel()
    # for time being control min and max lines jointly
    self.cmaxesStyleLabel.setText('Min/Max')
    font = self.cmaxesStyleLabel.font()
    font.setBold(True)
    self.cmaxesStyleLabel.setFont(font)
    self.hLayout8.addWidget(self.cmaxesStyleLabel)    
    
    # display min/max?
    self.displayCmaxesCheck = QPushButtonCheckable()
    self.displayCmaxesCheck.setText('S?')
    self.displayCmaxesCheck.setChecked(self.style['cmins']['visible'])
    self.displayCmaxesCheck.clicked.connect(partial(self.setDisplay, self.target, 'cmins', self.displayCmaxesCheck))
    self.displayCmaxesCheck.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmaxesCheck.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.hLayout8.addWidget(self.displayCmaxesCheck)
    self.displayCmaxesCheck2 = QPushButtonCheckable()
    self.displayCmaxesCheck2.setText('S?')
    self.displayCmaxesCheck2.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmaxesCheck2.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmaxesCheck2.setChecked(self.style['cmaxes']['visible'])
    self.displayCmaxesCheck2.clicked.connect(partial(self.setDisplay, self.target, 'cmaxes', self.displayCmaxesCheck2))
    self.hLayout8.addWidget(self.displayCmaxesCheck2)
    
    # line width
    self.cmaxesLineWidthGroup = QWidgetMac()
    self.vLayout2.addWidget(self.cmaxesLineWidthGroup)
    self.hLayout9 = QtWidgets.QHBoxLayout(self.cmaxesLineWidthGroup)
    self.hLayout9.setContentsMargins(0, 0, 0, 0)
    self.hLayout9.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesLineWidthLabel = QtWidgets.QLabel('Width')
    self.cmaxesLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmaxesLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout9.addWidget(self.cmaxesLineWidthLabel)
    self.cmaxesLineWidthEntry = QLineEditClick()
    self.cmaxesLineWidthEntry.setText(str(self.style['cmaxes']['linewidth']))
    self.cmaxesLineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.cmaxesLineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.cmaxesLineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'cmaxes', 'linewidth', self.cmaxesLineWidthEntry, 0.0, 100.0))
    self.cmaxesLineWidthEntry.setValidator(self.validFloat)
    self.hLayout9.addWidget(self.cmaxesLineWidthEntry)
    
    # line color
    self.cmaxesLineColorGroup = QWidgetMac()
    self.vLayout2.addWidget(self.cmaxesLineColorGroup)
    self.hLayout10 = QtWidgets.QHBoxLayout(self.cmaxesLineColorGroup)
    self.hLayout10.setContentsMargins(0, 0, 0, 0)
    self.hLayout10.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesLineColorLabel = QtWidgets.QLabel('Color')
    self.cmaxesLineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
    self.cmaxesLineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
    self.hLayout10.addWidget(self.cmaxesLineColorLabel)
      
    self.cmaxesLineColorButton = QPushButtonMac()
    self.cmaxesLineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['cmaxes']['color'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.cmaxesLineColorButton.setStyleSheet(colorstr)
    self.cmaxesLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cmaxesLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cmaxesLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.cmaxesLineColorButton.clicked.connect(partial(self.setColor, self.target, 'cmaxes', 'color'))
    self.hLayout10.addWidget(self.cmaxesLineColorButton)
      
    # line style
    self.cmaxesLineStyleGroup = QWidgetMac()
    self.vLayout2.addWidget(self.cmaxesLineStyleGroup)
    self.hLayout11 = QtWidgets.QHBoxLayout(self.cmaxesLineStyleGroup)
    self.hLayout11.setContentsMargins(0, 0, 0, 0)
    self.hLayout11.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesLineStyleLabel = QtWidgets.QLabel('Style')
    self.cmaxesLineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmaxesLineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout11.addWidget(self.cmaxesLineStyleLabel)
    self.cmaxesComboStyle = QComboBoxMac()
    for entry in self.linestyles:
      self.cmaxesComboStyle.addItem(entry)
    if(self.style['cmaxes']['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['cmaxes']['linestyle'])
    else:
      currindex = 0
    self.cmaxesComboStyle.setCurrentIndex(currindex)
    self.cmaxesComboStyle.activated.connect(partial(self.selectStyle, self.target, 'cmaxes', 'linestyle', self.cmaxesComboStyle))
    self.cmaxesComboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cmaxesComboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout11.addWidget(self.cmaxesComboStyle)

    # cap style
    self.cmaxesLineDashStyleGroup = QWidgetMac()
    self.vLayout2.addWidget(self.cmaxesLineDashStyleGroup)
    self.hLayout12 = QtWidgets.QHBoxLayout(self.cmaxesLineDashStyleGroup)
    self.hLayout12.setContentsMargins(0, 0, 0, 0)
    self.hLayout12.setAlignment(QtCore.Qt.AlignLeft)
    self.cmaxesLineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.cmaxesLineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmaxesLineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout12.addWidget(self.cmaxesLineDashStyleLabel)
    self.cmaxesComboDashStyle = QComboBoxMac()
    for entry in self.dashstyles:
      self.cmaxesComboDashStyle.addItem(entry)
    if(self.style['cmaxes']['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['cmaxes']['capstyle'])
    else:
      currindex = 0
    self.cmaxesComboDashStyle.setCurrentIndex(currindex)
    self.cmaxesComboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'cmaxes', 'capstyle', self.cmaxesComboDashStyle))
    self.cmaxesComboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cmaxesComboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout12.addWidget(self.cmaxesComboDashStyle)

    # cbars
    blah = self.VLine()
    self.hLayout.addWidget(blah)

    self.cbarsContainer = QWidgetMac(self)
    self.hLayout.addWidget(self.cbarsContainer)
    self.vLayout3 = QtWidgets.QVBoxLayout(self.cbarsContainer)
    self.vLayout3.setContentsMargins(0, 0, 0, 0)
    self.vLayout3.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout3.setSpacing(scaledDPI(2))
      
    self.displaycbarsGroup = QWidgetMac()
    self.vLayout3.addWidget(self.displaycbarsGroup)
    self.hLayout13 = QtWidgets.QHBoxLayout(self.displaycbarsGroup)
    self.hLayout13.setContentsMargins(0, 0, 0, 0)
    self.hLayout13.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsStyleLabel = QtWidgets.QLabel()
    # for time being control min and max lines jointly
    self.cbarsStyleLabel.setText('Bars')
    font = self.cbarsStyleLabel.font()
    font.setBold(True)
    self.cbarsStyleLabel.setFont(font)
    self.cbarsStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout13.addWidget(self.cbarsStyleLabel)    
    
    # display bars?
    self.displaycbarsLabel = QPushButtonCheckable()
    self.displaycbarsLabel.setText('Show?')
    self.displaycbarsLabel.setChecked(self.style['cbars']['visible'])
    self.displaycbarsLabel.clicked.connect(partial(self.setDisplay, self.target, 'cbars', self.displaycbarsLabel))
    self.displaycbarsLabel.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displaycbarsLabel.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout13.addWidget(self.displaycbarsLabel)

    # line width
    self.cbarsLineWidthGroup = QWidgetMac()
    self.vLayout3.addWidget(self.cbarsLineWidthGroup)
    self.hLayout14 = QtWidgets.QHBoxLayout(self.cbarsLineWidthGroup)
    self.hLayout14.setContentsMargins(0, 0, 0, 0)
    self.hLayout14.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsLineWidthLabel = QtWidgets.QLabel('Width')
    self.cbarsLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout14.addWidget(self.cbarsLineWidthLabel)
    self.cbarsLineWidthEntry = QLineEditClick()
    self.cbarsLineWidthEntry.setText(str(self.style['cbars']['linewidth']))
    self.cbarsLineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.cbarsLineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.cbarsLineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'cbars', 'linewidth', self.cbarsLineWidthEntry, 0.0, 100.0))
    self.cbarsLineWidthEntry.setValidator(self.validFloat)
    self.hLayout14.addWidget(self.cbarsLineWidthEntry)
    
    # line color
    self.cbarsLineColorGroup = QWidgetMac()
    self.vLayout3.addWidget(self.cbarsLineColorGroup)
    self.hLayout15 = QtWidgets.QHBoxLayout(self.cbarsLineColorGroup)
    self.hLayout15.setContentsMargins(0, 0, 0, 0)
    self.hLayout15.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsLineColorLabel = QtWidgets.QLabel('Color')
    self.cbarsLineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsLineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout15.addWidget(self.cbarsLineColorLabel)
      
    self.cbarsLineColorButton = QPushButtonMac()
    self.cbarsLineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['cbars']['color'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.cbarsLineColorButton.setStyleSheet(colorstr)
    self.cbarsLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cbarsLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cbarsLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.cbarsLineColorButton.clicked.connect(partial(self.setColor, self.target, 'cbars', 'color'))
    self.hLayout15.addWidget(self.cbarsLineColorButton)
      
    # line style
    self.cbarsLineStyleGroup = QWidgetMac()
    self.vLayout3.addWidget(self.cbarsLineStyleGroup)
    self.hLayout16 = QtWidgets.QHBoxLayout(self.cbarsLineStyleGroup)
    self.hLayout16.setContentsMargins(0, 0, 0, 0)
    self.hLayout16.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsLineStyleLabel = QtWidgets.QLabel('Style')
    self.cbarsLineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsLineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout16.addWidget(self.cbarsLineStyleLabel)
    self.cbarsComboStyle = QComboBoxMac()
    for entry in self.linestyles:
      self.cbarsComboStyle.addItem(entry)
    if(self.style['cbars']['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['cbars']['linestyle'])
    else:
      currindex = 0
    self.cbarsComboStyle.setCurrentIndex(currindex)
    self.cbarsComboStyle.activated.connect(partial(self.selectStyle, self.target, 'cbars', 'linestyle', self.cbarsComboStyle))
    self.cbarsComboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cbarsComboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout16.addWidget(self.cbarsComboStyle)

    # cap style
    self.cbarsLineDashStyleGroup = QWidgetMac()
    self.vLayout3.addWidget(self.cbarsLineDashStyleGroup)
    self.hLayout17 = QtWidgets.QHBoxLayout(self.cbarsLineDashStyleGroup)
    self.hLayout17.setContentsMargins(0, 0, 0, 0)
    self.hLayout17.setAlignment(QtCore.Qt.AlignLeft)
    self.cbarsLineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.cbarsLineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cbarsLineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout17.addWidget(self.cbarsLineDashStyleLabel)
    self.cbarsComboDashStyle = QComboBoxMac()
    for entry in self.dashstyles:
      self.cbarsComboDashStyle.addItem(entry)
    if(self.style['cbars']['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['cbars']['capstyle'])
    else:
      currindex = 0
    self.cbarsComboDashStyle.setCurrentIndex(currindex)
    self.cbarsComboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'cbars', 'capstyle', self.cbarsComboDashStyle))
    self.cbarsComboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cbarsComboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout17.addWidget(self.cbarsComboDashStyle)

    # cmeans
    blah = self.VLine()
    self.hLayout.addWidget(blah)

    self.cmeansContainer = QWidgetMac(self)
    self.hLayout.addWidget(self.cmeansContainer)
    self.vLayout4 = QtWidgets.QVBoxLayout(self.cmeansContainer)
    self.vLayout4.setContentsMargins(0, 0, 0, 0)
    self.vLayout4.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout4.setSpacing(scaledDPI(2))
      
    self.displayCmeansGroup = QWidgetMac()
    self.vLayout4.addWidget(self.displayCmeansGroup)
    self.hLayout18 = QtWidgets.QHBoxLayout(self.displayCmeansGroup)
    self.hLayout18.setContentsMargins(0, 0, 0, 0)
    self.hLayout18.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansStyleLabel = QtWidgets.QLabel()
    # for time being control mean and median lines jointly
    self.cmeansStyleLabel.setText('Mean/Median')
    font = self.cmeansStyleLabel.font()
    font.setBold(True)
    self.cmeansStyleLabel.setFont(font)
    self.hLayout18.addWidget(self.cmeansStyleLabel)    
    
    # display mean/median?
    self.displayCmeansCheck = QPushButtonCheckable()
    self.displayCmeansCheck.setText('S?')
    self.displayCmeansCheck.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmeansCheck.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmeansCheck.setChecked(self.style['cmeans']['visible'])
    self.displayCmeansCheck.clicked.connect(partial(self.setDisplay, self.target, 'cmeans', self.displayCmeansCheck))
    self.hLayout18.addWidget(self.displayCmeansCheck)
    self.displayCmeansCheck2 = QPushButtonCheckable()
    self.displayCmeansCheck2.setText('S?')
    self.displayCmeansCheck2.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmeansCheck2.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.displayCmeansCheck2.setChecked(self.style['cmedians']['visible'])
    self.displayCmeansCheck2.clicked.connect(partial(self.setDisplay, self.target, 'cmedians', self.displayCmeansCheck2))
    self.hLayout18.addWidget(self.displayCmeansCheck2)
    
    # line width
    self.cmeansLineWidthGroup = QWidgetMac()
    self.vLayout4.addWidget(self.cmeansLineWidthGroup)
    self.hLayout19 = QtWidgets.QHBoxLayout(self.cmeansLineWidthGroup)
    self.hLayout19.setContentsMargins(0, 0, 0, 0)
    self.hLayout19.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansLineWidthLabel = QtWidgets.QLabel('Width')
    self.cmeansLineWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmeansLineWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout19.addWidget(self.cmeansLineWidthLabel)
    self.cmeansLineWidthEntry = QLineEditClick()
    self.cmeansLineWidthEntry.setText(str(self.style['cmeans']['linewidth']))
    self.cmeansLineWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.cmeansLineWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.cmeansLineWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'cmeans', 'linewidth', self.cmeansLineWidthEntry, 0.0, 100.0))
    self.cmeansLineWidthEntry.setValidator(self.validFloat)
    self.hLayout19.addWidget(self.cmeansLineWidthEntry)
    
    # line color
    self.cmeansLineColorGroup = QWidgetMac()
    self.vLayout4.addWidget(self.cmeansLineColorGroup)
    self.hLayout20 = QtWidgets.QHBoxLayout(self.cmeansLineColorGroup)
    self.hLayout20.setContentsMargins(0, 0, 0, 0)
    self.hLayout20.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansLineColorLabel = QtWidgets.QLabel('Color')
    self.cmeansLineColorLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmeansLineColorLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout20.addWidget(self.cmeansLineColorLabel)
      
    self.cmeansLineColorButton = QPushButtonMac()
    self.cmeansLineColorButton.setAutoFillBackground(False)
    colorvalue = [int(i*255.0) for i in self.style['cmeans']['color'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.cmeansLineColorButton.setStyleSheet(colorstr)
    self.cmeansLineColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cmeansLineColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.cmeansLineColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.cmeansLineColorButton.clicked.connect(partial(self.setColor, self.target, 'cmeans', 'color'))
    self.hLayout20.addWidget(self.cmeansLineColorButton)
      
    # line style
    self.cmeansLineStyleGroup = QWidgetMac()
    self.vLayout4.addWidget(self.cmeansLineStyleGroup)
    self.hLayout21 = QtWidgets.QHBoxLayout(self.cmeansLineStyleGroup)
    self.hLayout21.setContentsMargins(0, 0, 0, 0)
    self.hLayout21.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansLineStyleLabel = QtWidgets.QLabel('Style')
    self.cmeansLineStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmeansLineStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout21.addWidget(self.cmeansLineStyleLabel)
    self.cmeansComboStyle = QComboBoxMac()
    for entry in self.linestyles:
      self.cmeansComboStyle.addItem(entry)
    if(self.style['cmeans']['linestyle'] in self.linestyles):
      currindex = self.linestyles.index(self.style['cmeans']['linestyle'])
    else:
      currindex = 0
    self.cmeansComboStyle.setCurrentIndex(currindex)
    self.cmeansComboStyle.activated.connect(partial(self.selectStyle, self.target, 'cmeans', 'linestyle', self.cmeansComboStyle))
    self.cmeansComboStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cmeansComboStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout21.addWidget(self.cmeansComboStyle)

    # cap style
    self.cmeansLineDashStyleGroup = QWidgetMac()
    self.vLayout4.addWidget(self.cmeansLineDashStyleGroup)
    self.hLayout22 = QtWidgets.QHBoxLayout(self.cmeansLineDashStyleGroup)
    self.hLayout22.setContentsMargins(0, 0, 0, 0)
    self.hLayout22.setAlignment(QtCore.Qt.AlignLeft)
    self.cmeansLineDashStyleLabel = QtWidgets.QLabel('Cap')
    self.cmeansLineDashStyleLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.cmeansLineDashStyleLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.hLayout22.addWidget(self.cmeansLineDashStyleLabel)
    self.cmeansComboDashStyle = QComboBoxMac()
    for entry in self.dashstyles:
      self.cmeansComboDashStyle.addItem(entry)
    if(self.style['cmeans']['capstyle'] in self.dashstyles):
      currindex = self.dashstyles.index(self.style['cmeans']['capstyle'])
    else:
      currindex = 0
    self.cmeansComboDashStyle.setCurrentIndex(currindex)
    self.cmeansComboDashStyle.activated.connect(partial(self.selectStyle, self.target, 'cmeans', 'capstyle', self.cmeansComboDashStyle))
    self.cmeansComboDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.cmeansComboDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
    self.hLayout22.addWidget(self.cmeansComboDashStyle)

  def changeStyle(self, target=None, subtarget=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def setDisplay(self, target=None, subtarget=None, entryfield=None):
    if(target != None):
      value = entryfield.isChecked()
      target.setViolinStyle(subtarget, 'visible', value, redraw=True)

  def selectStyle(self, target=None, subtarget=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key == 'hatchMultiply'):
        value = int(value)
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def setColor(self, target=None, subtarget=None, key=None):
    if((target != None) and (key != None)):
      # get current color
      if((subtarget != None) and (key in self.style[subtarget])):
        prevColor = [255*i for i in self.style[subtarget][key]]
        prevColor = QtGui.QColor(*prevColor)
      elif (key in self.style):
        prevColor = [255*i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]

        target.setViolinStyle(subtarget, key, value, redraw=True)

  def toggleBodyFill(self, target=None, entryfield=None):
    # toggles whether to fill violin bodies or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['bodies']['doFill'] = value
      target.toggleViolinBodyFill(value, redraw=True)

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

class boxStyleMenu(QWidgetMac):
  def __init__(self, parent=None, target=None):
    super(boxStyleMenu, self).__init__(parent)
    self.parent = parent
    self.target = target

    # float validator
    self.validFloat = MyValidFloat()

    # valid line styles
    self.linestyles = ['None', '-', '--', '-.', ':']
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.hatchstyles = ['None', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*'] # unfortunately none is not interpreted correctly
    self.hatchstyles = ['', '/', '|', '-', '+', 'x', 'o', 'O', '.', '*']
    self.hatchMultiplystyles = [str(i) for i in range(1, 11)]

    self.markerstyles = []
    self.markerstyles.extend(matplotlib.lines.Line2D.markers)
    # weed out duplicate blank items
    blankItems = [i for i in self.markerstyles if i in ['', ' ', 'None', None]]
    while (len(blankItems) - 1):
      killItem = blankItems[-1]
      self.markerstyles = [i for i in self.markerstyles if i != killItem]
      blankItems = blankItems[:-1]
    # had to remove a couple of styles as fliers crash otherwise
    self.orderedstyles = ['.', ',', 'o', 'v', '^', '<', '>', '1', '2', '3', '4', '8', 's', 'p', '*', 'h', 'H', '+',\
                          'x', 'D', 'd', '|', '_', 'P', 'X', 1, 2, 3, 4, 8, 'None', None, ' ', '']
    self.orderedstyles = [i for i in self.orderedstyles if (i in self.markerstyles)]

    self.fillstyles = [i for i in matplotlib.lines.Line2D.fillStyles if not i in ['', 'none', 'None', None]]
    
    # set up initial values
    self.style = {}
    if (self.target != None):
      getStyle = self.target.getViolinStyle()

      # have to make a copy to not directly alter the original object
      for entry in getStyle:
        if(type(getStyle[entry]) == type({})):
          # have to deepcopy inner dicts to prevent inadvertent overwriting of values
          self.style[entry] = deepcopy(getStyle[entry])
        else:
          self.style[entry] = getStyle[entry]
    
    # set default values
    defaultStyle = {}

    defaultStyle['boxes'] = {'linestyle': 'solid', 'linewidth': 1.0, 'color': [0.2, 0.2, 0.2, 1.0], 'dash_capstyle': 'butt', 'visible': True}
    for slaved in ['whiskers', 'medians', 'caps']:
      defaultStyle[slaved] = {}
      defaultStyle[slaved].update(defaultStyle['boxes'])
    defaultStyle['boxes'].update({'edgecolor': [0.2, 0.2, 0.2, 1.0], 'width': 0.5, 'boxFill': True, 'facecolor': [0.8, 0.8, 0.9, 0.0], 'hatch': '', 'hatchMultiply': 1})
    # only used this key temporarily for slaving whiskers etc.
    del defaultStyle['boxes']['color']
    for entry in defaultStyle:
      if(not (entry in self.style)):
        self.style[entry] = defaultStyle[entry]
    defaultStyle['fliers'] = {'visible': True, 'marker': 'o', 'markerfacecolor': [0.89, 0.29, 0.2, 1.0], 'markerfacecoloralt': [0.0, 0.0, 0.0, 1.0],\
                'markeredgecolor': [0.0, 0.0, 0.0, 1.0], 'markeredgewidth': 0.5, 'markersize': 10.0, 'fillstyle': 'full'}

    # set up GUI
    self.buildRessource()
    
  def buildRessource(self):
    # build gui
    self.hLayout = QtWidgets.QHBoxLayout(self)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.hLayout.setSpacing(scaledDPI(2))
    
    self.hLayouts, self.vLayouts = [], []
    self.generalContainers, self.generalLabels, self.generalGroups = [], [], []
    self.displayChecks, self.lineWidthEntries, self.lineColorButtons, self.lineStyleCombos, self.lineCapCombos = [], [], [], [], []
    items, labels = ['boxes', 'whiskers', 'caps', 'medians'], ['Boxes', 'Whisk.', 'Caps', 'Median']
    for i, j in zip(items, labels):
      # header
      self.generalContainers.append(QWidgetMac(self))
      self.hLayout.addWidget(self.generalContainers[-1])
      self.vLayouts.append(QtWidgets.QVBoxLayout(self.generalContainers[-1]))
      self.vLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.vLayouts[-1].setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
      self.vLayouts[-1].setSpacing(scaledDPI(2))
        
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
      self.generalLabels.append(QtWidgets.QLabel())
      self.generalLabels[-1].setText(j)
      font = self.generalLabels[-1].font()
      font.setBold(True)
      self.generalLabels[-1].setFont(font)
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])    

      # display group
      self.displayChecks.append(QPushButtonCheckable())
      self.displayChecks[-1].setText('Show?')
      self.displayChecks[-1].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.displayChecks[-1].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.displayChecks[-1].setChecked(self.style[i]['visible'])
      self.displayChecks[-1].clicked.connect(partial(self.setDisplay, self.target, i, self.displayChecks[-1]))
      self.hLayouts[-1].addWidget(self.displayChecks[-1])
      
      # line width group
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

      self.generalLabels.append(QtWidgets.QLabel('Width'))
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])

      self.lineWidthEntries.append(QLineEditClick())
      self.lineWidthEntries[-1].setText(str(self.style[i]['linewidth']))
      self.lineWidthEntries[-1].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.lineWidthEntries[-1].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.lineWidthEntries[-1].editingFinished.connect(partial(self.changeStyle, self.target, i, 'linewidth', self.lineWidthEntries[-1], 0.0, 100.0))
      self.lineWidthEntries[-1].setValidator(self.validFloat)
      self.hLayouts[-1].addWidget(self.lineWidthEntries[-1])
    
      # line color group
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
      self.generalLabels.append(QtWidgets.QLabel('Color'))
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])

      self.lineColorButtons.append(QPushButtonMac())
      self.lineColorButtons[-1].setAutoFillBackground(False)
      if(i == 'boxes'):
        colorvalue = [int(i * 255.0) for i in self.style[i]['edgecolor'][0:3]]
      else:
        colorvalue = [int(i * 255.0) for i in self.style[i]['color'][0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.lineColorButtons[-1].setStyleSheet(colorstr)
      self.lineColorButtons[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.lineColorButtons[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.lineColorButtons[-1].setCursor(QtCore.Qt.PointingHandCursor)
      if(i == 'boxes'):
        self.lineColorButtons[-1].clicked.connect(partial(self.setColor, self.target, i, 'edgecolor'))
      else:
        self.lineColorButtons[-1].clicked.connect(partial(self.setColor, self.target, i, 'color'))
      self.hLayouts[-1].addWidget(self.lineColorButtons[-1])

      # line styles group
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

      self.generalLabels.append(QtWidgets.QLabel('Style'))
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])

      self.lineStyleCombos.append(QComboBoxMac())
      for entry in self.linestyles:
        self.lineStyleCombos[-1].addItem(entry)
      if(self.style[i]['linestyle'] in self.linestyles):
        currindex = self.linestyles.index(self.style[i]['linestyle'])
      else:
        currindex = 0
      self.lineStyleCombos[-1].setCurrentIndex(currindex)
      self.lineStyleCombos[-1].activated.connect(partial(self.selectStyle, self.target, i, 'linestyle', self.lineStyleCombos[-1]))
      self.lineStyleCombos[-1].setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.lineStyleCombos[-1].setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.lineStyleCombos[-1])

      # cap styles group
      self.generalGroups.append(QWidgetMac())
      self.vLayouts[-1].addWidget(self.generalGroups[-1])
      self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
      self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
      self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

      self.generalLabels.append(QtWidgets.QLabel('Cap'))
      self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.generalLabels[-1])

      self.lineCapCombos.append(QComboBoxMac())
      for entry in self.dashstyles:
        self.lineCapCombos[-1].addItem(entry)
      if(self.style[i]['dash_capstyle'] in self.dashstyles):
        currindex = self.dashstyles.index(self.style[i]['dash_capstyle'])
      else:
        currindex = 0
      self.lineCapCombos[-1].setCurrentIndex(currindex)
      self.lineCapCombos[-1].activated.connect(partial(self.selectStyle, self.target, i, 'dash_capstyle', self.lineCapCombos[-1]))
      self.lineCapCombos[-1].setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.lineCapCombos[-1].setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.hLayouts[-1].addWidget(self.lineCapCombos[-1])
      
      # extra options for boxes
      if(i == 'boxes'):
        # fill color group
        self.generalGroups.append(QWidgetMac())
        self.vLayouts[-1].addWidget(self.generalGroups[-1])
        self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
        self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
        self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
        self.generalLabels.append(QPushButtonCheckable())
        self.generalLabels[-1].setText('Fill')
        self.generalLabels[-1].setChecked(self.style[i]['boxFill'])
        self.generalLabels[-1].clicked.connect(partial(self.toggleBoxFill, self.target, self.generalLabels[-1]))
        self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.generalLabels[-1])
        
        self.lineColorButtons.append(QPushButtonMac())
        self.lineColorButtons[-1].setAutoFillBackground(False)
        colorvalue = [int(i * 255.0) for i in self.style[i]['facecolor'][0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.lineColorButtons[-1].setStyleSheet(colorstr)
        self.lineColorButtons[-1].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.lineColorButtons[-1].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.lineColorButtons[-1].setCursor(QtCore.Qt.PointingHandCursor)
        self.lineColorButtons[-1].clicked.connect(partial(self.setColor, self.target, i, 'facecolor'))
        self.hLayouts[-1].addWidget(self.lineColorButtons[-1])

        # hatch group
        self.generalGroups.append(QWidgetMac())
        self.vLayouts[-1].addWidget(self.generalGroups[-1])
        self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
        self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
        self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
  
        self.generalLabels.append(QtWidgets.QLabel('Hatch'))
        self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.generalLabels[-1])

        self.boxesComboHatchStyle = QComboBoxMac()
        for entry in self.hatchstyles:
          self.boxesComboHatchStyle.addItem(entry)
        if(self.style['boxes']['hatch'] in self.hatchstyles):
          currindex = self.hatchstyles.index(self.style['boxes']['hatch'])
        else:
          currindex = 0
        self.boxesComboHatchStyle.setCurrentIndex(currindex)
        self.boxesComboHatchStyle.activated.connect(partial(self.selectStyle, self.target, 'boxes', 'hatch', self.boxesComboHatchStyle))
        self.boxesComboHatchStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.boxesComboHatchStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.boxesComboHatchStyle)
        self.boxesComboHatchMultiplyStyle = QComboBoxMac()
        for entry in self.hatchMultiplystyles:
          self.boxesComboHatchMultiplyStyle.addItem(str(entry))
        if(str(self.style['boxes']['hatchMultiply']) in self.hatchMultiplystyles):
          currindex = self.hatchMultiplystyles.index(str(self.style['boxes']['hatchMultiply']))
        else:
          currindex = 0
        self.boxesComboHatchMultiplyStyle.setCurrentIndex(currindex)
        self.boxesComboHatchMultiplyStyle.activated.connect(partial(self.selectStyle, self.target, 'boxes', 'hatchMultiply', self.boxesComboHatchMultiplyStyle))
        self.boxesComboHatchMultiplyStyle.setMaximumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.boxesComboHatchMultiplyStyle.setMinimumSize(QtCore.QSize(scaledDPI(31), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.boxesComboHatchMultiplyStyle)

        # body width group
        self.generalGroups.append(QWidgetMac())
        self.vLayouts[-1].addWidget(self.generalGroups[-1])
        self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
        self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
        self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
  
        self.generalLabels.append(QtWidgets.QLabel('BWid'))
        self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.hLayouts[-1].addWidget(self.generalLabels[-1])
        
        self.boxesWidthEntry = QLineEditClick()
        self.boxesWidthEntry.setText(str(self.style['boxes']['width']))
        self.boxesWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.boxesWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.boxesWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, 'boxes', 'width', self.boxesWidthEntry, 0.0, 100.0))
        self.boxesWidthEntry.setValidator(self.validFloat)
        self.hLayouts[-1].addWidget(self.boxesWidthEntry)

      # add a spacing line
      blah = self.VLine()
      self.hLayout.addWidget(blah)

    # now put config of outliers
    i, j = 'fliers', 'Outliers'
    # header
    self.generalContainers.append(QWidgetMac(self))
    self.hLayout.addWidget(self.generalContainers[-1])
    self.vLayouts.append(QtWidgets.QVBoxLayout(self.generalContainers[-1]))
    self.vLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.vLayouts[-1].setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayouts[-1].setSpacing(scaledDPI(2))
      
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)
    self.generalLabels.append(QtWidgets.QLabel())
    self.generalLabels[-1].setText(j)
    font = self.generalLabels[-1].font()
    font.setBold(True)
    self.generalLabels[-1].setFont(font)
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])    

    # display group
    self.displayChecks.append(QPushButtonCheckable())
    self.displayChecks[-1].setText('Show?')
    self.displayChecks[-1].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displayChecks[-1].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.displayChecks[-1].setChecked(self.style[i]['visible'])
    self.displayChecks[-1].clicked.connect(partial(self.setDisplay, self.target, i, self.displayChecks[-1]))
    self.hLayouts[-1].addWidget(self.displayChecks[-1])
      
    # marker size group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QtWidgets.QLabel('Size'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.markerSizeEntry = QLineEditClick()
    self.markerSizeEntry.setText(str(self.style[i]['markersize']))
    self.markerSizeEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerSizeEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerSizeEntry.editingFinished.connect(partial(self.changeStyle, self.target, i, 'markersize', self.markerSizeEntry, 0.0, 100.0))
    self.markerSizeEntry.setValidator(self.validFloat)
    self.hLayouts[-1].addWidget(self.markerSizeEntry)

    # marker color group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QPushButtonCheckable())
    self.generalLabels[-1].setText('Face')
    self.generalLabels[-1].setChecked(self.style[i]['doFill'])
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].clicked.connect(partial(self.toggleFliersMarkerFill, self.target, self.generalLabels[-1]))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.markerFaceColorButton = QPushButtonMac()
    self.markerFaceColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style[i]['markerfacecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerFaceColorButton.setStyleSheet(colorstr)
    self.markerFaceColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerFaceColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerFaceColorButton.clicked.connect(partial(self.setColor, self.target, i, key='markerfacecolor'))
    self.hLayouts[-1].addWidget(self.markerFaceColorButton)

    self.generalLabels.append(QtWidgets.QLabel('Edge'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(34), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.markerEdgeColorButton = QPushButtonMac()
    self.markerEdgeColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style[i]['markeredgecolor'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerEdgeColorButton.setStyleSheet(colorstr)
    self.markerEdgeColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerEdgeColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerEdgeColorButton.clicked.connect(partial(self.setColor, self.target, i, key='markeredgecolor'))
    self.hLayouts[-1].addWidget(self.markerEdgeColorButton)

    # marker edge width group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QtWidgets.QLabel('Edgewidth'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.markerEdgeWidthEntry = QLineEditClick()
    self.markerEdgeWidthEntry.setText(str(self.style[i]['markeredgewidth']))
    self.markerEdgeWidthEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.markerEdgeWidthEntry.editingFinished.connect(partial(self.changeStyle, self.target, i, 'markeredgewidth', self.markerEdgeWidthEntry, 0.0, 100.0))
    self.markerEdgeWidthEntry.setValidator(self.validFloat)
    self.hLayouts[-1].addWidget(self.markerEdgeWidthEntry)

    # marker style group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QtWidgets.QLabel('Style'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.comboStyle = QComboBoxMac()
    for entry in self.orderedstyles:
      self.comboStyle.addItem(str(entry))
    if(self.style[i]['marker'] in self.orderedstyles):
      currindex = self.orderedstyles.index(self.style[i]['marker'])
    else:
      currindex = 0
    self.comboStyle.setCurrentIndex(currindex)
    self.comboStyle.activated.connect(partial(self.selectStyle, self.target, i, 'marker', self.comboStyle))
    self.comboStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.comboStyle)    

    # marker fillstyle group
    self.generalGroups.append(QWidgetMac())
    self.vLayouts[-1].addWidget(self.generalGroups[-1])
    self.hLayouts.append(QtWidgets.QHBoxLayout(self.generalGroups[-1]))
    self.hLayouts[-1].setContentsMargins(0, 0, 0, 0)
    self.hLayouts[-1].setAlignment(QtCore.Qt.AlignLeft)

    self.generalLabels.append(QtWidgets.QLabel('Fillstyle'))
    self.generalLabels[-1].setMaximumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.generalLabels[-1].setMinimumSize(QtCore.QSize(scaledDPI(56), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.generalLabels[-1])
    self.comboFillStyle = QComboBoxMac()
    for entry in self.fillstyles:
      self.comboFillStyle.addItem(str(entry))
    if(self.style[i]['fillstyle'] in self.fillstyles):
      currindex = self.fillstyles.index(self.style[i]['fillstyle'])
    else:
      currindex = 0
    self.comboFillStyle.setCurrentIndex(currindex)
    self.comboFillStyle.activated.connect(partial(self.selectStyle, self.target, i, 'fillstyle', self.comboFillStyle))
    self.comboFillStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.comboFillStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.hLayouts[-1].addWidget(self.comboFillStyle)

    self.markerAltColorButton = QPushButtonMac()
    self.markerAltColorButton.setAutoFillBackground(False)
    colorvalue = [int(i * 255.0) for i in self.style[i]['markerfacecoloralt'][0:3]]
    colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
    self.markerAltColorButton.setStyleSheet(colorstr)
    self.markerAltColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.markerAltColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.markerAltColorButton.clicked.connect(partial(self.setColor, self.target, i, 'markerfacecoloralt'))
    self.hLayouts[-1].addWidget(self.markerAltColorButton)

  def changeStyle(self, target=None, subtarget=None, key=None, entryfield=None, minval=0, maxval=1):
    if((target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def toggleBoxFill(self, target=None, entryfield=None):
    if(target != None):
      value = entryfield.isChecked()
      target.setViolinStyle('boxes', 'boxFill', value, redraw=True)

  def setDisplay(self, target=None, subtarget=None, entryfield=None):
    if(target != None):
      value = entryfield.isChecked()
      target.setViolinStyle(subtarget, 'visible', value, redraw=True)

  def selectStyle(self, target=None, subtarget=None, key=None, entryfield=None):
    if((target != None) and (key != None)):
      value = str(entryfield.currentText())
      if(key == 'hatchMultiply'):
        value = int(value)
      if((subtarget != None) and (key in self.style[subtarget])):
        self.style[subtarget][key] = value
      elif(key in self.style):
        self.style[key] = value

      target.setViolinStyle(subtarget, key, value, redraw=True)

  def setColor(self, target=None, subtarget=None, key=None):
    if((target != None) and (key != None)):
      # get current color
      if((subtarget != None) and (key in self.style[subtarget])):
        prevColor = [255 * i for i in self.style[subtarget][key]]
        prevColor = QtGui.QColor(*prevColor)
      elif (key in self.style):
        prevColor = [255 * i for i in self.style[key]]
        prevColor = QtGui.QColor(*prevColor)
      else:
        prevColor = QtCore.Qt.black
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]

        target.setViolinStyle(subtarget, key, value, redraw=True)

  def toggleFliersMarkerFill(self, target=None, entryfield=None):
    # toggles whether to fill fliers markers or not
    if(target != None):
      value = entryfield.isChecked()
      self.style['fliers']['doFill'] = value
      target.toggleFliersMarkerFill(value, redraw=True)

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

class ConfigMenu(KuhMenu):
  def __init__(self, parent = None, target = None, residMode = False, residZero = False, displayName=False):
    super(ConfigMenu, self).__init__()
    self.parent = parent
    self.target = target
    self.residMode = residMode
    self.residZero = residZero
    self.displayName = displayName
    
    self.validFloat = MyValidFloat()
    
    # initialize drag values
    self.startPos = None
      
    # set up GUI
    self.buildRessource()

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(self.underMouse()):
      if(self.displayName and (event.button() == QtCore.Qt.LeftButton)):
        self.startPos = event.globalPos()
    else:
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def mouseMoveEvent(self, event):
    if((event.buttons() == QtCore.Qt.LeftButton) and (self.startPos != None)):
      currentPos = event.globalPos()
      menuPos = self.mapToGlobal(self.pos()) + (currentPos - self.startPos)
      menuPos = self.mapFromGlobal(menuPos)
      self.move(menuPos)
      self.startPos = currentPos
    
  def mouseReleaseEvent(self, event):
    # turn off tracking
    if(event.button() == QtCore.Qt.LeftButton):
      self.startPos = None

  def buildRessource(self):
    # build gui
    self.vLayout = QtWidgets.QVBoxLayout(self)
    self.vLayout.setContentsMargins(*[scaledDPI(4)]*4)
    
    # display name of item?
    if(self.displayName):
      self.topContainer = QWidgetMac(self)
      self.vLayout.addWidget(self.topContainer)
      self.LayoutTopContainer = QtWidgets.QHBoxLayout(self.topContainer)
      self.LayoutTopContainer.setContentsMargins(0, 0, 0, 0)

      if(self.target in self.parent.parent.data):
        index = self.parent.parent.data.index(self.target)
        if(self.residMode):
          leader = 'Resid ' + str(index)
        else:
          leader = 'Data ' + str(index)
      elif(self.target in self.parent.parent.fit):
        index = self.parent.parent.fit.index(self.target)
        leader = 'Curve ' + str(index)
      elif(self.residZero):
        index = 0
        leader = 'Zero Line'
      else:
        leader = 'unknown'
      self.targetLabel = QtWidgets.QLabel()
      self.targetLabel.setText(leader)
      font = self.targetLabel.font()
      font.setBold(True)
      self.targetLabel.setFont(font)
      self.LayoutTopContainer.addWidget(self.targetLabel)
      # create entry field to edit name
      if(self.residMode and (hasattr(self.target, 'nameResid'))):
        name = self.target.nameResid
      elif(hasattr(self.target, 'name')):
        name = self.target.name
      else:
        name = None
      
      if(name != None):
        self.entryField = QLineEditClick(name)
        self.entryField.setAlignment(QtCore.Qt.AlignLeft)
        self.entryField.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.entryField.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.entryField.editingFinished.connect(partial(self.setField, leader, index))
        self.LayoutTopContainer.addWidget(self.entryField)
     
      # put controls for altering active item
      self.LayoutTopContainer.addStretch()
      if(leader.startswith('Data') or leader.startswith('Curve')):
        self.activeButton = QPushButtonCheckable()
        self.activeButton.setText('active')
        self.activeButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.activeButton.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        # check whether item is already active
        if((leader.startswith('Data') and (index == self.parent.parent.activeData)) or \
           (leader.startswith('Curve') and (index == self.parent.parent.activeFit))):
          self.activeButton.setChecked(True)
          self.activeButton.setEnabled(False)
        self.activeButton.clicked.connect(partial(self.makeActive, leader, index))
        self.LayoutTopContainer.addWidget(self.activeButton)
      
      # put controls for altering z position
      self.zLabel = QtWidgets.QLabel('z')
      self.LayoutTopContainer.addWidget(self.zLabel)

      self.innerContainer = QWidgetMac(self)
      self.LayoutTopContainer.addWidget(self.innerContainer)
      self.LayoutInnerContainer = QtWidgets.QHBoxLayout(self.innerContainer)
      self.LayoutInnerContainer.setContentsMargins(0, 0, 0, 0)
      self.LayoutInnerContainer.setSpacing(0)

      self.zDownButton = QPushButtonMac()
      self.zDownButton.setText('\u25be')
      self.zDownButton.setAutoRepeat(True)
      self.zDownButton.setMaximumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zDownButton.setMinimumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zDownButton.clicked.connect(partial(self.alterZ, leader, index, -1))
      self.LayoutInnerContainer.addWidget(self.zDownButton)

      self.zUpButton = QPushButtonMac()
      self.zUpButton.setText('\u25b4')
      self.zUpButton.setAutoRepeat(True)
      self.zUpButton.setMaximumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zUpButton.setMinimumSize(QtCore.QSize(scaledDPI(15), scaledDPI(BASE_SIZE)))
      self.zUpButton.clicked.connect(partial(self.alterZ, leader, index, 1))
      self.LayoutInnerContainer.addWidget(self.zUpButton)

      # call alterZ to initiate button disabling
      self.alterZ(leader, index, 0)
     
      blah = self.HLine()
      self.vLayout.addWidget(blah)

    self.upperRow = QWidgetMac()
    
    # populate menu with items
    # set up line style configurator
    if(self.target in self.parent.parent.data + self.parent.parent.fit):
      # generate top row
      self.displayLineButton = QPushButtonCheckable()
      self.displayLineButton.setText('Configure Line and Marker \u25be')
      self.displayLineButton.setChecked(self.parent.displayLineConfig)
      self.vLayout.addWidget(self.displayLineButton)
      self.vLayout.addWidget(self.upperRow)

      self.displayLineButton.clicked.connect(partial(self.toggleDisplay, self.displayLineButton, self.upperRow, 'displayLineConfig'))
      self.toggleDisplay(button=self.displayLineButton, target=self.upperRow, flag='displayLineConfig')
    else:
      self.vLayout.addWidget(self.upperRow)
      
    self.hLayout = QtWidgets.QHBoxLayout(self.upperRow)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.lineStyleMenu = lineStyleMenu(self, self.target, self.residMode, self.residZero)
    self.hLayout.addWidget(self.lineStyleMenu)
    
    if(not self.residZero):
      # set up marker style configurator
      self.hLayout.addWidget(self.VLine())
      self.markerStyleMenu = markerStyleMenu(self, self.target, self.residMode)
      self.hLayout.addWidget(self.markerStyleMenu)
      self.hLayout.addStretch()

    if(self.target in self.parent.parent.data):
      # generate lower row
      self.displayBarButton = QPushButtonCheckable()
      self.displayBarButton.setText('Configure Bar and Stack \u25be')
      self.displayBarButton.setChecked(self.parent.displayBarConfig)
      self.vLayout.addWidget(self.displayBarButton)

      self.lowerRow = QWidgetMac()
      self.vLayout.addWidget(self.lowerRow)
      self.hLayout2 = QtWidgets.QHBoxLayout(self.lowerRow)
      self.hLayout2.setContentsMargins(0, 0, 0, 0)
      self.displayBarButton.clicked.connect(partial(self.toggleDisplay, self.displayBarButton, self.lowerRow, 'displayBarConfig'))
      self.toggleDisplay(button=self.displayBarButton, target=self.lowerRow, flag='displayBarConfig')
      
      # set up bar style configurator
      self.barStyleMenu = barStyleMenu(self, self.target, self.residMode)
      self.hLayout2.addWidget(self.barStyleMenu)
  
      # set up stack style configurator
      self.hLayout2.addWidget(self.VLine())
      self.stackStyleMenu = stackStyleMenu(self, self.target, self.residMode)
      self.hLayout2.addWidget(self.stackStyleMenu)
      self.hLayout2.addStretch()
    
      if(not self.residMode):
        # set up errorbar configurator
        self.displayErrorButton = QPushButtonCheckable()
        self.displayErrorButton.setText('Configure Error Bar \u25be')
        self.displayErrorButton.setChecked(self.parent.displayErrorConfig)
        self.vLayout.addWidget(self.displayErrorButton)

        self.lowestRow = QWidgetMac()
        self.vLayout.addWidget(self.lowestRow)
        self.hLayout3 = QtWidgets.QHBoxLayout(self.lowestRow)
        self.hLayout3.setContentsMargins(0, 0, 0, 0)
        self.displayErrorButton.clicked.connect(partial(self.toggleDisplay, self.displayErrorButton, self.lowestRow, 'displayErrorConfig'))
        self.toggleDisplay(button=self.displayErrorButton, target=self.lowestRow, flag='displayErrorConfig')

        self.errorStyleMenu = errorStyleMenu(self, self.target, self.residMode)
        self.hLayout3.addWidget(self.errorStyleMenu)

      # set up violin and box plot configurator
      if(not self.residMode):
        self.displayViolinButton = QPushButtonCheckable()
        self.displayViolinButton.setText('Configure Violin and Box Plots \u25be')
        self.displayViolinButton.setChecked(self.parent.displayViolinConfig)
        self.vLayout.addWidget(self.displayViolinButton)

        self.violinRow = QWidgetMac()
        self.vLayout.addWidget(self.violinRow)
        self.hLayout5 = QtWidgets.QHBoxLayout(self.violinRow)
        self.hLayout5.setContentsMargins(0, 0, 0, 0)
        self.displayViolinButton.clicked.connect(partial(self.toggleDisplay, self.displayViolinButton, self.violinRow, 'displayViolinConfig'))
        self.toggleDisplay(button=self.displayViolinButton, target=self.violinRow, flag='displayViolinConfig')
        
        self.violinBoxMenu = violinBoxMenu(self, self.target)
        self.hLayout5.addWidget(self.violinBoxMenu)

      # generate lowest row
      self.displayTextButton = QPushButtonCheckable()
      self.displayTextButton.setText('Configure Text Labels \u25be')
      self.displayTextButton.setChecked(self.parent.displayTextConfig)
      self.vLayout.addWidget(self.displayTextButton)

      self.lowestRow2 = QWidgetMac()
      self.vLayout.addWidget(self.lowestRow2)
      self.hLayout4 = QtWidgets.QHBoxLayout(self.lowestRow2)
      self.hLayout4.setContentsMargins(0, 0, 0, 0)
      self.displayTextButton.clicked.connect(partial(self.toggleDisplay, self.displayTextButton, self.lowestRow2, 'displayTextConfig'))
      self.toggleDisplay(button=self.displayTextButton, target=self.lowestRow2, flag='displayTextConfig')
      
      # set up text style configurator
      self.textStyleMenu = textStyleMenu(self, self.target, self.residMode)
      self.hLayout4.addWidget(self.textStyleMenu)

      # put declustering control
      if(not self.residMode):
        index = self.parent.parent.data.index(self.target)
        self.displayDeclusterButton = QPushButtonCheckable()
        self.displayDeclusterButton.setText('Data Operations \u25be')
        self.displayDeclusterButton.setChecked(self.parent.displayDeclusterConfig)
        self.vLayout.addWidget(self.displayDeclusterButton)
  
        self.declusterRow = QWidgetMac()
        self.vLayout2 = QtWidgets.QVBoxLayout(self.declusterRow)
        self.vLayout2.setContentsMargins(0, 0, 0, 0)
        self.vLayout.addWidget(self.declusterRow)
        self.displayDeclusterButton.clicked.connect(partial(self.toggleDisplay, self.displayDeclusterButton, self.declusterRow, 'displayDeclusterConfig'))
        self.toggleDisplay(button=self.displayDeclusterButton, target=self.declusterRow, flag='displayDeclusterConfig')
  
        self.declusterInnerRow = QWidgetMac()
        self.vLayout2.addWidget(self.declusterInnerRow)
        self.hLayout5 = QtWidgets.QHBoxLayout(self.declusterInnerRow)
        self.hLayout5.setContentsMargins(0, 0, 0, 0)
        self.declusterButton = QPushButtonMac()
        self.declusterButton.setText('Decluster')
        self.declusterButton.setMaximumSize(QtCore.QSize(scaledDPI(72), scaledDPI(BASE_SIZE)))
        self.declusterButton.setMinimumSize(QtCore.QSize(scaledDPI(72), scaledDPI(BASE_SIZE)))
        self.declusterButton.clicked.connect(partial(self.declusterData, index))
        self.hLayout5.addWidget(self.declusterButton)
        
        self.declusterTolXLabel = QtWidgets.QLabel('Tol. ' + u'\N{GREEK CAPITAL LETTER DELTA}' + 'x')
        self.declusterTolXLabel.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.declusterTolXLabel.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        self.hLayout5.addWidget(self.declusterTolXLabel)
        self.declusterTolXEntry = QLineEditClick()
        self.declusterTolXEntry.setText(str(self.parent.declusterTolX))
        self.declusterTolXEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.declusterTolXEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.declusterTolXEntry.editingFinished.connect(partial(self.changeTol, self.declusterTolXEntry, 1e-9, 1e9))
        self.declusterTolXEntry.setValidator(self.validFloat)
        self.hLayout5.addWidget(self.declusterTolXEntry)
  
        self.declusterTolYLabel = QtWidgets.QLabel(u'\N{GREEK CAPITAL LETTER DELTA}' + 'y')
        self.declusterTolYLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
        self.declusterTolYLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
        self.hLayout5.addWidget(self.declusterTolYLabel)
        self.declusterTolYEntry = QLineEditClick()
        self.declusterTolYEntry.setText(str(self.parent.declusterTolY))
        self.declusterTolYEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.declusterTolYEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.declusterTolYEntry.editingFinished.connect(partial(self.changeTol, self.declusterTolYEntry, 1e-9, 1e9))
        self.declusterTolYEntry.setValidator(self.validFloat)
        self.hLayout5.addWidget(self.declusterTolYEntry)
        self.hLayout5.addStretch()
        
        self.guessDeclusterTol(index)

        blah = self.HLine()
        self.vLayout2.addWidget(blah)
        
        self.declusterInnerRow2 = QWidgetMac()
        self.vLayout2.addWidget(self.declusterInnerRow2)
        self.hLayout6 = QtWidgets.QHBoxLayout(self.declusterInnerRow2)
        self.hLayout6.setContentsMargins(0, 0, 0, 0)
        self.mergeButton = QPushButtonMac()
        self.mergeButton.setText('Merge with')
        self.mergeButton.setMaximumSize(QtCore.QSize(scaledDPI(72), scaledDPI(BASE_SIZE)))
        self.mergeButton.setMinimumSize(QtCore.QSize(scaledDPI(72), scaledDPI(BASE_SIZE)))
        self.mergeButton.clicked.connect(partial(self.mergeData, index))
        self.hLayout6.addWidget(self.mergeButton)
        
        self.dataSetSelector = QComboBoxMac()
        self.hLayout6.addWidget(self.dataSetSelector)
        self.dataSetSelector.setMaximumHeight(scaledDPI(BASE_SIZE))
        self.dataSetSelector.setMinimumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
        self.hLayout6.addStretch()
        
        self.updateDataSetSelector(targetIndex=index)

    # set plot interval configuration
    if(self.target in self.parent.parent.fit):
      # generate row
      self.displayIntervalButton = QPushButtonCheckable()
      self.displayIntervalButton.setText('Configure Plot Interval \u25be')
      self.displayIntervalButton.setChecked(self.parent.displayIntervalConfig)
      self.vLayout.addWidget(self.displayIntervalButton)

      self.intervalRow = QWidgetMac()
      self.vLayout.addWidget(self.intervalRow)
      self.hLayout6 = QtWidgets.QHBoxLayout(self.intervalRow)
      self.hLayout6.setContentsMargins(0, 0, 0, 0)

      self.displayIntervalButton.clicked.connect(partial(self.toggleDisplay, self.displayIntervalButton, self.intervalRow, 'displayIntervalConfig'))
      self.toggleDisplay(button=self.displayIntervalButton, target=self.intervalRow, flag='displayIntervalConfig')

      # controls for limiting plot interval
      restrictMe, restrictLow, restrictHigh = self.target.getRestricted()

      self.displayIntervalLabel = QPushButtonCheckable()
      self.displayIntervalLabel.setText('Limit plot?')
      self.displayIntervalLabel.setChecked(restrictMe)
      self.displayIntervalLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.displayIntervalLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.displayIntervalLabel.clicked.connect(self.toggleRestricted)
      self.hLayout6.addWidget(self.displayIntervalLabel)
    
      self.labelDisplayIntervalLow = QtWidgets.QLabel('min')
      self.labelDisplayIntervalLow.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.labelDisplayIntervalLow.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.hLayout6.addWidget(self.labelDisplayIntervalLow)
      self.entryDisplayIntervalLow = QLineEditClick()
      self.entryDisplayIntervalLow.setText(str(restrictLow))
      self.entryDisplayIntervalLow.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.entryDisplayIntervalLow.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.entryDisplayIntervalLow.editingFinished.connect(partial(self.changeRestricted, 'restrictLow', self.entryDisplayIntervalLow, None, None))
      self.hLayout6.addWidget(self.entryDisplayIntervalLow)

      self.labelDisplayIntervalHigh= QtWidgets.QLabel('max')
      self.labelDisplayIntervalHigh.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.labelDisplayIntervalHigh.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.hLayout6.addWidget(self.labelDisplayIntervalHigh)
      self.entryDisplayIntervalHigh = QLineEditClick()
      self.entryDisplayIntervalHigh.setText(str(restrictHigh))
      self.entryDisplayIntervalHigh.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.entryDisplayIntervalHigh.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.entryDisplayIntervalHigh.editingFinished.connect(partial(self.changeRestricted, 'restrictHigh', self.entryDisplayIntervalHigh, None, None))
      self.hLayout6.addWidget(self.entryDisplayIntervalHigh)
      self.hLayout6.addStretch()
  
      self.updateRestrictedFields(restrictMe)
      
    self.setFocus()    
    self.focusNextChild()

  def mergeData(self, targetIndex):
    # merges data of selected data set into current data set
    mergeIndex = self.dataSetSelector.currentText()
    mergeIndex = int(mergeIndex.split('-')[0]) - 1
    mergeData = self.parent.parent.data[mergeIndex].value()
    sourceData = self.parent.parent.data[targetIndex].value()
    sourceRoles, mergeRoles = list(sourceData.keys()), list(mergeData.keys())
    
    if(not len(mergeRoles)):
      self.parent.parent.statusbar.showMessage('Data set to be merged contains no data, won\'t merge!', self.parent.parent.STATUS_TIME)
    else:
      if(not len(sourceRoles)):
        # okay, this is easy -- source data set is empty just copy the merge data
        combinedData = mergeData
      else:
        allRoles = list(set(sourceRoles + mergeRoles))
        # expand data sets prior to merger?
        defaultValues = {'xerr': 0.0, 'yerr': 0.0, 'labels': '', 'fval': 0.0, 'resid': 0.0, 'x': 0.0, 'y': 0.0}
        missingRoles = [i for i in allRoles if (not i in sourceRoles)]
        # expand source data set by needed columns
        length = len(sourceData[sourceRoles[0]])
        for entry in missingRoles:
          sourceData[entry] = [defaultValues[entry] for i in range(length)]
        # now append merge data set
        length = len(mergeData[mergeRoles[0]])
        for entry in sourceData:
          if(entry in mergeData):
            sourceData[entry] = np.hstack((sourceData[entry], mergeData[entry]))
          else:
            sourceData[entry] = np.hstack((sourceData[entry], np.array([defaultValues[entry] for i in range(length)])))
        combinedData = sourceData
        
      # now generate a new data set for the merged data
      newData, newRoles = [], []
      for key in combinedData:
        newRoles.append(key)
        if(len(newData)):
          newData = np.vstack((newData, combinedData[key]))
        else:
          newData = combinedData[key]
      newData = np.transpose(newData)

      self.parent.parent.data.append(DataObject(self.parent.parent))
      self.parent.parent.data[-1].setName('Merger_' + self.parent.parent.data[targetIndex].name)
      self.parent.parent.data[-1].setNameResid('Merger_' + self.parent.parent.data[targetIndex].nameResid)
      # need to copy contents of original object
      self.parent.parent.data[-1].spawned(self.parent.parent.data[targetIndex])
      # hide merged data set
      self.parent.parent.data[mergeIndex].setVisibility(False, redraw=False)
      self.parent.parent.data[mergeIndex].setVisibilityResid(False, redraw=False)
      # a number of calls to update plots
      # note that the subsequent call to setData() deliberately ignores fval and resid (although we extended them above)
      # this may be changed in the future, hence the assignment
      self.helperDeclusterAndMerge(sourceIndex=targetIndex, newData=newData, newRoles=newRoles)
      # give voice
      self.parent.parent.statusbar.showMessage('Generated merged data set, while preserving original data sets.', self.parent.parent.STATUS_TIME, color='blue')
      # close menu
      self.close()
    
  def updateDataSetSelector(self, targetIndex):
    # populates and updates the QCombobox data set selector
    items = [entry for entry in self.parent.parent.data]
    self.dataSetSelector.clear()
    for index, item in enumerate(items):
      if(index != targetIndex):
        self.dataSetSelector.addItem(str(index + 1) + ' - ' + item.name)
        
    # do we have any items?
    if(self.dataSetSelector.count()):
      self.dataSetSelector.setEnabled(True)
      self.mergeButton.setEnabled(True)
    else:
      self.dataSetSelector.setEnabled(False)
      self.mergeButton.setEnabled(False)

  def toggleRestricted(self):
    # toggles restriction of plot intervall
    state = self.displayIntervalLabel.isChecked()
    self.updateRestrictedFields(state)
    self.target.setRestricted('restrictMe', state, redraw=True)

  def updateRestrictedFields(self, state):
    # changes activity of entry fields for plot interval control
    items = (self.entryDisplayIntervalLow, self.entryDisplayIntervalHigh)
    for item in items:
      if(hasattr(item, 'setEnabled')):
        item.setEnabled(state)

  def changeRestricted(self, key=None, entryfield=None, minval=0, maxval=1):
    if((self.target != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      if(maxval != None):
        value = np.min((value, maxval))
      if(minval != None):
        value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))

      self.target.setRestricted(key, value, redraw=True)
    
  def toggleDisplay(self, button=None, target=None, flag=None):
    # toggles visibility of submenus
    if((button != None) and (target != None)):
      if(button.isChecked()):
        target.show()
        if((flag != None) and (hasattr(self.parent, flag))):
          self.parent.__dict__[flag] = True
      else:
        target.hide()
        if((flag != None) and (hasattr(self.parent, flag))):
          self.parent.__dict__[flag] = False
      self.adjustSize()

  def makeActive(self, leader, index):
    field = None
    if(leader.startswith('Data')):
      if(index != self.parent.parent.activeData):
        if(hasattr(self.parent.parent.objectsarea, 'dataSetTable')):
          field = self.parent.parent.objectsarea.dataSetTable.cellWidget(index, 1)
    elif(leader.startswith('Curve')):
      if(index != self.parent.parent.activeFit):
        if(hasattr(self.parent.parent.objectsarea, 'curvesTable')):
          field = self.parent.parent.objectsarea.curvesTable.cellWidget(index, 1)
    
    if(field != None):
      field.setChecked(True)
    self.activeButton.setEnabled(False)

  def alterZ(self, leader, index, direction):
    field = None
    if(leader.startswith('Data')):
      if(hasattr(self.parent.parent.objectsarea, 'dataSetTable')):
        field = self.parent.parent.objectsarea.dataSetTable.cellWidget(index, 2)
    elif(leader.startswith('Curve')):
      if(hasattr(self.parent.parent.objectsarea, 'curvesTable')):
        field = self.parent.parent.objectsarea.curvesTable.cellWidget(index, 2)
    elif(leader.startswith('Resid')):
      if(hasattr(self.parent.parent.objectsarea, 'residTable')):
        field = self.parent.parent.objectsarea.residTable.cellWidget(index + 1, 2)
    elif(leader.startswith('Zero Line')):
      if(hasattr(self.parent.parent.objectsarea, 'residTable')):
        field = self.parent.parent.objectsarea.residTable.cellWidget(index, 2)

    if(field != None):
      value, minimum, maximum = field.value(), field.minimum(), field.maximum()
      newValue = value + direction
      newValue = max(minimum, newValue)
      newValue = min(maximum, newValue)
      # set new value
      if(newValue != value):
        field.setValue(newValue)
      # (in)activate control buttons
      if(newValue == minimum):
        self.zDownButton.setEnabled(False)
      else:
        self.zDownButton.setEnabled(True)
      if(newValue == maximum):
        self.zUpButton.setEnabled(False)
      else:
        self.zUpButton.setEnabled(True)

  def setField(self, leader, index):
    text = self.entryField.text()
    field = None
    if(leader.startswith('Data')):
      if(hasattr(self.parent.parent.objectsarea, 'dataSetTable')):
        field = self.parent.parent.objectsarea.dataSetTable.cellWidget(index, 3)
    elif(leader.startswith('Curve')):
      if(hasattr(self.parent.parent.objectsarea, 'curvesTable')):
        field = self.parent.parent.objectsarea.curvesTable.cellWidget(index, 3)
    elif(leader.startswith('Resid')):
      if(hasattr(self.parent.parent.objectsarea, 'residTable')):
        field = self.parent.parent.objectsarea.residTable.cellWidget(index + 1, 3)
        
    if(field != None):
      field.setText(text)
      field.editingFinished.emit()

  def guessDeclusterTol(self, index):
    # proposes tolerances for declustering in x and y
    scaleMarker = 1.1
    currWidth, currHeight = 72.0 * self.parent.parent.plotArea.matplot.get_size_inches()
    if(self.parent.parent.data[index].handleData != None):
      markersize = self.parent.parent.data[index].handleData.get_markersize() + self.parent.parent.data[index].handleData.get_markeredgewidth()
      fractionWidth , fractionHeight = currWidth / markersize, currHeight / markersize
      absoluteWidth = scaleMarker * abs(self.parent.parent.plotArea.maxX - self.parent.parent.plotArea.minX) / fractionWidth
      absoluteHeight = scaleMarker * abs(self.parent.parent.plotArea.maxY - self.parent.parent.plotArea.minY) / fractionHeight
      # update tolerances
      self.parent.declusterTolX, self.parent.declusterTolY = absoluteWidth, absoluteHeight
      self.declusterTolXEntry.setText(self.parent.parent.formatNumber(absoluteWidth))
      self.declusterTolYEntry.setText(self.parent.parent.formatNumber(absoluteHeight))

  def declusterData(self, index):
    # declusters data in swarmplot fashion
    deltaX, deltaY = self.parent.declusterTolX, self.parent.declusterTolY
    data = self.parent.parent.data[index].value()
    if(('x' in data) and ('y' in data)):
      # implement option to terminate declustering if stalled
      self.runFlag, self.fev = True, 0
      self.daughterWindow = MinWindow(self, 'Decluster Data')
      # apply styles to popup window
      if(QSTYLE != None):
        self.daughterWindow.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.daughterWindow.setStyleSheet(QSTYLESHEET)
      self.daughterWindow.show()
      self.daughterWindow.messageLabel.setText('')
      self.daughterWindow.iterLabel.setText('no. data points: ' + str(len(data['x'])))
      useData = np.vstack((data['x'], data['y']))
      # loop through data array
      dataChanged, initialSign = False, 1.0
      for line in range(1, len(data['x'])):
        if(self.daughterWindow != None):
          self.daughterWindow.minLabel.setText('current data point: ' + str(line))
        currX, currY = useData[0, line], useData[1, line]
        currDeltaX, initCycle = 0, True
        collisionCheck = True
        while(collisionCheck and self.runFlag):
          collisionCheck, line2 = False, 0
          # adjust delta for current cycle
          if(initCycle):
            initCycle = False
          elif(currDeltaX > 0):
            currDeltaX = -currDeltaX
          else:
            currDeltaX = -currDeltaX + deltaX
          # check for data points spaced too closely
          while(line2 < line):
            if(not (self.fev % 100)):
              QtCore.QCoreApplication.processEvents()
            self.fev += 1
            normDistance = ((useData[0, line2] - currX - initialSign * currDeltaX) / deltaX) ** 2 + ((useData[1, line2] - currY) / deltaY) ** 2
            if(normDistance <= 1.0):
              collisionCheck = True
              line2 = line
            else:
              line2 += 1
        
        # okay, either we did not find a collision or we adjusted delta accordingly
        if(abs(currDeltaX) > 0):
          useData[0, line] += initialSign * currDeltaX
          dataChanged = True
          initialSign *= -1.0
      
      # create declustered data object and plot
      if(not self.runFlag):
        self.parent.parent.statusbar.showMessage('Declustering data aborted by user.', self.parent.parent.STATUS_TIME)
      elif(dataChanged):
        data['x'], data['y'] = useData[0], useData[1]
        newData, newRoles = [], []
        for key in data:
          newRoles.append(key)
          if(len(newData)):
            newData = np.vstack((newData, data[key]))
          else:
            newData = data[key]
        newData = np.transpose(newData)

        self.parent.parent.data.append(DataObject(self.parent.parent))
        self.parent.parent.data[-1].setName('Decluster_' + self.parent.parent.data[index].name)
        self.parent.parent.data[-1].setNameResid('Decluster_' + self.parent.parent.data[index].nameResid)
        # need to copy contents of original object
        self.parent.parent.data[-1].spawned(self.parent.parent.data[index])
        # turn off violin/box display in newly generated object to prevent ungodly mess
        self.parent.parent.data[-1].Violinstyle['mode'] = 0
        # a number of calls to update plots
        self.helperDeclusterAndMerge(sourceIndex=index, newData=newData, newRoles=newRoles)
        # give voice
        self.parent.parent.statusbar.showMessage('Generated declustered copy of data set, while preserving original one.', self.parent.parent.STATUS_TIME, color='blue')
        # close menu
        self.close()
      else:
        self.parent.parent.statusbar.showMessage('No data found that would need declustering!', self.parent.parent.STATUS_TIME, color='blue')

      # clean up as needed
      if(self.daughterWindow != None):
        self.daughterWindow.close()
        self.daughterWindow = None
    else:
      self.parent.parent.statusbar.showMessage('Cannot decluster because x and/or y data missing!', self.parent.parent.STATUS_TIME)

  def helperDeclusterAndMerge(self, sourceIndex, newData, newRoles):
    # jointly issued calls by declusterData() and mergeData()
    # update data in new object
    self.parent.parent.data[-1].setData(newData, newRoles, labels=self.parent.parent.data[-1].labels)
    # set new data object as active
    self.parent.parent.activeData = (len(self.parent.parent.data) - 1)
    self.parent.changeActiveDataSet(len(self.parent.parent.data) - 1, setCheck=False)
    # hide original data set
    self.parent.parent.data[sourceIndex].setVisibility(False, redraw=False)
    self.parent.parent.data[sourceIndex].setVisibilityResid(False, redraw=False)
    # cause data to be drawn
    self.parent.parent.data[-1].drawMe(redraw=False)
    self.parent.refreshDataTable()
    self.parent.dataSetTable.scrollToBottom()
    # also create a new resid object
    self.parent.parent.plotArea.setAxisLimits(lower=self.parent.parent.plotArea.minX, upper=self.parent.parent.plotArea.maxX, axis='x', updateLabel=False, target='resid', redraw=False, updateGrid=True)
    self.parent.parent.plotArea.setAxisLimits(lower=self.parent.parent.plotArea.minX_div, upper=self.parent.parent.plotArea.maxX_div, axis='x2', updateLabel=False, target='resid', redraw=False, updateGrid=True)
    self.parent.parent.data[-1].drawMeResid(redraw=False)
    self.parent.parent.plotArea.handleResidZero = self.parent.parent.plotArea.plotResidZero(self.parent.parent.plotArea.handleResidZero, redraw=True)
    self.parent.refreshResidTable()
    self.parent.residTable.scrollToBottom()
    # also refresh curves table to account for increased total number of items
    self.parent.refreshCurvesTable()
    self.parent.refreshExtrasTable()
    self.parent.parent.globalarea.updateDataSetTable()
    # update results table
    self.parent.parent.resultsarea.setDataSet(currIndex=len(self.parent.parent.data) - 1, maxIndex=len(self.parent.parent.data) - 1)
    # redraw active curve over current x interval
    self.parent.parent.fit[self.parent.parent.activeFit].drawMe(redraw=False, rescale=False)
    # update legend if needed
    self.parent.updateLegend(redraw=True)

  def changeTol(self, entryfield=None, minval=0, maxval=1):
    # check paramter boundaries
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
    # update parameters in parent object
    if(entryfield == self.declusterTolXEntry):
      self.parent.declusterTolX = value
    else:
      self.parent.declusterTolY = value

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

class GraphicsArea(QWidgetMac):
  def __init__(self, parent=None, secondAxes=False):
    super(GraphicsArea, self).__init__()
    self.parent = parent
    self.secondAxes = secondAxes
    
    # initial export filter
    self.exportFilter = ''
    
    # initialize filenames
    self.currStyleFile = None
    self.currExportFile = None
    
    # advanced export settings
    self.advancedExport = {'plotDPI': 600, 'plotResid': True, 'SVGtxt2path': False, 'advancedGraphics': False, 'stateFileFormat': 'statez'}
    
    # int and float validators
    self.validInt = MyValidInt()
    self.validFloat = MyValidFloat()

    # set up styles
    self.linestyles = ['None', 'solid', 'dashed', 'dashdot', 'dotted']
    self.dashstyles = ['butt', 'round', 'projecting']
    self.positionstyles = ['axes', 'data']
    # linestyles for graphics elements that do not heed 'None' (e.g. axis spines)
    self.linestyles2 = ['solid', 'dashed', 'dashdot', 'dotted']
    
    # set up GUI
    self.advancedGraphicsSettings = []
    self.buildRessource()
    # now populate fields
    self.updateFields(initialize=True)
    # and connect events
    self.connectEvents()

  def buildRessource(self):
    # build gui
    self.vLayout_0 = QtWidgets.QVBoxLayout(self)
    self.vLayout_0.setContentsMargins(0, 0, 0, 0)
    self.vLayout_0.setAlignment(QtCore.Qt.AlignTop)
    
    # container widget for subsequent widgets
    self.containerScroll = QtWidgets.QScrollArea()
    self.containerScroll.setWidgetResizable(True)
    # don't use palettes as these are incompatible with style sheets
    self.containerScroll.setAutoFillBackground(True)
    self.vLayout_0.addWidget(self.containerScroll)

    self.containerBox = QWidgetMac()
    # setting the background somehow breaks QStyleSet for children :(
    #self.containerBox.setStyleSheet('#stultus {background-color: white;}')
    self.containerBox.setAutoFillBackground(True)
    self.vLayout = QtWidgets.QVBoxLayout(self.containerBox)
    self.vLayout.setContentsMargins(0, 0, 0, 0)
    self.vLayout.setSpacing(scaledDPI(3))
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.containerScroll.setWidget(self.containerBox)
    
    # x label config
    self.alignHorizontal = ['left', 'center', 'right']
    self.alignVertical = ['top', 'center', 'bottom', 'baseline']
    if(not self.secondAxes):
      self.configXBox = QWidgetMac()
      self.vLayout.addWidget(self.configXBox)
      self.Layout_configX = QtWidgets.QHBoxLayout(self.configXBox)
      self.Layout_configX.setContentsMargins(0, 0, 0, 0)
      self.Layout_configX.setAlignment(QtCore.Qt.AlignLeft)
      self.configXLabel = QPushButtonCheckable()
      useFont = self.configXLabel.font()
      useFont.setBold(True)
      self.configXLabel.setFont(useFont)
      self.configXLabel.setText('xlabel')
      self.configXLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configXLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configX.addWidget(self.configXLabel)
      self.configXName = QLineEditClick()
      self.configXName.setAlignment(QtCore.Qt.AlignLeft)
      self.configXName.setMaximumSize(QtCore.QSize(scaledDPI(400), scaledDPI(BASE_SIZE)))
      self.configXName.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
      self.Layout_configX.addWidget(self.configXName)
  
      # x label config 2nd line
      self.configXBox2 = QWidgetMac()
      self.vLayout.addWidget(self.configXBox2)
      self.Layout_configX2 = QtWidgets.QHBoxLayout(self.configXBox2)
      self.Layout_configX2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configX2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configX2.addWidget(spacer)
      
      self.configXSizeLabel = QtWidgets.QLabel('font')
      self.configXSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configXSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configX2.addWidget(self.configXSizeLabel)
      self.configXColorButton = QPushButtonMac()
      self.configXColorButton.setAutoFillBackground(False)
      self.configXColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configXColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configXColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configX2.addWidget(self.configXColorButton)
  
      self.configXSize = QLineEditClick()
      self.configXSize.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXSize.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXSize.setValidator(self.validFloat)
      self.Layout_configX2.addWidget(self.configXSize)
      
      self.configXBold = QPushButtonCheckable()
      self.configXBold.setText('B')
      self.configXBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configXBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configXBold.font()
      useFont.setWeight(75)
      self.configXBold.setFont(useFont)
      self.Layout_configX2.addWidget(self.configXBold)
        
      self.configXItalic = QPushButtonCheckable()
      self.configXItalic.setText('I')
      self.configXItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configXItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configXItalic.font()
      useFont.setItalic(True)
      self.configXItalic.setFont(useFont)
      self.Layout_configX2.addWidget(self.configXItalic)
      
      if(0):
        # unfortunately not supported by matplotlib currently (this is a known bug)
        self.configXVariant = QPushButtonCheckable()
        self.configXVariant.setText('Aa')
        self.configXVariant.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configXVariant.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        useFont = self.configXVariant.font()
        useFont.setCapitalization(QtGui.QFont.SmallCaps)
        self.configXVariant.setFont(useFont)
        self.Layout_configX2.addWidget(self.configXVariant)
  
      self.configXFont = QComboBoxMac()
      self.configXFont.addItems(self.parent.fontNames)
      self.configXFont.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
      self.configXFont.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
      self.Layout_configX2.addWidget(self.configXFont)
  
      # x label config 3rd line
      self.configXBox3 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configXBox3)
      self.vLayout.addWidget(self.configXBox3)
      self.Layout_configX3 = QtWidgets.QHBoxLayout(self.configXBox3)
      self.Layout_configX3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configX3.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(spacer)
      
      self.configXAngleLabel = QtWidgets.QLabel('angle')
      self.configXAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configXAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXAngleLabel)
  
      self.configXAngle = QLineEditClick()
      self.configXAngle.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXAngle.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXAngle.setValidator(self.validFloat)
      self.Layout_configX3.addWidget(self.configXAngle)
      
      self.configXAlignmentLabel = QtWidgets.QLabel('align')
      self.configXAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.configXAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXAlignmentLabel)
  
      self.configXAlignment = QComboBoxMac()
      self.configXAlignment.addItems(self.alignHorizontal)
      self.configXAlignment.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configXAlignment.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXAlignment)
  
      self.configXAlignmentVertical = QComboBoxMac()
      self.configXAlignmentVertical.addItems(self.alignVertical)
      self.configXAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.configXAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXAlignmentVertical)
  
      self.configXPosLabel = QtWidgets.QLabel('pos.')
      self.configXPosLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.configXPosLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXPosLabel)
  
      self.configXPos = QLineEditClick()
      self.configXPos.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXPos.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXPos.setValidator(self.validFloat)
      self.Layout_configX3.addWidget(self.configXPos)
  
      self.configXPadLabel = QtWidgets.QLabel('pad')
      self.configXPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.configXPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.Layout_configX3.addWidget(self.configXPadLabel)
  
      self.configXPad = QLineEditClick()
      self.configXPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configXPad.setValidator(self.validFloat)
      self.Layout_configX3.addWidget(self.configXPad)

    # y label config
    self.configYBox = QWidgetMac()
    self.vLayout.addWidget(self.configYBox)
    self.Layout_configY = QtWidgets.QHBoxLayout(self.configYBox)
    self.Layout_configY.setContentsMargins(0, 0, 0, 0)
    self.Layout_configY.setAlignment(QtCore.Qt.AlignLeft)
    self.configYLabel = QPushButtonCheckable()
    useFont = self.configYLabel.font()
    useFont.setBold(True)
    self.configYLabel.setFont(useFont)
    self.configYLabel.setText('ylabel')
    self.configYLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.configYLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.Layout_configY.addWidget(self.configYLabel)
    self.configYName = QLineEditClick()
    self.configYName.setAlignment(QtCore.Qt.AlignLeft)
    self.configYName.setMaximumSize(QtCore.QSize(scaledDPI(400), scaledDPI(BASE_SIZE)))
    self.configYName.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
    self.Layout_configY.addWidget(self.configYName)

    # y label config 2nd line
    self.configYBox2 = QWidgetMac()
    self.vLayout.addWidget(self.configYBox2)
    self.Layout_configY2 = QtWidgets.QHBoxLayout(self.configYBox2)
    self.Layout_configY2.setContentsMargins(0, 0, 0, 0)
    self.Layout_configY2.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configY2.addWidget(spacer)
    
    self.configYSizeLabel = QtWidgets.QLabel('font')
    self.configYSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.configYSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.Layout_configY2.addWidget(self.configYSizeLabel)
    self.configYColorButton = QPushButtonMac()
    self.configYColorButton.setAutoFillBackground(False)
    self.configYColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configYColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configYColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.Layout_configY2.addWidget(self.configYColorButton)

    self.configYSize = QLineEditClick()
    self.configYSize.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYSize.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYSize.setValidator(self.validFloat)
    self.Layout_configY2.addWidget(self.configYSize)

    self.configYBold = QPushButtonCheckable()
    self.configYBold.setText('B')
    self.configYBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configYBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    useFont = self.configYBold.font()
    useFont.setWeight(75)
    self.configYBold.setFont(useFont)
    self.Layout_configY2.addWidget(self.configYBold)
      
    self.configYItalic = QPushButtonCheckable()
    self.configYItalic.setText('I')
    self.configYItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configYItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    useFont = self.configYItalic.font()
    useFont.setItalic(True)
    self.configYItalic.setFont(useFont)
    self.Layout_configY2.addWidget(self.configYItalic)

    if(0):
      # unfortunately not supported by matplotlib currently (this is a known bug)
      self.configYVariant = QPushButtonCheckable()
      self.configYVariant.setText('Aa')
      self.configYVariant.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configYVariant.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configYVariant.font()
      useFont.setCapitalization(QtGui.QFont.SmallCaps)
      self.configYVariant.setFont(useFont)
      self.Layout_configY2.addWidget(self.configYVariant)

    self.configYFont = QComboBoxMac()
    self.configYFont.addItems(self.parent.fontNames)
    self.configYFont.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
    self.configYFont.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
    self.Layout_configY2.addWidget(self.configYFont)

    # y label config 2nd line
    self.configYBox3 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configYBox3)
    self.vLayout.addWidget(self.configYBox3)
    self.Layout_configY3 = QtWidgets.QHBoxLayout(self.configYBox3)
    self.Layout_configY3.setContentsMargins(0, 0, 0, 0)
    self.Layout_configY3.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(spacer)
    
    self.configYAngleLabel = QtWidgets.QLabel('angle')
    self.configYAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.configYAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYAngleLabel)

    self.configYAngle = QLineEditClick()
    self.configYAngle.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYAngle.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYAngle.setValidator(self.validFloat)
    self.Layout_configY3.addWidget(self.configYAngle)
    
    self.configYAlignmentLabel = QtWidgets.QLabel('align')
    self.configYAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
    self.configYAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYAlignmentLabel)

    self.configYAlignment = QComboBoxMac()
    self.configYAlignment.addItems(self.alignHorizontal)
    self.configYAlignment.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.configYAlignment.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYAlignment)

    self.configYAlignmentVertical = QComboBoxMac()
    self.configYAlignmentVertical.addItems(self.alignVertical)
    self.configYAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.configYAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYAlignmentVertical)

    self.configYPosLabel = QtWidgets.QLabel('pos.')
    self.configYPosLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.configYPosLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYPosLabel)

    self.configYPos = QLineEditClick()
    self.configYPos.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYPos.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYPos.setValidator(self.validFloat)
    self.Layout_configY3.addWidget(self.configYPos)

    self.configYPadLabel = QtWidgets.QLabel('pad')
    self.configYPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.configYPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.Layout_configY3.addWidget(self.configYPadLabel)

    self.configYPad = QLineEditClick()
    self.configYPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configYPad.setValidator(self.validFloat)
    self.Layout_configY3.addWidget(self.configYPad)

    # axis config
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.configAxisBox = {}; self.Layout_configAxis = {}
    self.configAxisLabel = {}
    self.configAxisWidthLabel = {}; self.configAxisWidth = {}
    self.configAxisStyle = {}; self.configAxisDashStyle = {}; self.configAxisColor = {}
    self.configAxisBox2 = {}; self.Layout_configAxis2 = {}
    self.configAxisLabel2 = {}; self.configAxisPosition = {};
    self.configAxisPositionValue = {}; self.configAxisPositionReset = {}
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configAxisBox[axis] = QWidgetMac()
      self.vLayout.addWidget(self.configAxisBox[axis])
      self.Layout_configAxis[axis] = QtWidgets.QHBoxLayout(self.configAxisBox[axis])
      self.Layout_configAxis[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configAxis[axis].setAlignment(QtCore.Qt.AlignLeft)
      self.configAxisLabel[axis] = QPushButtonCheckable()
      self.configAxisLabel[axis].setText('ax ' + axis)
      useFont = self.configAxisLabel[axis].font()
      useFont.setBold(True)
      self.configAxisLabel[axis].setFont(useFont)
      self.configAxisLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configAxisLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis[axis].addWidget(self.configAxisLabel[axis])

      self.configAxisColor[axis] = QPushButtonMac()
      self.configAxisColor[axis].setAutoFillBackground(False)
      self.configAxisColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configAxisColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configAxisColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configAxis[axis].addWidget(self.configAxisColor[axis])
  
      self.configAxisWidthLabel[axis] = QtWidgets.QLabel('width')
      self.configAxisWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configAxisWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis[axis].addWidget(self.configAxisWidthLabel[axis])
      self.configAxisWidth[axis] = QLineEditClick()
      self.configAxisWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configAxisWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configAxisWidth[axis].setValidator(self.validFloat)
      self.Layout_configAxis[axis].addWidget(self.configAxisWidth[axis])

      self.configAxisStyle[axis] = QComboBoxMac()
      self.configAxisStyle[axis].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAxisStyle[axis].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis[axis].addWidget(self.configAxisStyle[axis])

      self.configAxisDashStyle[axis] = QComboBoxMac()
      self.advancedGraphicsSettings.append(self.configAxisDashStyle[axis])
      self.configAxisDashStyle[axis].setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.configAxisDashStyle[axis].setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis[axis].addWidget(self.configAxisDashStyle[axis])
      
      # second row
      self.configAxisBox2[axis] = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configAxisBox2[axis])
      self.vLayout.addWidget(self.configAxisBox2[axis])
      self.Layout_configAxis2[axis] = QtWidgets.QHBoxLayout(self.configAxisBox2[axis])
      self.Layout_configAxis2[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configAxis2[axis].setAlignment(QtCore.Qt.AlignLeft)

      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis2[axis].addWidget(spacer)

      self.configAxisLabel2[axis] = QtWidgets.QLabel('position')
      self.configAxisLabel2[axis].setMaximumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.configAxisLabel2[axis].setMinimumSize(QtCore.QSize(scaledDPI(46), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis2[axis].addWidget(self.configAxisLabel2[axis])

      self.configAxisPosition[axis] = QComboBoxMac()
      self.configAxisPosition[axis].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configAxisPosition[axis].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configAxis2[axis].addWidget(self.configAxisPosition[axis])

      self.configAxisPositionValue[axis] = QLineEditClick()
      self.configAxisPositionValue[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configAxisPositionValue[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configAxisPositionValue[axis].setValidator(self.validFloat)
      self.Layout_configAxis2[axis].addWidget(self.configAxisPositionValue[axis])

      self.configAxisPositionReset[axis] = QPushButtonMac('Reset')
      self.configAxisPositionReset[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE - 2)))
      self.configAxisPositionReset[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE - 2)))
      self.configAxisPositionReset[axis].setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configAxis2[axis].addWidget(self.configAxisPositionReset[axis])
  
    # arrow config
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    if(not self.secondAxes):
      self.configArrowBox = {}; self.Layout_configArrow = {}
      self.configArrowLabel = {}
      self.configArrowLineColor = {}; self.configArrowFillColor = {}
      self.configArrowHeadLengthLabel = {}; self.configArrowHeadLength = {}
      self.configArrowHeadWidthLabel = {}; self.configArrowHeadWidth = {}
      self.configArrowOverhangLabel = {}; self.configArrowOverhang = {}
      self.configArrowOffsetLabel = {}; self.configArrowOffset = {}
      for axis in ['x', 'y']:
        self.configArrowBox[axis] = QWidgetMac()
        self.vLayout.addWidget(self.configArrowBox[axis])
        self.Layout_configArrow[axis] = QtWidgets.QHBoxLayout(self.configArrowBox[axis])
        self.Layout_configArrow[axis].setContentsMargins(0, 0, 0, 0)
        self.Layout_configArrow[axis].setAlignment(QtCore.Qt.AlignLeft)
        
        self.configArrowLabel[axis] = QPushButtonCheckable()
        self.configArrowLabel[axis].setText('arrow ' + axis)
        useFont = self.configArrowLabel[axis].font()
        useFont.setBold(True)
        self.configArrowLabel[axis].setFont(useFont)
        self.configArrowLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
        self.configArrowLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow[axis].addWidget(self.configArrowLabel[axis])
  
        self.configArrowLineColor[axis] = QPushButtonMac()
        self.configArrowLineColor[axis].setAutoFillBackground(False)
        self.configArrowLineColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configArrowLineColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configArrowLineColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
        self.Layout_configArrow[axis].addWidget(self.configArrowLineColor[axis])
        self.configArrowFillColor[axis] = QPushButtonMac()
        self.configArrowFillColor[axis].setAutoFillBackground(False)
        self.configArrowFillColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configArrowFillColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configArrowFillColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
        self.Layout_configArrow[axis].addWidget(self.configArrowFillColor[axis])
    
        self.configArrowHeadLengthLabel[axis] = QtWidgets.QLabel('length')
        self.configArrowHeadLengthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadLengthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow[axis].addWidget(self.configArrowHeadLengthLabel[axis])
        self.configArrowHeadLength[axis] = QLineEditClick()
        self.configArrowHeadLength[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadLength[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadLength[axis].setValidator(self.validFloat)
        self.Layout_configArrow[axis].addWidget(self.configArrowHeadLength[axis])
        self.configArrowHeadWidthLabel[axis] = QtWidgets.QLabel('width')
        self.configArrowHeadWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow[axis].addWidget(self.configArrowHeadWidthLabel[axis])
        self.configArrowHeadWidth[axis] = QLineEditClick()
        self.configArrowHeadWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowHeadWidth[axis].setValidator(self.validFloat)
        self.Layout_configArrow[axis].addWidget(self.configArrowHeadWidth[axis])
  
        self.configArrowOverhangLabel[axis] = QtWidgets.QLabel('ind.')
        self.configArrowOverhangLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
        self.configArrowOverhangLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow[axis].addWidget(self.configArrowOverhangLabel[axis])
        self.configArrowOverhang[axis] = QLineEditClick()
        self.configArrowOverhang[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowOverhang[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowOverhang[axis].setValidator(self.validFloat)
        self.Layout_configArrow[axis].addWidget(self.configArrowOverhang[axis])
  
        self.configArrowOffsetLabel[axis] = QtWidgets.QLabel('off.')
        self.configArrowOffsetLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
        self.configArrowOffsetLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(16), scaledDPI(BASE_SIZE)))
        self.Layout_configArrow[axis].addWidget(self.configArrowOffsetLabel[axis])
        self.configArrowOffset[axis] = QLineEditClick()
        self.configArrowOffset[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowOffset[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.configArrowOffset[axis].setValidator(self.validFloat)
        self.Layout_configArrow[axis].addWidget(self.configArrowOffset[axis])

    # x ticks config
    self.formatOptions = ['default', 'float', 'scientific', 'mathtext']
    if(not self.secondAxes):
      blah = self.HLine()
      self.vLayout.addWidget(blah)
      self.configTickXBox = QWidgetMac()
      self.vLayout.addWidget(self.configTickXBox)
      self.Layout_configTickX = QtWidgets.QHBoxLayout(self.configTickXBox)
      self.Layout_configTickX.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickXLabel = QPushButtonCheckable()
      useFont = self.configTickXLabel.font()
      useFont.setBold(True)
      self.configTickXLabel.setFont(useFont)
      self.configTickXLabel.setText('x ticks')
      self.configTickXLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configTickXLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX.addWidget(self.configTickXLabel)
      
      self.configTickXAuto = QPushButtonMac()
      self.configTickXAuto.setText('auto')
      self.configTickXAuto.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickXAuto.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX.addWidget(self.configTickXAuto)
          
      self.configTickXEntry = QLineEditClick()
      self.configTickXEntry.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickXEntry.setMaximumSize(QtCore.QSize(scaledDPI(224), scaledDPI(BASE_SIZE)))
      self.configTickXEntry.setMinimumSize(QtCore.QSize(scaledDPI(224), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX.addWidget(self.configTickXEntry)
  
      self.configTickUseData = QPushButtonMac()
      self.configTickUseData.setText('use labels')
      self.configTickUseData.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.configTickUseData.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX.addWidget(self.configTickUseData)
  
      self.configTickXBox3 = QWidgetMac()
      self.vLayout.addWidget(self.configTickXBox3)
      self.Layout_configTickX3 = QtWidgets.QHBoxLayout(self.configTickXBox3)
      self.Layout_configTickX3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX3.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX3.addWidget(spacer)
      
      self.configTickXSizeLabel = QtWidgets.QLabel('font')
      self.configTickXSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configTickXSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX3.addWidget(self.configTickXSizeLabel)
      self.configTickXColorButton = QPushButtonMac()
      self.configTickXColorButton.setAutoFillBackground(False)
      self.configTickXColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickXColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickXColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configTickX3.addWidget(self.configTickXColorButton)
  
      self.configTickXSize = QLineEditClick()
      self.configTickXSize.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXSize.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXSize.setValidator(self.validFloat)
      self.Layout_configTickX3.addWidget(self.configTickXSize)
  
      self.configTickXBold = QPushButtonCheckable()
      self.configTickXBold.setText('B')
      self.configTickXBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickXBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configTickXBold.font()
      useFont.setWeight(75)
      self.configTickXBold.setFont(useFont)
      self.Layout_configTickX3.addWidget(self.configTickXBold)
        
      self.configTickXItalic = QPushButtonCheckable()
      self.configTickXItalic.setText('I')
      self.configTickXItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickXItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configTickXItalic.font()
      useFont.setItalic(True)
      self.configTickXItalic.setFont(useFont)
      self.Layout_configTickX3.addWidget(self.configTickXItalic)
  
      self.configTickXFont = QComboBoxMac()
      self.configTickXFont.addItems(self.parent.fontNames)
      self.configTickXFont.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
      self.configTickXFont.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX3.addWidget(self.configTickXFont)
  
      self.configTickXBox2 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configTickXBox2)
      self.vLayout.addWidget(self.configTickXBox2)
      self.Layout_configTickX2 = QtWidgets.QHBoxLayout(self.configTickXBox2)
      self.Layout_configTickX2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(spacer)
      
      self.configTickXAngleLabel = QtWidgets.QLabel('angle')
      self.configTickXAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configTickXAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXAngleLabel)
  
      self.configTickXAngle = QLineEditClick()
      self.configTickXAngle.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXAngle.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXAngle.setValidator(self.validFloat)
      self.Layout_configTickX2.addWidget(self.configTickXAngle)
      
      self.configTickXAlignmentLabel = QtWidgets.QLabel('align')
      self.configTickXAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.configTickXAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXAlignmentLabel)
  
      self.configTickXAlignment = QComboBoxMac()
      self.configTickXAlignment.addItems(self.alignHorizontal)
      self.configTickXAlignment.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configTickXAlignment.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXAlignment)
  
      self.configTickXAlignmentVertical = QComboBoxMac()
      self.configTickXAlignmentVertical.addItems(self.alignVertical)
      self.configTickXAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.configTickXAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXAlignmentVertical)
  
      self.configTickXPadLabel = QtWidgets.QLabel('pad')
      self.configTickXPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.configTickXPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXPadLabel)
  
      self.configTickXPad = QLineEditClick()
      self.configTickXPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXPad.setValidator(self.validFloat)
      self.Layout_configTickX2.addWidget(self.configTickXPad)

      self.configTickXPad2Label = QtWidgets.QLabel('pad2')
      self.configTickXPad2Label.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configTickXPad2Label.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX2.addWidget(self.configTickXPad2Label)
  
      self.configTickXPad2 = QLineEditClick()
      self.configTickXPad2.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXPad2.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXPad2.setValidator(self.validFloat)
      self.Layout_configTickX2.addWidget(self.configTickXPad2)

      # tick label formatting
      self.configTickXBox4 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configTickXBox4)
      self.vLayout.addWidget(self.configTickXBox4)
      self.Layout_configTickX4 = QtWidgets.QHBoxLayout(self.configTickXBox4)
      self.Layout_configTickX4.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX4.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(spacer)
      
      self.configTickXFormatLabel = QtWidgets.QLabel('fmt')
      self.configTickXFormatLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configTickXFormatLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatLabel)
  
      self.configTickXFormat = QComboBoxMac()
      self.configTickXFormat.addItems(self.formatOptions)
      self.configTickXFormat.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configTickXFormat.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormat)
  
      self.configTickXFormatPrecisionLabel = QtWidgets.QLabel('precision')
      self.configTickXFormatPrecisionLabel.setMaximumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
      self.configTickXFormatPrecisionLabel.setMinimumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatPrecisionLabel)
  
      self.configTickXFormatPrecision = QLineEditClick()
      self.configTickXFormatPrecision.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXFormatPrecision.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickXFormatPrecision.setValidator(self.validInt)
      self.Layout_configTickX4.addWidget(self.configTickXFormatPrecision)

      self.configTickXFormatTrailZero = QPushButtonCheckable()
      self.configTickXFormatTrailZero.setText('trail zeros?')
      self.configTickXFormatTrailZero.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configTickXFormatTrailZero.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatTrailZero)

      self.configTickXFormatSeparator = QPushButtonCheckable()
      self.configTickXFormatSeparator.setText('separate 1000s?')
      self.configTickXFormatSeparator.setMaximumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
      self.configTickXFormatSeparator.setMinimumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX4.addWidget(self.configTickXFormatSeparator)
      self.Layout_configTickX4.addStretch()

      # tick label formatting ctd.
      self.configTickXBox5 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configTickXBox5)
      self.vLayout.addWidget(self.configTickXBox5)
      self.Layout_configTickX5 = QtWidgets.QHBoxLayout(self.configTickXBox5)
      self.Layout_configTickX5.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickX5.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(spacer)
      
      self.configTickXPrefixLabel = QtWidgets.QLabel('prefix')
      self.configTickXPrefixLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configTickXPrefixLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(self.configTickXPrefixLabel)
      self.configTickXPrefix = QLineEditClick()
      self.configTickXPrefix.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickXPrefix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configTickXPrefix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(self.configTickXPrefix)

      self.configTickXPostfixLabel = QtWidgets.QLabel('postfix')
      self.configTickXPostfixLabel.setMaximumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
      self.configTickXPostfixLabel.setMinimumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(self.configTickXPostfixLabel)
      self.configTickXPostfix = QLineEditClick()
      self.configTickXPostfix.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickXPostfix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configTickXPostfix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configTickX5.addWidget(self.configTickXPostfix)

    # y ticks config
    self.configTickYBox = QWidgetMac()
    self.vLayout.addWidget(self.configTickYBox)
    self.Layout_configTickY = QtWidgets.QHBoxLayout(self.configTickYBox)
    self.Layout_configTickY.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY.setAlignment(QtCore.Qt.AlignLeft)
    self.configTickYLabel = QPushButtonCheckable()
    useFont = self.configTickYLabel.font()
    useFont.setBold(True)
    self.configTickYLabel.setFont(useFont)
    self.configTickYLabel.setText('y ticks')
    self.configTickYLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.configTickYLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY.addWidget(self.configTickYLabel)
    
    self.configTickYAuto = QPushButtonMac()
    self.configTickYAuto.setText('auto')
    self.configTickYAuto.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.configTickYAuto.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY.addWidget(self.configTickYAuto)
        
    self.configTickYEntry = QLineEditClick()
    self.configTickYEntry.setAlignment(QtCore.Qt.AlignLeft)
    self.configTickYEntry.setMaximumSize(QtCore.QSize(scaledDPI(224), scaledDPI(BASE_SIZE)))
    self.configTickYEntry.setMinimumSize(QtCore.QSize(scaledDPI(224), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY.addWidget(self.configTickYEntry)

    self.configTickYBox3 = QWidgetMac()
    self.vLayout.addWidget(self.configTickYBox3)
    self.Layout_configTickY3 = QtWidgets.QHBoxLayout(self.configTickYBox3)
    self.Layout_configTickY3.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY3.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY3.addWidget(spacer)
    
    self.configTickYSizeLabel = QtWidgets.QLabel('font')
    self.configTickYSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.configTickYSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY3.addWidget(self.configTickYSizeLabel)
    self.configTickYColorButton = QPushButtonMac()
    self.configTickYColorButton.setAutoFillBackground(False)
    self.configTickYColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configTickYColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configTickYColorButton.setCursor(QtCore.Qt.PointingHandCursor)
    self.Layout_configTickY3.addWidget(self.configTickYColorButton)

    self.configTickYSize = QLineEditClick()
    self.configTickYSize.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYSize.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYSize.setValidator(self.validFloat)
    self.Layout_configTickY3.addWidget(self.configTickYSize)

    self.configTickYBold = QPushButtonCheckable()
    self.configTickYBold.setText('B')
    self.configTickYBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configTickYBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    useFont = self.configTickYBold.font()
    useFont.setWeight(75)
    self.configTickYBold.setFont(useFont)
    self.Layout_configTickY3.addWidget(self.configTickYBold)
      
    self.configTickYItalic = QPushButtonCheckable()
    self.configTickYItalic.setText('I')
    self.configTickYItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.configTickYItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    useFont = self.configTickYItalic.font()
    useFont.setItalic(True)
    self.configTickYItalic.setFont(useFont)
    self.Layout_configTickY3.addWidget(self.configTickYItalic)

    self.configTickYFont = QComboBoxMac()
    self.configTickYFont.addItems(self.parent.fontNames)
    self.configTickYFont.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
    self.configTickYFont.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY3.addWidget(self.configTickYFont)

    self.configTickYBox2 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configTickYBox2)
    self.vLayout.addWidget(self.configTickYBox2)
    self.Layout_configTickY2 = QtWidgets.QHBoxLayout(self.configTickYBox2)
    self.Layout_configTickY2.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY2.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(spacer)

    self.configTickYAngleLabel = QtWidgets.QLabel('angle')
    self.configTickYAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.configTickYAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYAngleLabel)

    self.configTickYAngle = QLineEditClick()
    self.configTickYAngle.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYAngle.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYAngle.setValidator(self.validFloat)
    self.Layout_configTickY2.addWidget(self.configTickYAngle)
    
    self.configTickYAlignmentLabel = QtWidgets.QLabel('align')
    self.configTickYAlignmentLabel.setMaximumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
    self.configTickYAlignmentLabel.setMinimumSize(QtCore.QSize(scaledDPI(22), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYAlignmentLabel)

    self.configTickYAlignment = QComboBoxMac()
    self.configTickYAlignment.addItems(self.alignHorizontal)
    self.configTickYAlignment.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.configTickYAlignment.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYAlignment)

    self.configTickYAlignmentVertical = QComboBoxMac()
    self.configTickYAlignmentVertical.addItems(self.alignVertical)
    self.configTickYAlignmentVertical.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.configTickYAlignmentVertical.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYAlignmentVertical)

    self.configTickYPadLabel = QtWidgets.QLabel('pad')
    self.configTickYPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.configTickYPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(20), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYPadLabel)

    self.configTickYPad = QLineEditClick()
    self.configTickYPad.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYPad.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYPad.setValidator(self.validFloat)
    self.Layout_configTickY2.addWidget(self.configTickYPad)

    self.configTickYPad2Label = QtWidgets.QLabel('pad2')
    self.configTickYPad2Label.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
    self.configTickYPad2Label.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY2.addWidget(self.configTickYPad2Label)

    self.configTickYPad2 = QLineEditClick()
    self.configTickYPad2.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYPad2.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYPad2.setValidator(self.validFloat)
    self.Layout_configTickY2.addWidget(self.configTickYPad2)

    # tick label formatting
    self.configTickYBox4 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configTickYBox4)
    self.vLayout.addWidget(self.configTickYBox4)
    self.Layout_configTickY4 = QtWidgets.QHBoxLayout(self.configTickYBox4)
    self.Layout_configTickY4.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY4.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(spacer)
    
    self.configTickYFormatLabel = QtWidgets.QLabel('fmt')
    self.configTickYFormatLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.configTickYFormatLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatLabel)

    self.configTickYFormat = QComboBoxMac()
    self.configTickYFormat.addItems(self.formatOptions)
    self.configTickYFormat.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.configTickYFormat.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormat)

    self.configTickYFormatPrecisionLabel = QtWidgets.QLabel('precision')
    self.configTickYFormatPrecisionLabel.setMaximumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
    self.configTickYFormatPrecisionLabel.setMinimumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatPrecisionLabel)

    self.configTickYFormatPrecision = QLineEditClick()
    self.configTickYFormatPrecision.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYFormatPrecision.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
    self.configTickYFormatPrecision.setValidator(self.validInt)
    self.Layout_configTickY4.addWidget(self.configTickYFormatPrecision)

    self.configTickYFormatTrailZero = QPushButtonCheckable()
    self.configTickYFormatTrailZero.setText('trail zeros?')
    self.configTickYFormatTrailZero.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.configTickYFormatTrailZero.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatTrailZero)

    self.configTickYFormatSeparator = QPushButtonCheckable()
    self.configTickYFormatSeparator.setText('separate 1000s?')
    self.configTickYFormatSeparator.setMaximumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
    self.configTickYFormatSeparator.setMinimumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY4.addWidget(self.configTickYFormatSeparator)
    self.Layout_configTickY4.addStretch()

    # tick label formatting ctd.
    self.configTickYBox5 = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configTickYBox5)
    self.vLayout.addWidget(self.configTickYBox5)
    self.Layout_configTickY5 = QtWidgets.QHBoxLayout(self.configTickYBox5)
    self.Layout_configTickY5.setContentsMargins(0, 0, 0, 0)
    self.Layout_configTickY5.setAlignment(QtCore.Qt.AlignLeft)

    spacer = QtWidgets.QLabel()
    spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(spacer)
    
    self.configTickYPrefixLabel = QtWidgets.QLabel('prefix')
    self.configTickYPrefixLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.configTickYPrefixLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(self.configTickYPrefixLabel)
    self.configTickYPrefix = QLineEditClick()
    self.configTickYPrefix.setAlignment(QtCore.Qt.AlignLeft)
    self.configTickYPrefix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.configTickYPrefix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(self.configTickYPrefix)

    self.configTickYPostfixLabel = QtWidgets.QLabel('postfix')
    self.configTickYPostfixLabel.setMaximumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
    self.configTickYPostfixLabel.setMinimumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(self.configTickYPostfixLabel)
    self.configTickYPostfix = QLineEditClick()
    self.configTickYPostfix.setAlignment(QtCore.Qt.AlignLeft)
    self.configTickYPostfix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.configTickYPostfix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.Layout_configTickY5.addWidget(self.configTickYPostfix)

    if(not self.secondAxes):
      self.configTickResidYBox = QWidgetMac()
      self.vLayout.addWidget(self.configTickResidYBox)
      self.Layout_configTickResidY = QtWidgets.QHBoxLayout(self.configTickResidYBox)
      self.Layout_configTickResidY.setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickResidY.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickResidYLabel = QPushButtonCheckable()
      useFont = self.configTickResidYLabel.font()
      useFont.setBold(True)
      self.configTickResidYLabel.setFont(useFont)
      self.configTickResidYLabel.setText('resid')
      self.configTickResidYLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configTickResidYLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidY.addWidget(self.configTickResidYLabel)
  
      self.configTickResidYAuto = QPushButtonMac()
      self.configTickResidYAuto.setText('auto')
      self.configTickResidYAuto.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickResidYAuto.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidY.addWidget(self.configTickResidYAuto)
          
      self.configTickResidYEntry = QLineEditClick()
      self.configTickResidYEntry.setAlignment(QtCore.Qt.AlignLeft)
      self.configTickResidYEntry.setMaximumSize(QtCore.QSize(scaledDPI(224), scaledDPI(BASE_SIZE)))
      self.configTickResidYEntry.setMinimumSize(QtCore.QSize(scaledDPI(224), scaledDPI(BASE_SIZE)))
      self.Layout_configTickResidY.addWidget(self.configTickResidYEntry)

    # minor ticks
    self.configMinorTickBox = QWidgetMac()
    self.advancedGraphicsSettings.append(self.configMinorTickBox)
    self.vLayout.addWidget(self.configMinorTickBox)
    self.Layout_configMinorTickBox = QtWidgets.QHBoxLayout(self.configMinorTickBox)
    self.Layout_configMinorTickBox.setContentsMargins(0, 0, 0, 0)
    self.Layout_configMinorTickBox.setAlignment(QtCore.Qt.AlignLeft)
    self.configMinorTickLabel = QtWidgets.QLabel()
    useFont = self.configMinorTickLabel.font()
    useFont.setBold(True)
    self.configMinorTickLabel.setFont(useFont)
    self.configMinorTickLabel.setText('minor')
    self.configMinorTickLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.configMinorTickLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.Layout_configMinorTickBox.addWidget(self.configMinorTickLabel)

    if(not self.secondAxes):
      self.configMinorTickXLabel = QtWidgets.QLabel('x')
      self.configMinorTickXLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configMinorTickXLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configMinorTickBox.addWidget(self.configMinorTickXLabel)
      self.configMinorTickX = QComboBoxMac()
      for entry in [str(i) for i in range(10)]:
        self.configMinorTickX.addItem(str(entry))
      self.configMinorTickX.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.configMinorTickX.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configMinorTickBox.addWidget(self.configMinorTickX)
  
    self.configMinorTickYLabel = QtWidgets.QLabel('y')
    self.configMinorTickYLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
    self.configMinorTickYLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
    self.Layout_configMinorTickBox.addWidget(self.configMinorTickYLabel)
    self.configMinorTickY = QComboBoxMac()
    for entry in [str(i) for i in range(10)]:
      self.configMinorTickY.addItem(str(entry))
    self.configMinorTickY.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
    self.configMinorTickY.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
    self.Layout_configMinorTickBox.addWidget(self.configMinorTickY)
  
    if(not self.secondAxes):
      self.configMinorTickResidLabel = QtWidgets.QLabel('resid')
      self.configMinorTickResidLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configMinorTickResidLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configMinorTickBox.addWidget(self.configMinorTickResidLabel)
      self.configMinorTickResid = QComboBoxMac()
      for entry in [str(i) for i in range(10)]:
        self.configMinorTickResid.addItem(str(entry))
      self.configMinorTickResid.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.configMinorTickResid.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configMinorTickBox.addWidget(self.configMinorTickResid)
  
      self.configMinorTickRelativeLengthLabel = QtWidgets.QLabel('ratio')
      self.configMinorTickRelativeLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configMinorTickRelativeLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configMinorTickBox.addWidget(self.configMinorTickRelativeLengthLabel)
      self.configMinorTickRelativeLength = QLineEditClick()
      self.configMinorTickRelativeLength.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configMinorTickRelativeLength.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configMinorTickRelativeLength.setValidator(self.validFloat)
      self.Layout_configMinorTickBox.addWidget(self.configMinorTickRelativeLength)
    
    # tick mark config
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.configTickMarkBox = {}; self.Layout_configTickMark = {}
    self.configTickMarkLabel = {}
    self.configTickMarkWidthLabel = {}; self.configTickMarkWidth = {}
    self.configTickMarkLengthLabel = {}; self.configTickMarkLength = {}
    self.configTickMarkDirection = {}; self.configTickMarkColor = {}
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configTickMarkBox[axis] = QWidgetMac()
      self.vLayout.addWidget(self.configTickMarkBox[axis])
      self.Layout_configTickMark[axis] = QtWidgets.QHBoxLayout(self.configTickMarkBox[axis])
      self.Layout_configTickMark[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configTickMark[axis].setAlignment(QtCore.Qt.AlignLeft)

      self.configTickMarkLabel[axis] = QPushButtonCheckable()
      self.configTickMarkLabel[axis].setText('tick ' + axis)
      useFont = self.configTickMarkLabel[axis].font()
      useFont.setBold(True)
      self.configTickMarkLabel[axis].setFont(useFont)
      self.configTickMarkLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configTickMarkLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkLabel[axis])

      self.configTickMarkDirection[axis] = QComboBoxMac()
      self.directionstyles = ['in', 'out', 'inout']
      self.configTickMarkDirection[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configTickMarkDirection[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkDirection[axis])

      self.configTickMarkColor[axis] = QPushButtonMac()
      self.configTickMarkColor[axis].setAutoFillBackground(False)
      self.configTickMarkColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickMarkColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configTickMarkColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkColor[axis])
  
      self.configTickMarkWidthLabel[axis] = QtWidgets.QLabel('width')
      self.configTickMarkWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickMarkWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkWidthLabel[axis])
      self.configTickMarkWidth[axis] = QLineEditClick()
      self.configTickMarkWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickMarkWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickMarkWidth[axis].setValidator(self.validFloat)
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkWidth[axis])

      self.configTickMarkLengthLabel[axis] = QtWidgets.QLabel('length')
      self.configTickMarkLengthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configTickMarkLengthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkLengthLabel[axis])
      self.configTickMarkLength[axis] = QLineEditClick()
      self.configTickMarkLength[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickMarkLength[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configTickMarkLength[axis].setValidator(self.validFloat)
      self.Layout_configTickMark[axis].addWidget(self.configTickMarkLength[axis])

    # the inner situation
    if(not self.secondAxes):
      self.innerDividerLine = self.HLine()
      self.vLayout.addWidget(self.innerDividerLine)

      self.configInnerTickXBox = QWidgetMac()
      self.vLayout.addWidget(self.configInnerTickXBox)
      self.Layout_configInnerTickX = QtWidgets.QHBoxLayout(self.configInnerTickXBox)
      self.Layout_configInnerTickX.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerTickX.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerLabel = QPushButtonCheckable()
      useFont = self.configInnerLabel.font()
      useFont.setBold(True)
      self.configInnerLabel.setFont(useFont)
      self.configInnerLabel.setText('split_x')
      self.configInnerLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configInnerLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerTickX.addWidget(self.configInnerLabel)
      
      self.configInnerTickXAuto = QPushButtonMac()
      self.configInnerTickXAuto.setText('auto')
      self.configInnerTickXAuto.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configInnerTickXAuto.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerTickX.addWidget(self.configInnerTickXAuto)
          
      self.configInnerTickXEntry = QLineEditClick()
      self.configInnerTickXEntry.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerTickXEntry.setMaximumSize(QtCore.QSize(scaledDPI(224), scaledDPI(BASE_SIZE)))
      self.configInnerTickXEntry.setMinimumSize(QtCore.QSize(scaledDPI(224), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerTickX.addWidget(self.configInnerTickXEntry)
  
      self.configInnerTickUseData = QPushButtonMac()
      self.configInnerTickUseData.setText('use labels')
      self.configInnerTickUseData.setMaximumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.configInnerTickUseData.setMinimumSize(QtCore.QSize(scaledDPI(55), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerTickX.addWidget(self.configInnerTickUseData)

      # second row
      self.configInnerBox2 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configInnerBox2)
      self.vLayout.addWidget(self.configInnerBox2)
      self.Layout_configInnerBox2 = QtWidgets.QHBoxLayout(self.configInnerBox2)
      self.Layout_configInnerBox2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerBox2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(spacer)
      
      self.configInnerTickXFormatLabel = QtWidgets.QLabel('fmt')
      self.configInnerTickXFormatLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatLabel)
  
      self.configInnerTickXFormat = QComboBoxMac()
      self.configInnerTickXFormat.addItems(self.formatOptions)
      self.configInnerTickXFormat.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormat.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormat)
  
      self.configInnerTickXFormatPrecisionLabel = QtWidgets.QLabel('precision')
      self.configInnerTickXFormatPrecisionLabel.setMaximumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatPrecisionLabel.setMinimumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatPrecisionLabel)
  
      self.configInnerTickXFormatPrecision = QLineEditClick()
      self.configInnerTickXFormatPrecision.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatPrecision.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatPrecision.setValidator(self.validInt)
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatPrecision)

      self.configInnerTickXFormatTrailZero = QPushButtonCheckable()
      self.configInnerTickXFormatTrailZero.setText('trail zeros?')
      self.configInnerTickXFormatTrailZero.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatTrailZero.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatTrailZero)
  
      self.configInnerTickXFormatSeparator = QPushButtonCheckable()
      self.configInnerTickXFormatSeparator.setText('separate 1000s?')
      self.configInnerTickXFormatSeparator.setMaximumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
      self.configInnerTickXFormatSeparator.setMinimumSize(QtCore.QSize(scaledDPI(84), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox2.addWidget(self.configInnerTickXFormatSeparator)
      self.Layout_configInnerBox2.addStretch()
      
      # third row
      self.configInnerBox3 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configInnerBox3)
      self.vLayout.addWidget(self.configInnerBox3)
      self.Layout_configInnerBox3 = QtWidgets.QHBoxLayout(self.configInnerBox3)
      self.Layout_configInnerBox3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerBox3.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(spacer)
      
      self.configInnerTickXPrefixLabel = QtWidgets.QLabel('prefix')
      self.configInnerTickXPrefixLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configInnerTickXPrefixLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(self.configInnerTickXPrefixLabel)
      self.configInnerTickXPrefix = QLineEditClick()
      self.configInnerTickXPrefix.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerTickXPrefix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configInnerTickXPrefix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(self.configInnerTickXPrefix)

      self.configInnerTickXPostfixLabel = QtWidgets.QLabel('postfix')
      self.configInnerTickXPostfixLabel.setMaximumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
      self.configInnerTickXPostfixLabel.setMinimumSize(QtCore.QSize(scaledDPI(43), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(self.configInnerTickXPostfixLabel)
      self.configInnerTickXPostfix = QLineEditClick()
      self.configInnerTickXPostfix.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerTickXPostfix.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configInnerTickXPostfix.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox3.addWidget(self.configInnerTickXPostfix)      

      # fourth row
      self.configInnerBox = QWidgetMac()
      self.vLayout.addWidget(self.configInnerBox)
      self.Layout_configInnerBox = QtWidgets.QHBoxLayout(self.configInnerBox)
      self.Layout_configInnerBox.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerBox.setAlignment(QtCore.Qt.AlignLeft)
      spacer = QWidgetMac(self)
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox.addWidget(spacer)
  
      self.xSplitFractionLabel = QtWidgets.QLabel('fraction')
      self.Layout_configInnerBox.addWidget(self.xSplitFractionLabel)
      self.xSplitFraction = QLineEditClick()
      self.xSplitFraction.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.xSplitFraction.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.xSplitFraction.setValidator(self.validFloat)
      self.Layout_configInnerBox.addWidget(self.xSplitFraction)
          
      self.xSplitPadLabel = QtWidgets.QLabel('pad')
      self.Layout_configInnerBox.addWidget(self.xSplitPadLabel)
      self.xSplitPad = QLineEditClick()
      self.xSplitPad.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.xSplitPad.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.xSplitPad.setValidator(self.validFloat)
      self.Layout_configInnerBox.addWidget(self.xSplitPad)

      self.configInnerAxesLabel = QPushButtonCheckable()
      self.configInnerAxesLabel.setText('axes')
      self.configInnerAxesLabel.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configInnerAxesLabel.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox.addWidget(self.configInnerAxesLabel)

      self.configInnerTickLabel = QPushButtonCheckable()
      self.configInnerTickLabel.setText('ticks')
      self.configInnerTickLabel.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configInnerTickLabel.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerBox.addWidget(self.configInnerTickLabel)
      self.Layout_configInnerBox.addStretch()

      # 4th row
      self.configInnerMinorTickBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configInnerMinorTickBox)
      self.vLayout.addWidget(self.configInnerMinorTickBox)
      self.Layout_configInnerMinorTickBox = QtWidgets.QHBoxLayout(self.configInnerMinorTickBox)
      self.Layout_configInnerMinorTickBox.setContentsMargins(0, 0, 0, 0)
      self.Layout_configInnerMinorTickBox.setAlignment(QtCore.Qt.AlignLeft)
      self.configInnerMinorTickLabel = QtWidgets.QLabel()
      useFont = self.configInnerMinorTickLabel.font()
      useFont.setBold(True)
      self.configInnerMinorTickLabel.setFont(useFont)
      self.configInnerMinorTickLabel.setText('minor')
      self.configInnerMinorTickLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.configInnerMinorTickLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerMinorTickBox.addWidget(self.configInnerMinorTickLabel)
  
      self.configInnerMinorTickXLabel = QtWidgets.QLabel('x')
      self.configInnerMinorTickXLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configInnerMinorTickXLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerMinorTickBox.addWidget(self.configInnerMinorTickXLabel)
      self.configInnerMinorTickX = QComboBoxMac()
      for entry in [str(i) for i in range(10)]:
        self.configInnerMinorTickX.addItem(str(entry))
      self.configInnerMinorTickX.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.configInnerMinorTickX.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configInnerMinorTickBox.addWidget(self.configInnerMinorTickX)

      if(not self.parent.plotArea.splitShow):
        self.innerDividerLine.hide()
        self.configInnerBox.hide()
        self.configInnerTickXBox.hide()
        self.configInnerMinorTickBox.hide()

    # grid config
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.configGridBox = {}; self.Layout_configGrid = {}
    self.configGridLabel = {}
    self.configGridWidthLabel = {}; self.configGridWidth = {}
    self.configGridColor = {}; self.configGridStyle = {}
    self.configGridDashStyle = {}; self.configGridOrder = {}
    if(not self.secondAxes):
      useAxes = ['x', 'y', 'x2']
    else:
      useAxes = ['y2']
    for axis in useAxes:
      self.configGridBox[axis] = QWidgetMac()
      self.vLayout.addWidget(self.configGridBox[axis])
      self.Layout_configGrid[axis] = QtWidgets.QHBoxLayout(self.configGridBox[axis])
      self.Layout_configGrid[axis].setContentsMargins(0, 0, 0, 0)
      self.Layout_configGrid[axis].setAlignment(QtCore.Qt.AlignLeft)
      self.configGridLabel[axis] = QPushButtonCheckable()
      if(axis != 'x2'):
        self.configGridLabel[axis].setText('grid ' + axis)
      else:
        self.configGridLabel[axis].setText('grid split_x')
      useFont = self.configGridLabel[axis].font()
      useFont.setBold(True)
      self.configGridLabel[axis].setFont(useFont)
      self.configGridLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configGridLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridLabel[axis])

      self.orderstyles = ['front', 'back']
      self.configGridOrder[axis] = QComboBoxMac()
      self.configGridOrder[axis].setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configGridOrder[axis].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridOrder[axis])

      self.configGridColor[axis] = QPushButtonMac()
      self.configGridColor[axis].setAutoFillBackground(False)
      self.configGridColor[axis].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configGridColor[axis].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configGridColor[axis].setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configGrid[axis].addWidget(self.configGridColor[axis])
  
      self.configGridWidthLabel[axis] = QtWidgets.QLabel('width')
      self.configGridWidthLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configGridWidthLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridWidthLabel[axis])
      self.configGridWidth[axis] = QLineEditClick()
      self.configGridWidth[axis].setText(str(self.parent.plotArea.gridWidth[axis]))
      self.configGridWidth[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configGridWidth[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configGridWidth[axis].setValidator(self.validFloat)
      self.Layout_configGrid[axis].addWidget(self.configGridWidth[axis])

      self.configGridStyle[axis] = QComboBoxMac()
      self.configGridStyle[axis].setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configGridStyle[axis].setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridStyle[axis])

      self.configGridDashStyle[axis] = QComboBoxMac()
      self.advancedGraphicsSettings.append(self.configGridDashStyle[axis])
      self.configGridDashStyle[axis].setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.configGridDashStyle[axis].setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.Layout_configGrid[axis].addWidget(self.configGridDashStyle[axis])

    if((not self.parent.plotArea.splitShow) and ('x2' in self.configGridBox)):
      self.configGridBox['x2'].hide()

        # legend config
    if(not self.secondAxes):
      self.placementstyles = 'best;upper right;upper left;lower left;lower right;right;center left;center right;lower center;upper center;center'.split(';')
      blah = self.HLine()
      self.vLayout.addWidget(blah)
      self.configLegendBox = QWidgetMac()
      self.vLayout.addWidget(self.configLegendBox)
      self.Layout_configLegend = QtWidgets.QHBoxLayout(self.configLegendBox)
      self.Layout_configLegend.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend.setAlignment(QtCore.Qt.AlignLeft)
      
      self.configLegendLabel = QPushButtonCheckable()
      self.configLegendLabel.setText('legend')
      useFont = self.configLegendLabel.font()
      useFont.setBold(True)
      self.configLegendLabel.setFont(useFont)
      self.configLegendLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configLegendLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend.addWidget(self.configLegendLabel)
  
      self.configLegendPlacement = QComboBoxMac()
      self.configLegendPlacement.addItems(self.placementstyles)
      self.configLegendPlacement.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.configLegendPlacement.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend.addWidget(self.configLegendPlacement)
  
      self.configLegendColor = {}; self.configLegendColorLabel = {}
      for prop in ['face', 'edge']:
        if(prop == 'face'):
          self.configLegendColorLabel[prop] = QPushButtonCheckable()
          self.configLegendColorLabel[prop].setText(prop)
          self.configLegendColorLabel[prop].setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
        else:
          self.configLegendColorLabel[prop] = QtWidgets.QLabel(prop)
          self.configLegendColorLabel[prop].setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
        self.Layout_configLegend.addWidget(self.configLegendColorLabel[prop])
        self.configLegendColor[prop] = QPushButtonMac()
        self.configLegendColor[prop].setAutoFillBackground(False)
        self.configLegendColor[prop].setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configLegendColor[prop].setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
        self.configLegendColor[prop].setCursor(QtCore.Qt.PointingHandCursor)
        self.Layout_configLegend.addWidget(self.configLegendColor[prop])
  
      self.configLegendEdgeWidthLabel = QtWidgets.QLabel('width')
      self.configLegendEdgeWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend.addWidget(self.configLegendEdgeWidthLabel)
      self.configLegendEdgeWidth = QLineEditClick()
      self.configLegendEdgeWidth.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendEdgeWidth.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendEdgeWidth.setValidator(self.validFloat)
      self.Layout_configLegend.addWidget(self.configLegendEdgeWidth)
   
      self.configLegendShadowLabel = QPushButtonCheckable()
      self.configLegendShadowLabel.setText('shadow')
      self.configLegendShadowLabel.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configLegendShadowLabel.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend.addWidget(self.configLegendShadowLabel)
      self.Layout_configLegend.addStretch()
  
      self.configLegendBox2 = QWidgetMac()
      self.vLayout.addWidget(self.configLegendBox2)
      self.Layout_configLegend2 = QtWidgets.QHBoxLayout(self.configLegendBox2)
      self.Layout_configLegend2.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend2.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend2.addWidget(spacer)
      
      self.configLegendSizeLabel = QtWidgets.QLabel('font')
      self.configLegendSizeLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configLegendSizeLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend2.addWidget(self.configLegendSizeLabel)
      self.configLegendLabelColor = QPushButtonMac()
      self.configLegendLabelColor.setAutoFillBackground(False)
      self.configLegendLabelColor.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendLabelColor.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendLabelColor.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configLegend2.addWidget(self.configLegendLabelColor)
  
      self.configLegendLabelSize = QLineEditClick()
      self.configLegendLabelSize.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendLabelSize.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendLabelSize.setValidator(self.validFloat)
      self.Layout_configLegend2.addWidget(self.configLegendLabelSize)
  
      self.configLegendLabelBold = QPushButtonCheckable()
      self.configLegendLabelBold.setText('B')
      self.configLegendLabelBold.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendLabelBold.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configLegendLabelBold.font()
      useFont.setWeight(75)
      self.configLegendLabelBold.setFont(useFont)
      self.Layout_configLegend2.addWidget(self.configLegendLabelBold)
        
      self.configLegendLabelItalic = QPushButtonCheckable()
      self.configLegendLabelItalic.setText('I')
      self.configLegendLabelItalic.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configLegendLabelItalic.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      useFont = self.configLegendLabelItalic.font()
      useFont.setItalic(True)
      self.configLegendLabelItalic.setFont(useFont)
      self.Layout_configLegend2.addWidget(self.configLegendLabelItalic)
  
      self.configLegendLabelFont = QComboBoxMac()
      self.configLegendLabelFont.addItems(self.parent.fontNames)
      self.configLegendLabelFont.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
      self.configLegendLabelFont.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend2.addWidget(self.configLegendLabelFont)
  
      self.configLegendBox3 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configLegendBox3)
      self.vLayout.addWidget(self.configLegendBox3)
      self.Layout_configLegend3 = QtWidgets.QHBoxLayout(self.configLegendBox3)
      self.Layout_configLegend3.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend3.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(spacer)
      
      self.configLegendNColLabel = QtWidgets.QLabel('#cols')
      self.configLegendNColLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configLegendNColLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendNColLabel)
      self.configLegendNCol = QComboBoxMac()
      for entry in [str(i + 1) for i in range(10)]:
        self.configLegendNCol.addItem(str(entry))
      self.configLegendNCol.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.configLegendNCol.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendNCol)
  
      self.configLegendMarkerFirstLabel = QPushButtonCheckable()
      self.configLegendMarkerFirstLabel.setText('mark. 1st')
      self.configLegendMarkerFirstLabel.setMaximumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerFirstLabel.setMinimumSize(QtCore.QSize(scaledDPI(54), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendMarkerFirstLabel)
      # disable this control on Linux platforms
      if(platform in ['linux', 'darwin']):
        self.configLegendMarkerFirstLabel.hide()
  
      self.configLegendMarkerScaleLabel = QtWidgets.QLabel('scale')
      self.configLegendMarkerScaleLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerScaleLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendMarkerScaleLabel)
      self.configLegendMarkerScale = QLineEditClick()
      self.configLegendMarkerScale.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerScale.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerScale.setValidator(self.validFloat)
      self.Layout_configLegend3.addWidget(self.configLegendMarkerScale)
  
      self.configLegendMarkerNumPointsLabel = QtWidgets.QLabel('#pts')
      self.configLegendMarkerNumPointsLabel.setMaximumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerNumPointsLabel.setMinimumSize(QtCore.QSize(scaledDPI(24), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendMarkerNumPointsLabel)
      self.configLegendMarkerNumPoints = QComboBoxMac()
      for entry in [str(i + 1) for i in range(10)]:
        self.configLegendMarkerNumPoints.addItem(str(entry))
      self.configLegendMarkerNumPoints.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.configLegendMarkerNumPoints.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend3.addWidget(self.configLegendMarkerNumPoints)
  
      self.configLegendBox4 = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configLegendBox4)
      self.vLayout.addWidget(self.configLegendBox4)
      self.Layout_configLegend4 = QtWidgets.QHBoxLayout(self.configLegendBox4)
      self.Layout_configLegend4.setContentsMargins(0, 0, 0, 0)
      self.Layout_configLegend4.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(spacer)
      
      self.configLegendPadLabel = QtWidgets.QLabel('pad')
      self.configLegendPadLabel.setMaximumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.configLegendPadLabel.setMinimumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(self.configLegendPadLabel)
      self.configLegendPadBorderLabel = QtWidgets.QLabel('border')
      self.configLegendPadBorderLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configLegendPadBorderLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(self.configLegendPadBorderLabel)
      self.configLegendPadBorder = QLineEditClick()
      self.configLegendPadBorder.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadBorder.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadBorder.setValidator(self.validFloat)
      self.Layout_configLegend4.addWidget(self.configLegendPadBorder)
      
      self.configLegendPadRowLabel = QtWidgets.QLabel('rows')
      self.configLegendPadRowLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configLegendPadRowLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(self.configLegendPadRowLabel)
      self.configLegendPadRow = QLineEditClick()
      self.configLegendPadRow.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadRow.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadRow.setValidator(self.validFloat)
      self.Layout_configLegend4.addWidget(self.configLegendPadRow)
      
      self.configLegendPadColLabel = QtWidgets.QLabel('cols')
      self.configLegendPadColLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.configLegendPadColLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configLegend4.addWidget(self.configLegendPadColLabel)
      self.configLegendPadCol = QLineEditClick()
      self.configLegendPadCol.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadCol.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configLegendPadCol.setValidator(self.validFloat)
      self.Layout_configLegend4.addWidget(self.configLegendPadCol)

    # canvas config
    if(not self.secondAxes):
      blah = self.HLine()
      self.vLayout.addWidget(blah)
      self.configCanvasBox = QWidgetMac()
      self.vLayout.addWidget(self.configCanvasBox)
      self.Layout_configCanvas = QtWidgets.QHBoxLayout(self.configCanvasBox)
      self.Layout_configCanvas.setContentsMargins(0, 0, 0, 0)
      self.Layout_configCanvas.setAlignment(QtCore.Qt.AlignLeft)
      
      self.configFigureLabel = QPushButtonCheckable()
      self.configFigureLabel.setText('figure')
      useFont = self.configFigureLabel.font()
      useFont.setBold(True)
      self.configFigureLabel.setFont(useFont)
      self.configFigureLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configFigureLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configCanvas.addWidget(self.configFigureLabel)
      self.configFigureColorButton = QPushButtonMac()
      self.configFigureColorButton.setAutoFillBackground(False)
      self.configFigureColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configFigureColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configFigureColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configCanvas.addWidget(self.configFigureColorButton)
  
      self.configCanvasLabel = QPushButtonCheckable()
      self.configCanvasLabel.setText('canvas')
      self.configCanvasLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configCanvasLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configCanvas.addWidget(self.configCanvasLabel)
      self.configCanvasColorButton = QPushButtonMac()
      self.configCanvasColorButton.setAutoFillBackground(False)
      self.configCanvasColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configCanvas.addWidget(self.configCanvasColorButton)

      # canvas gradient
      self.canvasGradientBox = QWidgetMac()
      self.vLayout.addWidget(self.canvasGradientBox)
      self.Layout_canvasGradient = QtWidgets.QHBoxLayout(self.canvasGradientBox)
      self.Layout_canvasGradient.setContentsMargins(0, 0, 0, 0)
      self.Layout_canvasGradient.setAlignment(QtCore.Qt.AlignLeft)
      self.advancedGraphicsSettings.append(self.canvasGradientBox)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(spacer)

      self.configCanvasGradientLabel = QPushButtonCheckable()
      self.configCanvasGradientLabel.setText('gradient')
      self.configCanvasGradientLabel.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientLabel.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientLabel)

      self.configCanvasGradientStyle = QComboBoxMac()
      self.configCanvasGradientStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      for entry in ['linear', 'radial']:
        self.configCanvasGradientStyle.addItem(str(entry))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientStyle)

      self.configCanvasGradientColor1Button = QPushButtonMac()
      self.configCanvasGradientColor1Button.setAutoFillBackground(False)
      self.configCanvasGradientColor1Button.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasGradientColor1Button.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasGradientColor1Button.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientColor1Button)  
      self.configCanvasGradientColor2Button = QPushButtonMac()
      self.configCanvasGradientColor2Button.setAutoFillBackground(False)
      self.configCanvasGradientColor2Button.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasGradientColor2Button.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configCanvasGradientColor2Button.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientColor2Button)  

      self.configCanvasGradientAngleLabel = QtWidgets.QLabel('angle')
      self.configCanvasGradientAngleLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientAngleLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientAngleLabel)
      self.configCanvasGradientAngle = QLineEditClick()
      self.configCanvasGradientAngle.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientAngle.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientAngle.setValidator(self.validFloat)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientAngle)

      self.configCanvasGradientCenterLabel = QtWidgets.QLabel('center')
      self.configCanvasGradientCenterLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientCenterLabel)
      self.configCanvasGradientCenterX = QLineEditClick()
      self.configCanvasGradientCenterX.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterX.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterX.setValidator(self.validFloat)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientCenterX)
      self.configCanvasGradientCenterY = QLineEditClick()
      self.configCanvasGradientCenterY.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterY.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientCenterY.setValidator(self.validFloat)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientCenterY)
      
      self.configCanvasGradientWidthLabel = QtWidgets.QLabel('width')
      self.configCanvasGradientWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(26), scaledDPI(BASE_SIZE)))
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientWidthLabel)
      self.configCanvasGradientWidth = QLineEditClick()
      self.configCanvasGradientWidth.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientWidth.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configCanvasGradientWidth.setValidator(self.validFloat)
      self.Layout_canvasGradient.addWidget(self.configCanvasGradientWidth)

      # canvas dimensions
      self.exportSizeBox = QWidgetMac()
      self.vLayout.addWidget(self.exportSizeBox)
      self.Layout_exportSize = QtWidgets.QHBoxLayout(self.exportSizeBox)
      self.Layout_exportSize.setContentsMargins(0, 0, 0, 0)
      self.Layout_exportSize.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(spacer)
      
      self.exportSizeBaseLabel = QtWidgets.QLabel('fig.')
      self.exportSizeBaseLabel.setMaximumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.exportSizeBaseLabel.setMinimumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(self.exportSizeBaseLabel)
      self.exportSizeXLabel = QtWidgets.QLabel('width')
      self.exportSizeXLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.exportSizeXLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(self.exportSizeXLabel)
      self.exportSizeX = QLineEditClick()
      self.exportSizeX.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.exportSizeX.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.exportSizeX.setValidator(self.validFloat)
      self.Layout_exportSize.addWidget(self.exportSizeX)
      self.exportSizeYLabel = QtWidgets.QLabel('height')
      self.exportSizeYLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.exportSizeYLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(self.exportSizeYLabel)
      self.exportSizeY = QLineEditClick()
      self.exportSizeY.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.exportSizeY.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.exportSizeY.setValidator(self.validFloat)
      self.Layout_exportSize.addWidget(self.exportSizeY)
      self.exportSizeCurrentButton = QPushButtonMac()
      self.exportSizeCurrentButton.setText('Use screen')
      self.exportSizeCurrentButton.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.exportSizeCurrentButton.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
      self.Layout_exportSize.addWidget(self.exportSizeCurrentButton)
      
      # pad graphics
      self.exportPadBox = QWidgetMac()
      self.vLayout.addWidget(self.exportPadBox)
      self.Layout_exportPad = QtWidgets.QHBoxLayout(self.exportPadBox)
      self.Layout_exportPad.setContentsMargins(0, 0, 0, 0)
      self.Layout_exportPad.setAlignment(QtCore.Qt.AlignLeft)
  
      spacer = QtWidgets.QLabel()
      spacer.setMaximumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      spacer.setMinimumSize(QtCore.QSize(scaledDPI(4), scaledDPI(BASE_SIZE)))
      self.Layout_exportPad.addWidget(spacer)
  
      self.exportPadLabelMain = QtWidgets.QLabel('pad')
      self.exportPadLabelMain.setMaximumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.exportPadLabelMain.setMinimumSize(QtCore.QSize(scaledDPI(18), scaledDPI(BASE_SIZE)))
      self.Layout_exportPad.addWidget(self.exportPadLabelMain)
  
      self.exportPadLabel = {}; self.exportPadEntry = {}
      for axis in ['bottom', 'top', 'left', 'right']:
        self.exportPadLabel[axis] = QtWidgets.QLabel(axis)
        self.exportPadLabel[axis].setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
        self.exportPadLabel[axis].setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
        self.Layout_exportPad.addWidget(self.exportPadLabel[axis])
  
        self.exportPadEntry[axis] = QLineEditClick()
        self.exportPadEntry[axis].setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.exportPadEntry[axis].setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
        self.exportPadEntry[axis].setValidator(self.validFloat)
        self.Layout_exportPad.addWidget(self.exportPadEntry[axis])
      
      # format frame
      self.configFrameBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configFrameBox)
      self.vLayout.addWidget(self.configFrameBox)
      self.Layout_configFrame = QtWidgets.QHBoxLayout(self.configFrameBox)
      self.Layout_configFrame.setContentsMargins(0, 0, 0, 0)
      self.Layout_configFrame.setAlignment(QtCore.Qt.AlignLeft)
      
      self.configFrameLabel = QPushButtonCheckable()
      self.configFrameLabel.setText('frame')
      useFont = self.configFrameLabel.font()
      useFont.setBold(True)
      self.configFrameLabel.setFont(useFont)
      self.configFrameLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configFrameLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(self.configFrameLabel)
      
      self.configFrameColor = QPushButtonMac()
      self.configFrameColor.setAutoFillBackground(False)
      self.configFrameColor.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configFrameColor.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configFrameColor.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configFrame.addWidget(self.configFrameColor)
    
      self.configFrameWidthLabel = QtWidgets.QLabel('width')
      self.configFrameWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configFrameWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(self.configFrameWidthLabel)
      self.configFrameWidth = QLineEditClick()
      self.configFrameWidth.setText(str(self.parent.plotArea.frameWidth))
      self.configFrameWidth.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configFrameWidth.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configFrameWidth.setValidator(self.validFloat)
      self.Layout_configFrame.addWidget(self.configFrameWidth)
  
      self.configFrameStyle = QComboBoxMac()
      self.configFrameStyle.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.configFrameStyle.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(self.configFrameStyle)
  
      self.configFrameDashStyle = QComboBoxMac()
      self.configFrameDashStyle.setMinimumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.configFrameDashStyle.setMaximumSize(QtCore.QSize(scaledDPI(70), scaledDPI(BASE_SIZE)))
      self.Layout_configFrame.addWidget(self.configFrameDashStyle)
    
    # xkcdify
    if(not self.secondAxes):
      blah = self.HLine()
      self.vLayout.addWidget(blah)
      self.configXkcdBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configXkcdBox)
      self.vLayout.addWidget(self.configXkcdBox)
      self.Layout_configXkcd = QtWidgets.QHBoxLayout(self.configXkcdBox)
      self.Layout_configXkcd.setContentsMargins(0, 0, 0, 0)
      self.Layout_configXkcd.setAlignment(QtCore.Qt.AlignLeft)

      self.configXkcdLabel = QPushButtonCheckable()
      self.configXkcdLabel.setText('xkcdify')
      useFont = self.configXkcdLabel.font()
      useFont.setBold(True)
      self.configXkcdLabel.setFont(useFont)
      self.configXkcdLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configXkcdLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configXkcd.addWidget(self.configXkcdLabel)
  
      self.xkcdScaleLabel = QtWidgets.QLabel('scale')
      self.xkcdScaleLabel.setMaximumSize(QtCore.QSize(scaledDPI(25), scaledDPI(BASE_SIZE)))
      self.xkcdScaleLabel.setMinimumSize(QtCore.QSize(scaledDPI(25), scaledDPI(BASE_SIZE)))
      self.Layout_configXkcd.addWidget(self.xkcdScaleLabel)
      self.xkcdScale = QLineEditClick()
      self.xkcdScale.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xkcdScale.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xkcdScale.setValidator(self.validFloat)
      self.Layout_configXkcd.addWidget(self.xkcdScale)
  
      self.xkcdLengthLabel = QtWidgets.QLabel('length')
      self.xkcdLengthLabel.setMaximumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.xkcdLengthLabel.setMinimumSize(QtCore.QSize(scaledDPI(33), scaledDPI(BASE_SIZE)))
      self.Layout_configXkcd.addWidget(self.xkcdLengthLabel)
      self.xkcdLength = QLineEditClick()
      self.xkcdLength.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xkcdLength.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xkcdLength.setValidator(self.validFloat)
      self.Layout_configXkcd.addWidget(self.xkcdLength)
  
      self.xkcdRandomLabel = QtWidgets.QLabel('random')
      self.xkcdRandomLabel.setMaximumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.xkcdRandomLabel.setMinimumSize(QtCore.QSize(scaledDPI(36), scaledDPI(BASE_SIZE)))
      self.Layout_configXkcd.addWidget(self.xkcdRandomLabel)
      self.xkcdRandom = QLineEditClick()
      self.xkcdRandom.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xkcdRandom.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.xkcdRandom.setValidator(self.validFloat)
      self.Layout_configXkcd.addWidget(self.xkcdRandom)
  
      # path effects -- stroke
      self.configPathEffectsBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configPathEffectsBox)
      self.vLayout.addWidget(self.configPathEffectsBox)
      self.Layout_configPathEffects = QtWidgets.QHBoxLayout(self.configPathEffectsBox)
      self.Layout_configPathEffects.setContentsMargins(0, 0, 0, 0)
      self.Layout_configPathEffects.setAlignment(QtCore.Qt.AlignLeft)

      self.configPathEffectsLabel = QPushButtonCheckable()
      self.configPathEffectsLabel.setText('outline')
      useFont = self.configPathEffectsLabel.font()
      useFont.setBold(True)
      self.configPathEffectsLabel.setFont(useFont)
      self.configPathEffectsLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configPathEffectsLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configPathEffects.addWidget(self.configPathEffectsLabel)
  
      self.configPathEffectsColorButton = QPushButtonMac()
      self.configPathEffectsColorButton.setAutoFillBackground(False)
      self.configPathEffectsColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configPathEffectsColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configPathEffectsColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configPathEffects.addWidget(self.configPathEffectsColorButton)
  
      self.configPathEffectsWidthLabel = QtWidgets.QLabel('width')
      self.configPathEffectsWidthLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configPathEffectsWidthLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configPathEffects.addWidget(self.configPathEffectsWidthLabel)
      self.configPathEffectsWidth = QLineEditClick()
      self.configPathEffectsWidth.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configPathEffectsWidth.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configPathEffectsWidth.setValidator(self.validFloat)
      self.Layout_configPathEffects.addWidget(self.configPathEffectsWidth)
   
      # path effects -- shadow
      self.configPathShadowBox = QWidgetMac()
      self.advancedGraphicsSettings.append(self.configPathShadowBox)
      self.vLayout.addWidget(self.configPathShadowBox)
      self.Layout_configPathShadow = QtWidgets.QHBoxLayout(self.configPathShadowBox)
      self.Layout_configPathShadow.setContentsMargins(0, 0, 0, 0)
      self.Layout_configPathShadow.setAlignment(QtCore.Qt.AlignLeft)

      self.configPathShadowLabel = QPushButtonCheckable()
      self.configPathShadowLabel.setText('shadow')
      useFont = self.configPathShadowLabel.font()
      useFont.setBold(True)
      self.configPathShadowLabel.setFont(useFont)
      self.configPathShadowLabel.setMaximumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.configPathShadowLabel.setMinimumSize(QtCore.QSize(scaledDPI(66), scaledDPI(BASE_SIZE)))
      self.Layout_configPathShadow.addWidget(self.configPathShadowLabel)
  
      self.configPathShadowColorButton = QPushButtonMac()
      self.configPathShadowColorButton.setAutoFillBackground(False)
      self.configPathShadowColorButton.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configPathShadowColorButton.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
      self.configPathShadowColorButton.setCursor(QtCore.Qt.PointingHandCursor)
      self.Layout_configPathShadow.addWidget(self.configPathShadowColorButton)
  
      self.configPathShadowOffXLabel = QtWidgets.QLabel('offX')
      self.configPathShadowOffXLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffXLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configPathShadow.addWidget(self.configPathShadowOffXLabel)
      self.configPathShadowOffX = QLineEditClick()
      self.configPathShadowOffX.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffX.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffX.setValidator(self.validFloat)
      self.Layout_configPathShadow.addWidget(self.configPathShadowOffX)
   
      self.configPathShadowOffYLabel = QtWidgets.QLabel('offY')
      self.configPathShadowOffYLabel.setMinimumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffYLabel.setMaximumSize(QtCore.QSize(scaledDPI(30), scaledDPI(BASE_SIZE)))
      self.Layout_configPathShadow.addWidget(self.configPathShadowOffYLabel)
      self.configPathShadowOffY = QLineEditClick()
      self.configPathShadowOffY.setMaximumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffY.setMinimumSize(QtCore.QSize(scaledDPI(32), scaledDPI(BASE_SIZE)))
      self.configPathShadowOffY.setValidator(self.validFloat)
      self.Layout_configPathShadow.addWidget(self.configPathShadowOffY)
      
    self.vLayout.addStretch()
 
    # export graphics
    if(not self.secondAxes):
      self.exportBox = QWidgetMac()
      self.vLayout_0.addWidget(self.exportBox)
      self.Layout_export = QtWidgets.QHBoxLayout(self.exportBox)
      self.Layout_export.setContentsMargins(0, 0, 0, 0)
      self.Layout_export.setAlignment(QtCore.Qt.AlignLeft)
      self.previewButton = QPushButtonMac()
      self.previewButton.setText('Preview')
      self.previewButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.previewButton.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.previewButton)
      self.exportButton = QPushButtonMac()
      self.exportButton.setText('Export graphics')
      self.exportButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.exportButton.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.exportButton)
      self.reportButton = QPushButtonMac()
      self.reportButton.setText('Create report')
      self.reportButton.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.reportButton.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.reportButton)
  
      # load/save style
      self.loadStyleSet = QPushButtonMac()
      self.loadStyleSet.setText('Open style')
      self.loadStyleSet.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.loadStyleSet.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.loadStyleSet)
      self.saveStyleSet = QPushButtonMac()
      self.saveStyleSet.setText('Save style')
      self.saveStyleSet.setMaximumSize(QtCore.QSize(scaledDPI(100), scaledDPI(BASE_SIZE)))
      self.saveStyleSet.setMinimumSize(QtCore.QSize(scaledDPI(75), scaledDPI(BASE_SIZE)))
      self.Layout_export.addWidget(self.saveStyleSet)

    # hide less frequent options
    for entry in self.advancedGraphicsSettings:
      if((not self.advancedExport['advancedGraphics']) and (hasattr(entry, 'hide'))):
        entry.hide()
        
  def visibilityCanvasGradientControls(self):
    # controls visibility of canvas control elements
    items1 = [self.configCanvasGradientAngleLabel, self.configCanvasGradientAngle]
    items2 = [self.configCanvasGradientCenterLabel, self.configCanvasGradientCenterX,
              self.configCanvasGradientCenterY, self.configCanvasGradientWidthLabel, self.configCanvasGradientWidth]

    # determine state
    if(self.configCanvasGradientStyle.currentText() == 'linear'):
      for entry in items1:
        entry.show()
      for entry in items2:
        entry.hide()
    else:
      for entry in items1:
        entry.hide()
      for entry in items2:
        entry.show()

  def updateFields(self, initialize=False):
    # updates all fields in entry mask
    defaultFont = 'DejaVu Sans'
    # x label config
    if(not self.secondAxes):
      self.configXLabel.setChecked(self.parent.plotArea.labelXShow)
      self.configXName.setText(self.parent.plotArea.labelX)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.labelXColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configXColorButton.setStyleSheet(colorstr)
      self.configXSize.setText(str(self.parent.plotArea.labelXSize))
      if(self.parent.plotArea.labelXWeight == 'bold'):
        self.configXBold.setChecked(True)
      else:
        self.configXBold.setChecked(False)
      if(self.parent.plotArea.labelXStyle == 'italic'):
        self.configXItalic.setChecked(True)
      else:
        self.configXItalic.setChecked(False)
      '''
      if(self.parent.plotArea.labelXVariant == 'small-caps'):
        self.configXVariant.setChecked(True)
      else:
        self.configXVariant.setChecked(False)
      '''
      if(self.parent.plotArea.axisFont['x'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.axisFont['x'])
        self.configXFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configXFont.setCurrentIndex(currindex)
        self.parent.plotArea.axisFont['x'] = defaultFont
      else:
        self.configXFont.setCurrentIndex(0)
      if(self.parent.plotArea.labelXAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.labelXAlignment)
        self.configXAlignment.setCurrentIndex(currindex)
      else:
        self.configXAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.labelXAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.labelXAlignmentVertical)
        self.configXAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configXAlignmentVertical.setCurrentIndex(0)
      self.configXPad.setText(str(self.parent.plotArea.labelXPad))
      self.configXPos.setText(str(self.parent.plotArea.labelXPos))
      self.configXAngle.setText(str(self.parent.plotArea.labelXAngle))

    # y label config
    if(not self.secondAxes):
      self.configYLabel.setChecked(self.parent.plotArea.labelYShow)
      self.configYName.setText(self.parent.plotArea.labelY)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.labelYColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configYColorButton.setStyleSheet(colorstr)
      self.configYSize.setText(str(self.parent.plotArea.labelYSize))
      if(self.parent.plotArea.labelYWeight == 'bold'):
        self.configYBold.setChecked(True)
      else:
        self.configYBold.setChecked(False)
      if(self.parent.plotArea.labelYStyle == 'italic'):
        self.configYItalic.setChecked(True)
      else:
        self.configYItalic.setChecked(False)
      '''
      if(self.parent.plotArea.labelYVariant == 'small-caps'):
        self.configYVariant.setChecked(True)
      else:
        self.configYVariant.setChecked(False)
      '''
      if(self.parent.plotArea.axisFont['y'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.axisFont['y'])
        self.configYFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configYFont.setCurrentIndex(currindex)
        self.parent.plotArea.axisFont['y'] = defaultFont
      else:
        self.configYFont.setCurrentIndex(0)
      if(self.parent.plotArea.labelYAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.labelYAlignment)
        self.configYAlignment.setCurrentIndex(currindex)
      else:
        self.configYAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.labelYAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.labelYAlignmentVertical)
        self.configYAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configYAlignmentVertical.setCurrentIndex(0)
      self.configYPad.setText(str(self.parent.plotArea.labelYPad))
      self.configYPos.setText(str(self.parent.plotArea.labelYPos))
      self.configYAngle.setText(str(self.parent.plotArea.labelYAngle))
    else:
      self.configYLabel.setChecked(self.parent.plotArea.labelY2Show)
      self.configYName.setText(self.parent.plotArea.labelY2)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.labelY2Color[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configYColorButton.setStyleSheet(colorstr)
      self.configYSize.setText(str(self.parent.plotArea.labelY2Size))
      if(self.parent.plotArea.labelY2Weight == 'bold'):
        self.configYBold.setChecked(True)
      else:
        self.configYBold.setChecked(False)
      if(self.parent.plotArea.labelY2Style == 'italic'):
        self.configYItalic.setChecked(True)
      else:
        self.configYItalic.setChecked(False)
      '''
      if(self.parent.plotArea.labelY2Variant == 'small-caps'):
        self.configYVariant.setChecked(True)
      else:
        self.configYVariant.setChecked(False)
      '''
      if(self.parent.plotArea.axisFont['y2'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.axisFont['y2'])
        self.configYFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configYFont.setCurrentIndex(currindex)
        self.parent.plotArea.axisFont['y2'] = defaultFont
      else:
        self.configYFont.setCurrentIndex(0)
      if(self.parent.plotArea.labelY2Alignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.labelY2Alignment)
        self.configYAlignment.setCurrentIndex(currindex)
      else:
        self.configYAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.labelY2AlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.labelY2AlignmentVertical)
        self.configYAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configYAlignmentVertical.setCurrentIndex(0)
      self.configYPad.setText(str(self.parent.plotArea.labelY2Pad))
      self.configYPos.setText(str(self.parent.plotArea.labelY2Pos))
      self.configYAngle.setText(str(self.parent.plotArea.labelY2Angle))

    # axis config
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configAxisLabel[axis].setChecked(self.parent.plotArea.axisVisible[axis])
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.axisColor[axis][0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configAxisColor[axis].setStyleSheet(colorstr)
      self.configAxisWidth[axis].setText(str(self.parent.plotArea.axisWidth[axis]))
      if(initialize):
        for entry in self.linestyles2:
          self.configAxisStyle[axis].addItem(entry)
      if(self.parent.plotArea.axisStyle[axis] in self.linestyles2):
        currindex = self.linestyles2.index(self.parent.plotArea.axisStyle[axis])
        self.configAxisStyle[axis].setCurrentIndex(currindex)
      else:
        self.configAxisStyle[axis].setCurrentIndex(0)
      if(initialize):
        for entry in self.dashstyles:
          self.configAxisDashStyle[axis].addItem(entry)
      if(self.parent.plotArea.axisDashStyle[axis] in self.dashstyles):
        currindex = self.dashstyles.index(self.parent.plotArea.axisDashStyle[axis])
        self.configAxisDashStyle[axis].setCurrentIndex(currindex)
      else:
        self.configAxisDashStyle[axis].setCurrentIndex(0)
      if(initialize):
        for entry in self.positionstyles:
          self.configAxisPosition[axis].addItem(entry)
      if(self.parent.plotArea.axisPosition[axis] in self.positionstyles):
        currindex = self.positionstyles.index(self.parent.plotArea.axisPosition[axis])
        self.configAxisPosition[axis].setCurrentIndex(currindex)
      else:
        self.configAxisPosition[axis].setCurrentIndex(0)
      self.configAxisPositionValue[axis].setText(str(self.parent.plotArea.axisPositionValue[axis]))
        
    # arrow config
    if(not self.secondAxes):
      for axis in ['x', 'y']:
        self.configArrowLabel[axis].setChecked(self.parent.plotArea.arrowVisible[axis])
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.arrowColor[axis][0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.configArrowLineColor[axis].setStyleSheet(colorstr)
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.arrowFill[axis][0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.configArrowFillColor[axis].setStyleSheet(colorstr)
        self.configArrowHeadLength[axis].setText(str(self.parent.plotArea.arrowHeadLength[axis]))
        self.configArrowHeadWidth[axis].setText(str(self.parent.plotArea.arrowHeadWidth[axis]))
        self.configArrowOverhang[axis].setText(str(self.parent.plotArea.arrowOverhang[axis]))
        self.configArrowOffset[axis].setText(str(self.parent.plotArea.arrowOffset[axis]))

    # x ticks config
    if(not self.secondAxes):
      self.configTickXLabel.setChecked(self.parent.plotArea.ticksXShow)
      tickstr = ', '.join([str(i) for i in self.parent.plotArea.ticksX])
      self.configTickXEntry.setText(tickstr)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.ticksXColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configTickXColorButton.setStyleSheet(colorstr)
      self.configTickXSize.setText(str(self.parent.plotArea.ticksXSize))
      if(self.parent.plotArea.ticksXWeight == 'bold'):
        self.configTickXBold.setChecked(True)
      else:
        self.configTickXBold.setChecked(False)
      if(self.parent.plotArea.ticksXStyle == 'italic'):
        self.configTickXItalic.setChecked(True)
      else:
        self.configTickXItalic.setChecked(False)
      self.configTickXAngle.setText(str(self.parent.plotArea.ticksXAngle))
      if(self.parent.plotArea.ticksXAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.ticksXAlignment)
        self.configTickXAlignment.setCurrentIndex(currindex)
      else:
        self.configTickXAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.ticksXAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.ticksXAlignmentVertical)
        self.configTickXAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configTickXAlignmentVertical.setCurrentIndex(0)
      self.configTickXPad.setText(str(self.parent.plotArea.ticksXPad))
      self.configTickXPad2.setText(str(self.parent.plotArea.ticksXPad2))
      if(self.parent.plotArea.tickFont['x'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.tickFont['x'])
        self.configTickXFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configTickXFont.setCurrentIndex(currindex)
        self.parent.plotArea.tickFont['x'] = defaultFont
      else:
        self.configTickXFont.setCurrentIndex(0)
      if(self.parent.plotArea.ticksXFormat in self.formatOptions):
        currindex = self.formatOptions.index(self.parent.plotArea.ticksXFormat)
        self.configTickXFormat.setCurrentIndex(currindex)
      else:
        self.configTickXFormat.setCurrentIndex(0)
      self.configTickXFormatPrecision.setText(str(self.parent.plotArea.ticksXFormatPrecision))
      self.configTickXFormatTrailZero.setChecked(self.parent.plotArea.ticksXFormatTrailZero)
      self.configTickXFormatSeparator.setChecked(self.parent.plotArea.ticksXFormatSeparator)
      self.configTickXPrefix.setText(str(self.parent.plotArea.ticksXFormatPrefix))
      self.configTickXPostfix.setText(str(self.parent.plotArea.ticksXFormatPostfix))
      self.updateTickFormatFields(axis='x', tickFormat=self.parent.plotArea.ticksXFormat)      

    # y ticks config
    if(not self.secondAxes):
      self.configTickYLabel.setChecked(self.parent.plotArea.ticksYShow)
      tickstr = ', '.join([str(i) for i in self.parent.plotArea.ticksY])
      self.configTickYEntry.setText(tickstr)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.ticksYColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configTickYColorButton.setStyleSheet(colorstr)
      self.configTickYSize.setText(str(self.parent.plotArea.ticksYSize))
      if(self.parent.plotArea.ticksYWeight == 'bold'):
        self.configTickYBold.setChecked(True)
      else:
        self.configTickYBold.setChecked(False)
      if(self.parent.plotArea.ticksYStyle == 'italic'):
        self.configTickYItalic.setChecked(True)
      else:
        self.configTickYItalic.setChecked(False)
      self.configTickYAngle.setText(str(self.parent.plotArea.ticksYAngle))
      if(self.parent.plotArea.ticksYAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.ticksYAlignment)
        self.configTickYAlignment.setCurrentIndex(currindex)
      else:
        self.configTickYAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.ticksYAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.ticksYAlignmentVertical)
        self.configTickYAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configTickYAlignmentVertical.setCurrentIndex(0)
      self.configTickYPad.setText(str(self.parent.plotArea.ticksYPad))
      self.configTickYPad2.setText(str(self.parent.plotArea.ticksYPad2))
      if(self.parent.plotArea.tickFont['y'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.tickFont['y'])
        self.configTickYFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configTickYFont.setCurrentIndex(currindex)
        self.parent.plotArea.tickFont['y'] = defaultFont
      else:
        self.configTickYFont.setCurrentIndex(0)
      if(self.parent.plotArea.ticksYFormat in self.formatOptions):
        currindex = self.formatOptions.index(self.parent.plotArea.ticksYFormat)
        self.configTickYFormat.setCurrentIndex(currindex)
      else:
        self.configTickYFormat.setCurrentIndex(0)
      self.configTickYFormatPrecision.setText(str(self.parent.plotArea.ticksYFormatPrecision))
      self.configTickYFormatTrailZero.setChecked(self.parent.plotArea.ticksYFormatTrailZero)
      self.configTickYFormatSeparator.setChecked(self.parent.plotArea.ticksYFormatSeparator)
      self.configTickYPrefix.setText(str(self.parent.plotArea.ticksYFormatPrefix))
      self.configTickYPostfix.setText(str(self.parent.plotArea.ticksYFormatPostfix))
      self.updateTickFormatFields(axis='y', tickFormat=self.parent.plotArea.ticksYFormat)      
    else:
      self.configTickYLabel.setChecked(self.parent.plotArea.ticksY2Show)
      tickstr = ', '.join([str(i) for i in self.parent.plotArea.ticksY2])
      self.configTickYEntry.setText(tickstr)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.ticksY2Color[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configTickYColorButton.setStyleSheet(colorstr)
      self.configTickYSize.setText(str(self.parent.plotArea.ticksY2Size))
      if(self.parent.plotArea.ticksY2Weight == 'bold'):
        self.configTickYBold.setChecked(True)
      else:
        self.configTickYBold.setChecked(False)
      if(self.parent.plotArea.ticksY2Style == 'italic'):
        self.configTickYItalic.setChecked(True)
      else:
        self.configTickYItalic.setChecked(False)
      self.configTickYAngle.setText(str(self.parent.plotArea.ticksY2Angle))
      if(self.parent.plotArea.ticksYAlignment in self.alignHorizontal):
        currindex = self.alignHorizontal.index(self.parent.plotArea.ticksY2Alignment)
        self.configTickYAlignment.setCurrentIndex(currindex)
      else:
        self.configTickYAlignment.setCurrentIndex(0)
      if(self.parent.plotArea.ticksYAlignmentVertical in self.alignVertical):
        currindex = self.alignVertical.index(self.parent.plotArea.ticksY2AlignmentVertical)
        self.configTickYAlignmentVertical.setCurrentIndex(currindex)
      else:
        self.configTickYAlignmentVertical.setCurrentIndex(0)
      self.configTickYPad.setText(str(self.parent.plotArea.ticksY2Pad))
      self.configTickYPad2.setText(str(self.parent.plotArea.ticksY2Pad2))
      if(self.parent.plotArea.tickFont['y2'] in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.tickFont['y2'])
        self.configTickYFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configTickYFont.setCurrentIndex(currindex)
        self.parent.plotArea.tickFont['y2'] = defaultFont
      else:
        self.configTickYFont.setCurrentIndex(0)
      if(self.parent.plotArea.ticksY2Format in self.formatOptions):
        currindex = self.formatOptions.index(self.parent.plotArea.ticksY2Format)
        self.configTickYFormat.setCurrentIndex(currindex)
      else:
        self.configTickYFormat.setCurrentIndex(0)
      self.configTickYFormatPrecision.setText(str(self.parent.plotArea.ticksY2FormatPrecision))
      self.configTickYFormatTrailZero.setChecked(self.parent.plotArea.ticksY2FormatTrailZero)
      self.configTickYFormatSeparator.setChecked(self.parent.plotArea.ticksY2FormatSeparator)
      self.configTickYPrefix.setText(str(self.parent.plotArea.ticksY2FormatPrefix))
      self.configTickYPostfix.setText(str(self.parent.plotArea.ticksY2FormatPostfix))
      self.updateTickFormatFields(axis='y2', tickFormat=self.parent.plotArea.ticksY2Format)      

    # y resid ticks config
    if(not self.secondAxes):
      self.configTickResidYLabel.setChecked(self.parent.plotArea.ticksResidYShow)
      tickstr = ', '.join([str(i) for i in self.parent.plotArea.ticksResidY])
      self.configTickResidYEntry.setText(tickstr)

    # minor ticks config
    if(not self.secondAxes):
      if((self.parent.plotArea.ticksXMinor - 1) in [i for i in range(10)]):
        self.configMinorTickX.setCurrentIndex(self.parent.plotArea.ticksXMinor - 1)
      else:
        self.configMinorTickX.setCurrentIndex(0)
      if((self.parent.plotArea.ticksYMinor - 1) in [i for i in range(10)]):
        self.configMinorTickY.setCurrentIndex(self.parent.plotArea.ticksYMinor - 1)
      else:
        self.configMinorTickY.setCurrentIndex(0)
      if((self.parent.plotArea.ticksResidYMinor - 1) in [i for i in range(10)]):
        self.configMinorTickResid.setCurrentIndex(self.parent.plotArea.ticksResidYMinor - 1)
      else:
        self.configMinorTickResid.setCurrentIndex(0)
      self.configMinorTickRelativeLength.setText(str(self.parent.plotArea.ticksMinorRelativeLength))
    else:
      if((self.parent.plotArea.ticksY2Minor - 1) in [i for i in range(10)]):
        self.configMinorTickY.setCurrentIndex(self.parent.plotArea.ticksY2Minor - 1)
      else:
        self.configMinorTickY.setCurrentIndex(0)

    # tick mark config
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configTickMarkLabel[axis].setChecked(self.parent.plotArea.ticksVisible[axis])
      if(initialize):
        for entry in self.directionstyles:
          self.configTickMarkDirection[axis].addItem(entry)
      if(self.parent.plotArea.ticksDirection[axis] in self.directionstyles):
        currindex = self.directionstyles.index(self.parent.plotArea.ticksDirection[axis])
        self.configTickMarkDirection[axis].setCurrentIndex(currindex)
      else:
        self.configTickMarkDirection[axis].setCurrentIndex(0)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.ticksColor[axis][0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configTickMarkColor[axis].setStyleSheet(colorstr)
      self.configTickMarkWidth[axis].setText(str(self.parent.plotArea.ticksWidth[axis]))
      self.configTickMarkLength[axis].setText(str(self.parent.plotArea.ticksLength[axis]))

    # inner situation config
    if(not self.secondAxes):
      self.xSplitFraction.setText(str(self.parent.formatNumber(self.parent.plotArea.splitFraction)))
      self.xSplitPad.setText(str(self.parent.formatNumber(self.parent.plotArea.splitPad)))

      self.configInnerAxesLabel.setChecked(self.parent.plotArea.innerAxes)
      self.configInnerTickLabel.setChecked(self.parent.plotArea.innerTicks)
        
      self.configInnerLabel.setChecked(self.parent.plotArea.ticksXShow_div)
      tickstr = ', '.join([str(i) for i in self.parent.plotArea.ticksX_div])
      self.configInnerTickXEntry.setText(tickstr)

      if(self.parent.plotArea.ticksXFormat_div in self.formatOptions):
        currindex = self.formatOptions.index(self.parent.plotArea.ticksXFormat_div)
        self.configInnerTickXFormat.setCurrentIndex(currindex)
      else:
        self.configInnerTickXFormat.setCurrentIndex(0)
      self.configInnerTickXFormatPrecision.setText(str(self.parent.plotArea.ticksXFormatPrecision_div))
      self.configInnerTickXFormatTrailZero.setChecked(self.parent.plotArea.ticksXFormatTrailZero_div)
      self.configInnerTickXFormatSeparator.setChecked(self.parent.plotArea.ticksXFormatSeparator_div)
      self.configInnerTickXPrefix.setText(str(self.parent.plotArea.ticksXFormatPrefix_div))
      self.configInnerTickXPostfix.setText(str(self.parent.plotArea.ticksXFormatPostfix_div))
      self.updateTickFormatFields(axis='x2', tickFormat=self.parent.plotArea.ticksXFormat_div)

      if((self.parent.plotArea.ticksXMinor_div - 1) in [i for i in range(10)]):
        self.configInnerMinorTickX.setCurrentIndex(self.parent.plotArea.ticksXMinor_div - 1)
      else:
        self.configInnerMinorTickX.setCurrentIndex(0)
      
    # grid config
    if(not self.secondAxes):
      useAxes = ['x', 'y', 'x2']
    else:
      useAxes = ['y2']
    for axis in useAxes:
      self.configGridLabel[axis].setChecked(self.parent.plotArea.gridVisible[axis])
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.gridColor[axis][0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configGridColor[axis].setStyleSheet(colorstr)
      self.configGridWidth[axis].setText(str(self.parent.plotArea.gridWidth[axis]))
      useLineStyle = [i for i in self.linestyles if (i != 'None')]
      if(initialize):
        for entry in useLineStyle:
          self.configGridStyle[axis].addItem(entry)
      if(self.parent.plotArea.gridStyle[axis] in useLineStyle):
        currindex = useLineStyle.index(self.parent.plotArea.gridStyle[axis])
        self.configGridStyle[axis].setCurrentIndex(currindex)
      else:
        self.configGridStyle[axis].setCurrentIndex(0)
      if(initialize):
        for entry in self.dashstyles:
          self.configGridDashStyle[axis].addItem(entry)
      if(self.parent.plotArea.gridDashStyle[axis] in self.dashstyles):
        currindex = self.dashstyles.index(self.parent.plotArea.gridDashStyle[axis])
        self.configGridDashStyle[axis].setCurrentIndex(currindex)
      else:
        self.configGridDashStyle[axis].setCurrentIndex(0)
      if(initialize):
        for entry in self.orderstyles:
          self.configGridOrder[axis].addItem(entry)
      if(self.parent.plotArea.gridOrder[axis] in self.orderstyles):
        currindex = self.orderstyles.index(self.parent.plotArea.gridOrder[axis])
        self.configGridOrder[axis].setCurrentIndex(currindex)
      else:
        self.configGridOrder[axis].setCurrentIndex(0)

    # legend config
    if(not self.secondAxes):
      self.configLegendLabel.setChecked(self.parent.plotArea.legendVisible)
      if(self.parent.plotArea.legendPlacement in self.placementstyles):
        currindex = self.placementstyles.index(self.parent.plotArea.legendPlacement)
        self.configLegendPlacement.setCurrentIndex(currindex)
      else:
        self.configLegendPlacement.setCurrentIndex(0)
      for prop in ['face', 'edge']:
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.legendColor[prop]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.configLegendColor[prop].setStyleSheet(colorstr)
      self.configLegendColorLabel['face'].blockSignals(True)
      self.configLegendColorLabel['face'].setChecked(self.parent.plotArea.legendFill)
      self.configLegendColorLabel['face'].blockSignals(False)
      self.configLegendEdgeWidth.setText(str(self.parent.plotArea.legendEdgeWidth))
      self.configLegendShadowLabel.setChecked(self.parent.plotArea.legendShadow)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.legendLabelColor]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configLegendLabelColor.setStyleSheet(colorstr)
      self.configLegendLabelSize.setText(str(self.parent.plotArea.legendLabelSize))
      if(self.parent.plotArea.legendLabelWeight == 'bold'):
        self.configLegendLabelBold.setChecked(True)
      else:
        self.configLegendLabelBold.setChecked(False)
      if(self.parent.plotArea.legendLabelStyle == 'italic'):
        self.configLegendLabelItalic.setChecked(True)
      else:
        self.configLegendLabelItalic.setChecked(False)
      if(self.parent.plotArea.legendLabelFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(self.parent.plotArea.legendLabelFont)
        self.configLegendLabelFont.setCurrentIndex(currindex)
      elif(defaultFont in self.parent.fontNames):
        currindex = self.parent.fontNames.index(defaultFont)
        self.configLegendLabelFont.setCurrentIndex(currindex)
        self.parent.plotArea.legendLabelFont = defaultFont
      else:
        self.configLegendLabelFont.setCurrentIndex(0)
      if(self.parent.plotArea.legendNumPoints in [(i+1) for i in range(10)]):
        self.configLegendMarkerNumPoints.setCurrentIndex(self.parent.plotArea.legendNumPoints - 1)
      else:
        self.configLegendMarkerNumPoints.setCurrentIndex(0)
      if(self.parent.plotArea.legendMarkerFirst):
        self.configLegendMarkerFirstLabel.setChecked(True)
      else:
        self.configLegendMarkerFirstLabel.setChecked(False)
      self.configLegendMarkerScale.setText(str(self.parent.plotArea.legendMarkerScale))
      if(self.parent.plotArea.legendNumCol in [(i+1) for i in range(10)]):
        self.configLegendNCol.setCurrentIndex(self.parent.plotArea.legendNumCol - 1)
      else:
        self.configLegendNCol.setCurrentIndex(0)
      self.configLegendPadBorder.setText(str(self.parent.plotArea.legendBorderPad))
      self.configLegendPadRow.setText(str(self.parent.plotArea.legendLabelSpacing))
      self.configLegendPadCol.setText(str(self.parent.plotArea.legendColumnSpacing))

    # canvas config
    if(not self.secondAxes):
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.figureColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configFigureColorButton.setStyleSheet(colorstr)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.canvasColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configCanvasColorButton.setStyleSheet(colorstr)
      
      # canvas and figure fill?
      self.configFigureLabel.setChecked(self.parent.plotArea.figureFill)
      self.configCanvasLabel.setChecked(self.parent.plotArea.canvasFill)
      self.configFrameLabel.setChecked(self.parent.plotArea.frameDraw)
      
      # canvas gradient
      self.configCanvasGradientLabel.setChecked(self.parent.plotArea.canvasGradientVisible)
      
      if(self.parent.plotArea.canvasGradientStyle == 'radial'):
        self.configCanvasGradientStyle.setCurrentIndex(1)
      else:
        self.configCanvasGradientStyle.setCurrentIndex(0)
      # control visibility of canvas gradient controls
      self.visibilityCanvasGradientControls()
      
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.canvasGradientColor1[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configCanvasGradientColor1Button.setStyleSheet(colorstr)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.canvasGradientColor2[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configCanvasGradientColor2Button.setStyleSheet(colorstr)

      self.configCanvasGradientAngle.setText(str(self.parent.plotArea.canvasGradientAngle))
      self.configCanvasGradientCenterX.setText(str(self.parent.plotArea.canvasGradientCenter[0]))
      self.configCanvasGradientCenterY.setText(str(self.parent.plotArea.canvasGradientCenter[1]))
      self.configCanvasGradientWidth.setText(str(self.parent.plotArea.canvasGradientWidth))
      
      # canvas dimensions
      self.exportSizeX.setText(str(self.parent.plotArea.exportWidth))
      self.exportSizeY.setText(str(self.parent.plotArea.exportHeight))
      
      # pad graphics
      for axis in ['bottom', 'top', 'left', 'right']:
        self.exportPadEntry[axis].setText(str(self.parent.plotArea.padSize[axis]))
        
      # frame
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.frameColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configFrameColor.setStyleSheet(colorstr)
      self.configFrameWidth.setText(str(self.parent.plotArea.frameWidth))
      if(initialize):
        self.linestyles__ = [i for i in self.linestyles if (i != 'None')]
        for entry in self.linestyles__:
          self.configFrameStyle.addItem(entry)
      if(self.parent.plotArea.frameStyle in self.linestyles__):
        currindex = self.linestyles__.index(self.parent.plotArea.frameStyle)
        self.configFrameStyle.setCurrentIndex(currindex)
      else:
        self.configFrameStyle.setCurrentIndex(0)
      if(initialize):
        for entry in self.dashstyles:
          self.configFrameDashStyle.addItem(entry)
      if(self.parent.plotArea.frameDashStyle in self.dashstyles):
        currindex = self.dashstyles.index(self.parent.plotArea.frameDashStyle)
        self.configFrameDashStyle.setCurrentIndex(currindex)
      else:
        self.configGridDashStyle.setCurrentIndex(0)

    # xkcd
    if(not self.secondAxes):
      self.configXkcdLabel.setChecked(self.parent.plotArea.xkcd)
      self.xkcdScale.setText(str(self.parent.plotArea.xkcdScale))
      self.xkcdLength.setText(str(self.parent.plotArea.xkcdLength))
      self.xkcdRandom.setText(str(self.parent.plotArea.xkcdRandomness))
      
      # path effects
      self.configPathEffectsLabel.setChecked(self.parent.plotArea.applyPathStroke)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.pathStrokeColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configPathEffectsColorButton.setStyleSheet(colorstr)
      self.configPathEffectsWidth.setText(str(self.parent.plotArea.pathStrokeWidth))
  
      self.configPathShadowLabel.setChecked(self.parent.plotArea.applyPathShadow)
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.pathShadowColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configPathShadowColorButton.setStyleSheet(colorstr)
      self.configPathShadowOffX.setText(str(self.parent.plotArea.pathShadowX))
      self.configPathShadowOffY.setText(str(self.parent.plotArea.pathShadowY))
  
  def connectEvents(self):
    # connects all events in entry mask
    # x label config
    if(not self.secondAxes):
      self.configXLabel.clicked.connect(partial(self.toggleAxisLabel, 'x'))
      self.configXName.editingFinished.connect(partial(self.changeAxisLabel, 'x'))
      self.configXColorButton.clicked.connect(partial(self.changeAxisLabelColor, axis = 'x'))
      self.configXSize.editingFinished.connect(partial(self.changeAxisLabelSize, entryfield = self.configXSize, axis = 'x', minval = 0.0, maxval = 100.0))
      self.configXBold.clicked.connect(partial(self.changeAxisLabelBold, axis = 'x'))
      self.configXItalic.clicked.connect(partial(self.changeAxisLabelItalic, axis = 'x'))
      ###self.configXVariant.clicked.connect(partial(self.changeAxisLabelVariant, axis = 'x'))
      self.configXFont.activated.connect(partial(self.setAxisFont, axis = 'x'))
      self.configXAlignment.activated.connect(partial(self.setAxisLabelAlignment, axis = 'x'))
      self.configXAlignmentVertical.activated.connect(partial(self.setAxisLabelAlignmentVertical, axis = 'x'))
      self.configXPad.editingFinished.connect(partial(self.changeAxisLabelPad, entryfield = self.configXPad, axis = 'x', minval = -100.0, maxval = 100.0))
      self.configXPos.editingFinished.connect(partial(self.changeAxisLabelPos, entryfield = self.configXPos, axis = 'x', minval = -1, maxval = 10))
      self.configXAngle.editingFinished.connect(partial(self.changeAxisLabelAngle, entryfield = self.configXAngle, axis = 'x', minval = 0.0, maxval = 360.0))
    
    # y label config
    if(not self.secondAxes):
      targetAxis = 'y'
    else:
      targetAxis = 'y2'
    self.configYLabel.clicked.connect(partial(self.toggleAxisLabel, targetAxis))
    self.configYName.editingFinished.connect(partial(self.changeAxisLabel, targetAxis))
    self.configYColorButton.clicked.connect(partial(self.changeAxisLabelColor, axis = targetAxis))
    self.configYSize.editingFinished.connect(partial(self.changeAxisLabelSize, entryfield = self.configYSize, axis = targetAxis, minval = 0.0, maxval = 100.0))
    self.configYBold.clicked.connect(partial(self.changeAxisLabelBold, axis = targetAxis))
    self.configYItalic.clicked.connect(partial(self.changeAxisLabelItalic, axis = targetAxis))
    ###self.configYVariant.clicked.connect(partial(self.changeAxisLabelVariant, axis = targetAxis))
    self.configYFont.activated.connect(partial(self.setAxisFont, axis = targetAxis))
    self.configYAlignment.activated.connect(partial(self.setAxisLabelAlignment, axis = targetAxis))
    self.configYAlignmentVertical.activated.connect(partial(self.setAxisLabelAlignmentVertical, axis = targetAxis))
    self.configYPad.editingFinished.connect(partial(self.changeAxisLabelPad, entryfield = self.configYPad, axis = targetAxis, minval = -100.0, maxval = 100.0))
    self.configYPos.editingFinished.connect(partial(self.changeAxisLabelPos, entryfield = self.configYPos, axis = targetAxis, minval = -0.5, maxval = 1.5))
    self.configYAngle.editingFinished.connect(partial(self.changeAxisLabelAngle, entryfield = self.configYAngle, axis = targetAxis, minval = 0.0, maxval = 360.0))

    # axis config
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configAxisLabel[axis].clicked.connect(partial(self.setAxisVisibility, axis = axis))
      self.configAxisColor[axis].clicked.connect(partial(self.changeAxisColor, axis = axis))
      self.configAxisWidth[axis].editingFinished.connect(partial(self.changeAxisWidth, axis = axis, minval = 0.0, maxval = 100.0))
      self.configAxisStyle[axis].activated.connect(partial(self.setAxisStyle, axis = axis))
      self.configAxisDashStyle[axis].activated.connect(partial(self.setAxisDashStyle, axis = axis))
      self.configAxisPosition[axis].activated.connect(partial(self.setAxisPosition, axis = axis))
      self.configAxisPositionValue[axis].editingFinished.connect(partial(self.changeAxisPositionValue, axis = axis))
      self.configAxisPositionReset[axis].clicked.connect(partial(self.resetAxisPosition, axis = axis))

    # arrow config
    if(not self.secondAxes):
      for axis in ['x', 'y']:
        self.configArrowLabel[axis].clicked.connect(partial(self.setAxisArrow, axis = axis))
        self.configArrowLineColor[axis].clicked.connect(partial(self.changeArrowColor, axis = axis, item='line'))
        self.configArrowFillColor[axis].clicked.connect(partial(self.changeArrowColor, axis = axis, item='fill'))
        self.configArrowHeadWidth[axis].editingFinished.connect(partial(self.changeArrowHeadWidth, axis = axis, minval = 0.0, maxval = 1.0))
        self.configArrowHeadLength[axis].editingFinished.connect(partial(self.changeArrowHeadLength, axis = axis, minval = 0.0, maxval = 1.0))
        self.configArrowOverhang[axis].editingFinished.connect(partial(self.changeArrowOverhang, axis = axis, minval = -1.0, maxval = 1.0))
        self.configArrowOffset[axis].editingFinished.connect(partial(self.changeArrowOffset, axis = axis, minval = 0.0, maxval = 1.0))

    # x ticks config
    if(not self.secondAxes):
      self.configTickXLabel.clicked.connect(partial(self.toggleTicksLabel, 'x'))
      self.configTickXAuto.clicked.connect(partial(self.automaticAxisTicks, axis = 'x'))
      self.configTickXEntry.editingFinished.connect(partial(self.changeAxisTicks, 'x'))
      self.configTickUseData.clicked.connect(partial(self.dataAxisTicks, False))
      self.configTickXColorButton.clicked.connect(partial(self.changeTickLabelColor, axis = 'x'))
      self.configTickXSize.editingFinished.connect(partial(self.changeTickLabelSize, entryfield = self.configTickXSize, axis = 'x', minval = 0.0, maxval = 100.0))
      self.configTickXBold.clicked.connect(partial(self.changeTickLabelBold, axis = 'x'))
      self.configTickXItalic.clicked.connect(partial(self.changeTickLabelItalic, axis = 'x'))
      self.configTickXAngle.editingFinished.connect(partial(self.changeTickLabelAngle, entryfield = self.configTickXAngle, axis = 'x', minval = 0.0, maxval = 360.0))
      self.configTickXAlignment.activated.connect(partial(self.setTickLabelAlignment, axis = 'x'))
      self.configTickXAlignmentVertical.activated.connect(partial(self.setTickLabelAlignmentVertical, axis = 'x'))
      self.configTickXPad.editingFinished.connect(partial(self.changeTickLabelPad, entryfield = self.configTickXPad, axis = 'x', minval = -100.0, maxval = 100.0))
      self.configTickXPad2.editingFinished.connect(partial(self.changeTickLabelPad2, entryfield = self.configTickXPad2, axis = 'x', minval = -100.0, maxval = 100.0))
      self.configTickXFont.activated.connect(partial(self.setTickFont, axis = 'x'))
      self.configMinorTickX.activated.connect(partial(self.setMinorTick, axis = 'x'))
      self.configTickXFormat.activated.connect(partial(self.setTickFormat, entryfield = self.configTickXFormat, axis = 'x'))
      self.configTickXFormatPrecision.editingFinished.connect(partial(self.changeTickFormatPrecision, entryfield = self.configTickXFormatPrecision, axis = 'x', minval = 0, maxval = 20))
      self.configTickXFormatTrailZero.clicked.connect(partial(self.setFormatTrailZero, entryfield=self.configTickXFormatTrailZero, axis = 'x'))
      self.configTickXFormatSeparator.clicked.connect(partial(self.setFormatSeparator, entryfield=self.configTickXFormatSeparator, axis = 'x'))
      self.configTickXPrefix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configTickXPrefix, axis='x', prefix=True))
      self.configTickXPostfix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configTickXPostfix, axis='x', prefix=False))

    # y ticks config
    if(not self.secondAxes):
      targetAxis = 'y'
    else:
      targetAxis = 'y2'
    self.configTickYLabel.clicked.connect(partial(self.toggleTicksLabel, targetAxis))
    self.configTickYAuto.clicked.connect(partial(self.automaticAxisTicks, axis = targetAxis))
    self.configTickYEntry.editingFinished.connect(partial(self.changeAxisTicks, targetAxis))
    self.configTickYColorButton.clicked.connect(partial(self.changeTickLabelColor, axis = targetAxis))
    self.configTickYSize.editingFinished.connect(partial(self.changeTickLabelSize, entryfield = self.configTickYSize, axis = targetAxis, minval = 0.0, maxval = 100.0))
    self.configTickYBold.clicked.connect(partial(self.changeTickLabelBold, axis = targetAxis))
    self.configTickYItalic.clicked.connect(partial(self.changeTickLabelItalic, axis = targetAxis))
    self.configTickYAngle.editingFinished.connect(partial(self.changeTickLabelAngle, entryfield = self.configTickYAngle, axis = targetAxis, minval = 0.0, maxval = 360.0))
    self.configTickYAlignment.activated.connect(partial(self.setTickLabelAlignment, axis = targetAxis))
    self.configTickYAlignmentVertical.activated.connect(partial(self.setTickLabelAlignmentVertical, axis = targetAxis))
    self.configTickYPad.editingFinished.connect(partial(self.changeTickLabelPad, entryfield = self.configTickYPad, axis = targetAxis, minval = -100.0, maxval = 100.0))
    self.configTickYPad2.editingFinished.connect(partial(self.changeTickLabelPad2, entryfield = self.configTickYPad2, axis = targetAxis, minval = -100.0, maxval = 100.0))
    self.configTickYFont.activated.connect(partial(self.setTickFont, axis = targetAxis))
    self.configMinorTickY.activated.connect(partial(self.setMinorTick, axis = targetAxis))
    self.configTickYFormat.activated.connect(partial(self.setTickFormat, entryfield = self.configTickYFormat, axis = targetAxis))
    self.configTickYFormatPrecision.editingFinished.connect(partial(self.changeTickFormatPrecision, entryfield = self.configTickYFormatPrecision, axis = targetAxis, minval = 0, maxval = 20))
    self.configTickYFormatTrailZero.clicked.connect(partial(self.setFormatTrailZero, entryfield=self.configTickYFormatTrailZero, axis = targetAxis))
    self.configTickYFormatSeparator.clicked.connect(partial(self.setFormatSeparator, entryfield=self.configTickYFormatSeparator, axis = targetAxis))
    self.configTickYPrefix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configTickYPrefix, axis=targetAxis, prefix=True))
    self.configTickYPostfix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configTickYPostfix, axis=targetAxis, prefix=False))

    if(not self.secondAxes):
      self.configTickResidYLabel.clicked.connect(partial(self.toggleTicksLabel, 'resid'))
      self.configTickResidYAuto.clicked.connect(partial(self.automaticAxisTicks, axis = 'resid'))
      self.configTickResidYEntry.editingFinished.connect(partial(self.changeAxisTicks, 'resid'))
      self.configMinorTickResid.activated.connect(partial(self.setMinorTick, axis = 'resid'))
      self.configMinorTickRelativeLength.editingFinished.connect(partial(self.changeMinorTickRelativeLength, entryfield = self.configMinorTickRelativeLength, minval = 0.1, maxval = 10.0))
    
    # tick mark config
    if(not self.secondAxes):
      useAxes = ['bottom', 'top', 'left', 'right']
    else:
      useAxes = ['left2', 'right2']
    for axis in useAxes:
      self.configTickMarkLabel[axis].clicked.connect(partial(self.setTicksVisibility, axis = axis))
      self.configTickMarkDirection[axis].activated.connect(partial(self.setTickMarkDirection, axis = axis))
      self.configTickMarkColor[axis].clicked.connect(partial(self.changeTickMarkColor, axis = axis))
      self.configTickMarkWidth[axis].editingFinished.connect(partial(self.changeTickMarkWidth, axis = axis, minval = 0.0, maxval = 100.0))
      self.configTickMarkLength[axis].editingFinished.connect(partial(self.changeTickMarkLength, axis = axis, minval = 0.0, maxval = 100.0))

    # inner situation config
    if(not self.secondAxes):
      self.xSplitFraction.editingFinished.connect(partial(self.changeSplitFraction, 0.05, 20, True))
      self.xSplitPad.editingFinished.connect(partial(self.changeSplitPad, 0.0, 10 , True))
      self.configInnerLabel.clicked.connect(partial(self.toggleTicksLabel, 'x2'))
      self.configInnerAxesLabel.clicked.connect(partial(self.setInnerParameter, param='axes'))
      self.configInnerTickLabel.clicked.connect(partial(self.setInnerParameter, param='ticks'))

      self.configInnerTickXAuto.clicked.connect(partial(self.automaticAxisTicks, axis = 'x2'))
      self.configInnerTickXEntry.editingFinished.connect(partial(self.changeAxisTicks, 'x2'))
      self.configInnerTickUseData.clicked.connect(partial(self.dataAxisTicks, True))

      self.configInnerTickXFormat.activated.connect(partial(self.setTickFormat, entryfield = self.configInnerTickXFormat, axis = 'x2'))
      self.configInnerTickXFormatPrecision.editingFinished.connect(partial(self.changeTickFormatPrecision, entryfield = self.configInnerTickXFormatPrecision, axis = 'x2', minval = 0, maxval = 20))
      self.configInnerTickXFormatTrailZero.clicked.connect(partial(self.setFormatTrailZero, entryfield=self.configInnerTickXFormatTrailZero, axis = 'x2'))
      self.configInnerTickXFormatSeparator.clicked.connect(partial(self.setFormatSeparator, entryfield=self.configInnerTickXFormatSeparator, axis = 'x2'))
      self.configInnerTickXPrefix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configInnerTickXPrefix, axis='x2', prefix=True))
      self.configInnerTickXPostfix.editingFinished.connect(partial(self.setFormatFix, entryfield=self.configInnerTickXPostfix, axis='x2', prefix=False))

      self.configInnerMinorTickX.activated.connect(partial(self.setMinorTick, axis = 'x2'))

    # grid config
    if(not self.secondAxes):
      useAxes = ['x', 'y', 'x2']
    else:
      useAxes = ['y2']
    for axis in useAxes:
      self.configGridLabel[axis].clicked.connect(partial(self.setGridVisibility, axis = axis))
      self.configGridColor[axis].clicked.connect(partial(self.changeGridColor, axis = axis))
      self.configGridWidth[axis].editingFinished.connect(partial(self.changeGridWidth, axis = axis, minval = 0.0, maxval = 100.0))
      self.configGridStyle[axis].activated.connect(partial(self.setGridStyle, axis = axis))
      self.configGridDashStyle[axis].activated.connect(partial(self.setGridDashStyle, axis = axis))
      self.configGridOrder[axis].activated.connect(partial(self.setGridOrder, axis = axis))
      
    # legend config
    if(not self.secondAxes):
      self.configLegendLabel.clicked.connect(self.setLegend)
      self.configLegendPlacement.activated.connect(self.setLegendPlacement)
      for prop in ['face', 'edge']:
        self.configLegendColor[prop].clicked.connect(partial(self.changeLegendColor, prop))
      self.configLegendColorLabel['face'].clicked.connect(self.toggleLegendFill)
      self.configLegendEdgeWidth.editingFinished.connect(partial(self.changeLegendEdgeWidth, minval = 0.0, maxval = 100.0))
      self.configLegendShadowLabel.clicked.connect(self.setLegendShadow)
      self.configLegendLabelColor.clicked.connect(self.changeLegendLabelColor)
      self.configLegendLabelSize.editingFinished.connect(partial(self.changeLegendLabelSize, entryfield = self.configLegendLabelSize, minval = 0.0, maxval = 100.0))
      self.configLegendLabelBold.clicked.connect(self.changeLegendLabelBold)
      self.configLegendLabelItalic.clicked.connect(self.changeLegendLabelItalic)
      self.configLegendLabelFont.activated.connect(self.setLegendLabelFont)
      self.configLegendNCol.activated.connect(self.setLegendNCol)
      self.configLegendMarkerFirstLabel.clicked.connect(self.setLegendMarkerFirst)
      self.configLegendMarkerScale.editingFinished.connect(partial(self.changeLegendMarkerScale, entryfield = self.configLegendMarkerScale, minval = 0.0, maxval = 5.0))
      self.configLegendMarkerNumPoints.activated.connect(self.setLegendMarkerNumPoints)
  
      self.configLegendPadBorder.editingFinished.connect(partial(self.changeLegendPadBorder, entryfield = self.configLegendPadBorder, minval = 0.0, maxval = 10.0))
      self.configLegendPadRow.editingFinished.connect(partial(self.changeLegendPadRow, entryfield = self.configLegendPadRow, minval = 0.0, maxval = 10.0))
      self.configLegendPadCol.editingFinished.connect(partial(self.changeLegendPadCol, entryfield = self.configLegendPadCol, minval = 0.0, maxval = 50.0))
    
    # canvas config
    if(not self.secondAxes):
      self.configFigureColorButton.clicked.connect(self.changeFigureColor)  
      self.configCanvasColorButton.clicked.connect(self.changeCanvasColor)
      self.configFigureLabel.clicked.connect(self.toggleFigureFill)
      self.configCanvasLabel.clicked.connect(self.toggleCanvasFill)
      self.configFrameLabel.clicked.connect(self.toggleFrameDraw)
      
      # canvas gradient
      self.configCanvasGradientLabel.clicked.connect(self.setCanvasGradient)
      self.configCanvasGradientStyle.activated.connect(self.changeCanvasGradientStyle)
      self.configCanvasGradientColor1Button.clicked.connect(partial(self.changeCanvasGradientColor, color=0))
      self.configCanvasGradientColor2Button.clicked.connect(partial(self.changeCanvasGradientColor, color=1))
      self.configCanvasGradientAngle.editingFinished.connect(partial(self.changeCanvasGradientAngle, minval=0.0, maxval=360.0))
      self.configCanvasGradientCenterX.editingFinished.connect(partial(self.changeCanvasGradientCenter, minval=0.0, maxval=1.0, axis='x'))
      self.configCanvasGradientCenterY.editingFinished.connect(partial(self.changeCanvasGradientCenter, minval=0.0, maxval=1.0, axis='y'))
      self.configCanvasGradientWidth.editingFinished.connect(partial(self.changeCanvasGradientWidth, minval=0.01, maxval=5.0))
      
      # canvas dimensions
      self.exportSizeX.editingFinished.connect(partial(self.checkExportSize, entryfield = self.exportSizeX, axis='x', minval = 0.0, maxval = 500.0))
      self.exportSizeY.editingFinished.connect(partial(self.checkExportSize, entryfield = self.exportSizeY, axis='y', minval = 0.0, maxval = 500.0))
      self.exportSizeCurrentButton.clicked.connect(self.useCurrentDim)
      
      # pad graphics
      for axis in ['bottom', 'left']:
        self.exportPadEntry[axis].editingFinished.connect(partial(self.changePadding, axis = axis, minval = 0.0, maxval = 0.49))
      for axis in ['top', 'right']:
        self.exportPadEntry[axis].editingFinished.connect(partial(self.changePadding, axis = axis, minval = 0.50, maxval = 1.00))
      
      # frame
      self.configFrameColor.clicked.connect(self.changeFrameColor)
      self.configFrameWidth.editingFinished.connect(partial(self.changeFrameWidth, minval = 0.0, maxval = 100.0))
      self.configFrameStyle.activated.connect(self.setFrameStyle)
      self.configFrameDashStyle.activated.connect(self.setFrameDashStyle)
    
    # xkcd
    if(not self.secondAxes):
      self.configXkcdLabel.clicked.connect(partial(self.setXkcd,True))
      self.xkcdScale.editingFinished.connect(partial(self.checkXkcdSetting, entryfield = self.xkcdScale, item='scale', minval = 0.0, maxval = 10.0))
      self.xkcdLength.editingFinished.connect(partial(self.checkXkcdSetting, entryfield = self.xkcdLength, item='length', minval = 0.0, maxval = 1000.0))
      self.xkcdRandom.editingFinished.connect(partial(self.checkXkcdSetting, entryfield = self.xkcdRandom, item='random', minval = 0.0, maxval = 10.0))
      
      # path effects
      self.configPathEffectsLabel.clicked.connect(partial(self.setPathStroke, True))
      self.configPathEffectsColorButton.clicked.connect(self.changePathStrokeColor)
      self.configPathEffectsWidth.editingFinished.connect(partial(self.changePathStrokeWidth, minval = 0.0, maxval = 100.0))
  
      self.configPathShadowLabel.clicked.connect(partial(self.setPathShadow, True))
      self.configPathShadowColorButton.clicked.connect(self.changePathShadowColor)
      self.configPathShadowOffX.editingFinished.connect(partial(self.changePathShadowOffset, direction = 'x', minval = -50.0, maxval = 50.0))
      self.configPathShadowOffY.editingFinished.connect(partial(self.changePathShadowOffset, direction = 'y', minval = -50.0, maxval = 50.0))

    # preview and export graphics
    if(not self.secondAxes):
      self.previewButton.clicked.connect(self.previewThis)
      self.exportButton.clicked.connect(self.exportThis)
      self.reportButton.clicked.connect(self.reportThis)
    
      # load/save style
      self.loadStyleSet.clicked.connect(partial(self.processStyleSet, 'load', 'file'))
      self.saveStyleSet.clicked.connect(partial(self.processStyleSet,'save', 'file'))

  def processStyleSet(self, operation='load', modus='file', zoffsetData=0, zoffsetCurve=0, redraw=True, rescale=True):
    # loads/saves style set
    if(operation in ['load', 'save']):
      # items in plot style to save
      items = ['labelX', 'labelXShow', 'labelXColor', 'labelXSize', 'labelY', 'labelYShow', 'labelYColor', 'labelYSize',\
        'labelXWeight', 'labelYWeight', 'labelXStyle', 'labelYStyle', 'labelXVariant', 'labelYVariant', 'labelXAlignment', 'labelYAlignment',\
        'labelXAlignmentVertical', 'labelYAlignmentVertical', 'labelXPad', 'labelYPad', 'labelXPos', 'labelYPos', 'labelXAngle', 'labelYAngle',\
        'axisVisible', 'axisColor', 'axisPosition', 'axisPositionValue', 'axisWidth', 'axisStyle', 'axisDashStyle',\
        'ticksX', 'ticksXShow', 'ticksXColor', 'ticksXSize', 'ticksXAngle',\
        'ticksXWeight', 'ticksYWeight', 'ticksXStyle', 'ticksYStyle',\
        'ticksXAlignment', 'ticksXAlignmentVertical', 'ticksXPad', 'ticksXPad2', 'ticksXLabel', 'ticksXAuto', 'ticksXMinor', \
        'ticksXFormat', 'ticksYFormat', 'ticksY2Format', 'ticksResidYFormat',\
        'ticksXFormatPrecision', 'ticksYFormatPrecision', 'ticksY2FormatPrecision', 'ticksResidYFormatPrecision',\
        'ticksXFormatTrailZero', 'ticksYFormatTrailZero', 'ticksY2FormatTrailZero', 'ticksResidYFormatTrailZero',\
        'ticksXFormatSeparator', 'ticksYFormatSeparator', 'ticksY2FormatSeparator', 'ticksResidYFormatSeparator',\
        'ticksXFormatPrefix', 'ticksYFormatPrefix', 'ticksY2FormatPrefix', 'ticksResidYFormatPrefix',\
        'ticksXFormatPostfix', 'ticksYFormatPostfix', 'ticksY2FormatPostfix', 'ticksResidYFormatPostfix',\
        'ticksXFormat_div', 'ticksXFormatPrecision_div', 'ticksXFormatTrailZero_div', 'ticksXFormatSeparator_div', 'ticksXFormatPrefix_div', 'ticksXFormatPostfix_div',\
        'ticksX_div', 'ticksXShow_div', 'ticksXAuto_div', 'ticksXLabel_div', 'ticksXMinor_div',\
        'ticksY', 'ticksYShow', 'ticksResidYShow', 'ticksYColor', 'ticksYSize', 'ticksYAngle', 'ticksYAlignment', 'ticksYAlignmentVertical', 'ticksYPad', 'ticksYPad2', 'ticksYAuto','ticksYMinor', 'ticksY2Minor', 'ticksResidY', 'ticksResidYAuto', 'ticksVisible', 'ticksResidYMinor', 'ticksDirection', 'ticksColor', 'ticksWidth',\
        'ticksLength', 'ticksMinorRelativeLength','gridVisible', 'gridColor', 'gridWidth', 'gridStyle', 'gridDashStyle', 'gridOrder', \
        'labelY2', 'labelY2Color', 'labelY2Size', 'labelY2Weight', 'labelY2Style', 'labelY2Variant',\
        'labelY2Pad', 'labelY2Pos', 'labelY2Angle', 'labelY2Alignment', 'labelY2AlignmentVertical',\
        'ticksY2', 'ticksY2Show', 'ticksY2Color',\
        'ticksY2Size', 'ticksY2Angle', 'ticksY2Alignment', 'ticksY2AlignmentVertical', 'ticksY2Pad', 'ticksY2Pad2', 'ticksY2Auto', 'ticksY2Weight', 'ticksY2Style',\
        'figureColor', 'canvasColor', 'canvasFill', 'figureFill', 'frameDraw', 'exportWidth', 'exportHeight', 'axisFont', 'tickFont', 'padSize',\
        'frameWidth', 'frameColor', 'frameStyle', 'frameDashStyle',\
        'legendVisible', 'legendPlacement', 'legendColor', 'legendEdgeWidth', 'legendShadow', 'legendLabelColor',\
        'legendLabelSize', 'legendLabelWeight', 'legendLabelStyle', 'legendLabelFont', 'legendNumPoints',\
        'legendMarkerFirst', 'legendNumCol', 'legendMarkerScale', 'legendBorderPad', 'legendLabelSpacing', 'legendColumnSpacing', 'legendFill',\
        'xkcd', 'xkcdScale', 'xkcdLength', 'xkcdRandomness',\
        'applyPathStroke', 'pathStrokeWidth', 'pathStrokeColor',\
        'applyPathShadow', 'pathShadowX', 'pathShadowY', 'pathShadowColor',\
        'arrowVisible', 'arrowOverhang', 'arrowColor', 'arrowFill', 'arrowHeadLength', 'arrowHeadWidth', 'arrowOffset',\
        'canvasGradientVisible', 'canvasGradientStyle','canvasGradientColor1', 'canvasGradientColor2', 'canvasGradientAngle', 'canvasGradientWidth', 'canvasGradientCenter']
      dataobject = ['dataSet', 'dataError', 'dataErrorShady', 'dataBar', 'dataStack', 'dataText', 'dataViolin']
      fitobject = 'curve'
      residobject = ['resid', 'residBar', 'residStack', 'residText']
      residobjectzero = 'residZero'
      flag = True

      if(operation == 'load'):
        # store original axis limits to counteract rescaling when applying styles
        minX, maxX, minY, maxY = self.parent.plotArea.minX, self.parent.plotArea.maxX, self.parent.plotArea.minY, self.parent.plotArea.maxY
        minResidY, maxResidY = self.parent.plotArea.minResidY, self.parent.plotArea.maxResidY
        minY2, maxY2 = self.parent.plotArea.minY2, self.parent.plotArea.maxY2
        # load from file or from string?
        if(modus == 'file'):
          filename, filter_ = QtWidgets.QFileDialog.getOpenFileName(self, filter = 'Style set (*.style)', directory = WORKINGDIR + PATH_SEPARATOR + 'styles' + PATH_SEPARATOR, caption='Open Style Sheet')
          filename = str(filename)
          try:
            loadhandle = open(filename,'r', encoding='utf-8')
            lines = loadhandle.readlines()
            loadhandle.close()
            # save filename for future reference
            self.currStyleFile = filename
          except:
            self.parent.statusbar.showMessage('Cannot load style file ' + filename, self.parent.STATUS_TIME)
            lines = []
            flag = False
        else:
          lines = modus.split('\n')
        
        if(flag):
          entry = ''
          for red in lines:
            if(red.find('>>>') == 0):
              entry = red[3:].strip()
              # replace underscore in key names to avoid mixup with 
              if('000' in entry):
                entry = entry.replace('000', '_')
            elif(entry != ''):
              red = red.strip()
              # convert string input to original data
              try:
                red = literal_eval(red)
                # assign value to plot canvas
                if(hasattr(self.parent.plotArea, entry)):
                  # test whether this is a dictionary
                  if(type(red) == dict):
                    self.parent.plotArea.__dict__[entry].update(red)
                  else:
                    setattr(self.parent.plotArea, entry, red)
              except:
                self.parent.statusbar.showMessage('Failed to restore setting ' + repr(entry) + repr(red), self.parent.STATUS_TIME)
              entry = ''
              
          # loadconfig of data set and curve
          entry = ''
          for red in lines:
            if(red.find('>>>') == 0):
              entry = red[3:].strip()
            elif(entry != ''):
              if('_' in entry):
                splitentry = entry.split('_')
                entry = splitentry[0]; index = int(splitentry[-1])
                
              if((entry in dataobject) or (entry in residobject) or (entry in [fitobject, residobjectzero])):
                red = red.strip()
                # convert string input to original data
                try:
                  red = literal_eval(red)
                  for key in red:
                    if((entry == dataobject[0]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setStyle(key, red[key], redraw=False)
                    elif((entry == dataobject[1]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setErrorStyle(key, red[key], redraw=False)
                    elif((entry == dataobject[2]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setErrorShadyStyle(key, red[key], redraw=False)
                    elif((entry == dataobject[3]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setBarStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == dataobject[4]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setStackStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == dataobject[5]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setTextStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == dataobject[6]) and (index + zoffsetData < len(self.parent.data))):
                      if(key == 'mode'):
                        self.parent.data[index + zoffsetData].toggleViolin(red[key], redraw=False)
                      else:
                        subtarget = key
                        for key in red[subtarget]:
                          self.parent.data[index + zoffsetData].setViolinStyle(subtarget, key, red[subtarget][key], redraw=False, rescale=False)
                    elif((entry == residobject[0]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidStyle(key, red[key], redraw=False)
                    elif((entry == residobject[1]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidBarStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == residobject[2]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidStackStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == residobject[3]) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidTextStyle(key, red[key], redraw=False, rescale=False)
                    elif((entry == residobjectzero) and (index + zoffsetData < len(self.parent.data))):
                      self.parent.data[index + zoffsetData].setResidLineStyle(key, red[key], redraw=False)
                    elif((entry == fitobject) and (index + zoffsetCurve < len(self.parent.fit))):
                      self.parent.fit[index + zoffsetCurve].setStyle(key, red[key], redraw=False)
                except:
                  self.parent.statusbar.showMessage('Failed to restore setting' + repr(entry) + repr(red), self.parent.STATUS_TIME)
  
              entry = ''

          # cause plot to be redrawn
          self.parent.plotArea.initPlot(initialize=False)
          # update entry fields
          self.updateFields(initialize=False)
          self.parent.graphicsarea2.updateFields(initialize=False)
          # check whether we have items on the second axes
          self.parent.objectsarea.checkSecondAxes()
              
          # rescale to original axis limits
          if(rescale):
            self.parent.plotArea.setAxisLimits(lower=minX, upper=maxX, axis='x', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=minY2, upper=maxY2, axis='y2', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=minY, upper=maxY, axis='y', updateLabel=True, target='plot', redraw=False, updateGrid=True)
            self.parent.plotArea.setAxisLimits(lower=minResidY, upper=maxResidY, axis='y', updateLabel=True, target='resid', redraw=False, updateGrid=True)

          # separately deal with legend so that it updates
          value = self.parent.plotArea.legendVisible
          self.parent.plotArea.setLegend(value=value, redraw=redraw)
          
          # update resid plot?
          if(redraw):
            self.parent.plotArea.residplotwidget.myRefresh()
      else:
        # retrieve plot configuration
        red = ''
        for entry in items:
          if(hasattr(self.parent.plotArea, entry)):
            # replace underscore in key names to avoid mixup with 
            if('_' in entry):
              red += '>>>' + entry.replace('_', '000') + '\n'
            else:
              red += '>>>' + entry + '\n'
            tempOut = self.parent.plotArea.__dict__[entry]
            if(hasattr(tempOut, 'tolist')):
              tempOut = tempOut.tolist()
            red += repr(tempOut)+'\n'
        # save config of data set and curve
        for index in range(len(self.parent.data)):
          red += '>>>' + dataobject[0] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getStyle()) + '\n'
          red += '>>>' + dataobject[1] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getErrorStyle()) + '\n'
          red += '>>>' + dataobject[2] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getErrorShadyStyle()) + '\n'
          red += '>>>' + dataobject[3] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getBarStyle()) + '\n'
          red += '>>>' + dataobject[4] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getStackStyle()) + '\n'
          red += '>>>' + dataobject[5] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getTextStyle()) + '\n'
          red += '>>>' + dataobject[6] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getViolinStyle()) + '\n'
          red += '>>>' + residobject[0] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidStyle()) + '\n'
          red += '>>>' + residobject[1] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidBarStyle()) + '\n'
          red += '>>>' + residobject[2] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidStackStyle()) + '\n'
          red += '>>>' + residobject[3] + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidTextStyle()) + '\n'
          red += '>>>' + residobjectzero + '_' + str(index) + '\n'
          red += repr(self.parent.data[index].getResidLineStyle()) + '\n'
        
        for index in range(len(self.parent.fit)):
          red += '>>>' + fitobject + '_' + str(index) + '\n'
          red += repr(self.parent.fit[index].getStyle()) + '\n'

        if (modus == 'file'):
          usedir = WORKINGDIR + PATH_SEPARATOR + 'styles' + PATH_SEPARATOR
          if(self.currStyleFile != None):
            usedir = self.currStyleFile
          filename, fitler_ = QtWidgets.QFileDialog.getSaveFileName(self, filter = 'Style set (*.style)', directory = usedir, caption='Save Style Sheet')
          filename = str(filename)
          try:
            savehandle=open(filename,'w', encoding='utf-8')
            savehandle.write(red)
            savehandle.close()
            # save filename for future reference
            self.currStyleFile = filename
          except:
            self.parent.statusbar.showMessage('Cannot write style file ' + filename, self.parent.STATUS_TIME)
        else:
          return red

  def changeSplitFraction(self, minval=0, maxval=1, redraw=True):
    # check paramter boundaries
    try:
      value = float(self.xSplitFraction.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.xSplitFraction.setText(str(value))

    self.parent.plotArea.changeSplitFraction(value=value, redraw=redraw)

  def changeSplitPad(self, minval=0, maxval=1, redraw=True):
    # check paramter boundaries
    try:
      value = float(self.xSplitPad.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.xSplitPad.setText(str(value))

    self.parent.plotArea.changeSplitPad(value=value, redraw=redraw)

  def setInnerParameter(self, param='axes'):
    if(param in ['axes', 'ticks']):
      if(param == 'axes'):
        state = self.configInnerAxesLabel.isChecked()
      else:
        state = self.configInnerTickLabel.isChecked()
        
      self.parent.plotArea.setInnerParameter(param=param, state=state, redraw=True)
          
  def changePadding(self, axis='bottom', minval=0, maxval=1):
    # adjusts padding around figure
    if(axis in ['bottom', 'top', 'left', 'right']):
      # check paramter boundaries
      try:
        value = float(self.exportPadEntry[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.exportPadEntry[axis].setText(str(value))
        
      self.parent.plotArea.setPadding(value=value, axis=axis, redraw=True, target='plot')
      self.parent.plotArea.setPadding(value=value, axis=axis, redraw=True, target='resid')

  def changeArrowHeadWidth(self, axis='x', minval = 0.0, maxval = 1.0):
    # changes arro head width
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowHeadWidth[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configArrowHeadWidth[axis].setText(str(value))
        
      self.parent.plotArea.setAxisArrowHeadWidth(value=value, axis=axis, redraw=True)

  def changeArrowHeadLength(self, axis='x', minval = 0.0, maxval = 1.0):
    # changes arrow head length
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowHeadLength[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configArrowHeadLength[axis].setText(str(value))
        
      self.parent.plotArea.setAxisArrowHeadLength(value=value, axis=axis, redraw=True)

  def changeArrowOverhang(self, axis='x', minval = -1.0, maxval = 1.0):
    # changes arrow head overhang
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowOverhang[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configArrowOverhang[axis].setText(str(value))
        
      self.parent.plotArea.setAxisArrowOverhang(value=value, axis=axis, redraw=True)

  def changeArrowOffset(self, axis='x', minval = 0.0, maxval = 1.0):
    # changes arrow head offset
    if(axis in ['x', 'y']):
      # check paramter boundaries
      try:
        value = float(self.configArrowOffset[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configArrowOffset[axis].setText(str(value))
        
      self.parent.plotArea.setAxisArrowOffset(value=value, axis=axis, redraw=True)

  def changeArrowColor(self, axis='x', item='fill'):
    # sets arrow color(s)
    if((axis in ['x', 'y']) and (item in ['fill', 'line'])):
      # get current color
      if(item == 'line'):
        prevColor = [255*i for i in self.parent.plotArea.arrowColor[axis]]
      else:
        prevColor = [255*i for i in self.parent.plotArea.arrowFill[axis]]
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        self.parent.plotArea.setAxisArrowColor(value=value, axis=axis, item=item, redraw=True)
        # update color button
        if(item == 'line'):
          colorvalue = [int(i*255.0) for i in self.parent.plotArea.arrowColor[axis][0:3]]
          colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
          self.configArrowLineColor[axis].setStyleSheet(colorstr)
        else:
          colorvalue = [int(i*255.0) for i in self.parent.plotArea.arrowFill[axis][0:3]]
          colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
          self.configArrowFillColor[axis].setStyleSheet(colorstr)      

  def setAxisArrow(self, axis='x'):
    # toggles arrow visibility
    if(axis in ['x', 'y']):
      state = self.configArrowLabel[axis].isChecked()
      for target in ['plot', 'resid']:
        self.parent.plotArea.setAxisArrow(state=state, axis=axis, redraw=True, target=target)

  def setPathStroke(self, redraw=True):
    # toggles path effects
    state = self.configPathEffectsLabel.isChecked()
    self.parent.plotArea.setPathStroke(state=state, redraw=redraw)

  def changePathStrokeColor(self):
    # changes color of path stroke
    # get current color
    prevColor = [255*i for i in self.parent.plotArea.pathStrokeColor]
    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i/255.0 for i in value]
      self.parent.plotArea.setPathStrokeColor(value=value, redraw=True)
      # update color button
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.pathStrokeColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configPathEffectsColorButton.setStyleSheet(colorstr)

  def changePathStrokeWidth(self, minval = 0.0, maxval = 100.0):
    # changes path stroke width
    # check paramter boundaries
    try:
      value = float(self.configPathEffectsWidth.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configPathEffectsWidth.setText(str(value))
      
    self.parent.plotArea.setPathStrokeWidth(value=value, redraw=True)

  def setPathShadow(self, redraw=True):
    # toggles path effects
    state = self.configPathShadowLabel.isChecked()
    self.parent.plotArea.setPathShadow(state=state, redraw=redraw)

  def changePathShadowColor(self):
    # changes color of path shadow
    # get current color
    prevColor = [255*i for i in self.parent.plotArea.pathShadowColor]
    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i/255.0 for i in value]
      self.parent.plotArea.setPathShadowColor(value=value, redraw=True)
      # update color button
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.pathShadowColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configPathShadowColorButton.setStyleSheet(colorstr)

  def changePathShadowOffset(self, direction = 'x', minval = 0.0, maxval = 100.0):
    # changes path shadow offset
    if(direction in ['x', 'y']):
      # check paramter boundaries
      if(direction == 'x'):
        try:
          value = float(self.configPathShadowOffX.text())
          originalvalue = value
        except:
          value = 0.0
          originalvalue = 1.0
      else:
        try:
          value = float(self.configPathShadowOffY.text())
          originalvalue = value
        except:
          value = 0.0
          originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        if(direction == 'x'):
          self.configPathShadowOffX.setText(str(value))
        else:
          self.configPathShadowOffY.setText(str(value))
        
      self.parent.plotArea.setPathShadowOffset(value=value, direction=direction, redraw=True)

  def setFrame(self):
    # toggles visibility of frame
    state = self.configFrameCheck.isChecked()
    self.parent.plotArea.setFrame(value=state, redraw=True, target='plot')
    self.parent.plotArea.setFrame(value=state, redraw=True, target='resid')

  def changeFrameWidth(self, minval=0, maxval=1):
    # changes frame line width
    # check paramter boundaries
    try:
      value = float(self.configFrameWidth.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configFrameWidth.setText(str(value))
      
    self.parent.plotArea.setFrameWidth(value=value, redraw=True, target='plot')
    self.parent.plotArea.setFrameWidth(value=value, redraw=True, target='resid')

  def setFrameStyle(self):
    # sets grid style
    style = str(self.configFrameStyle.currentText())
    self.parent.plotArea.setFrameStyle(value=style, redraw=True, target='plot')
    self.parent.plotArea.setFrameStyle(value=style, redraw=True, target='resid')

  def setFrameDashStyle(self):
    # sets grid style
    style = str(self.configFrameDashStyle.currentText())
    self.parent.plotArea.setFrameDashStyle(value=style, redraw=True, target='plot')
    self.parent.plotArea.setFrameDashStyle(value=style, redraw=True, target='resid')

  def changeFrameColor(self):
    # sets frame color
    # get current color
    prevColor = [255*i for i in self.parent.plotArea.frameColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i/255.0 for i in value]
      self.parent.plotArea.setFrameColor(value=value, redraw=True, target='plot')
      self.parent.plotArea.setFrameColor(value=value, redraw=True, target='resid')
      # update color button
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.frameColor]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configFrameColor.setStyleSheet(colorstr)

  def setXkcd(self, redraw=True):
    # toggles Xkcd
    state = self.configXkcdLabel.isChecked()
    self.parent.plotArea.xkcdify(state=state, redraw=redraw)

  def setCanvasGradient(self):
    # toggles visibility of canvas gradient
    state = self.configCanvasGradientLabel.isChecked()
    self.parent.plotArea.setCanvasGradient(state=state, redraw=True, target='plot')
    self.parent.plotArea.setCanvasGradient(state=state, redraw=True, target='resid')

  def changeCanvasGradientStyle(self):
    # sets style of canvas gradient
    value = self.configCanvasGradientStyle.currentText()
    self.parent.plotArea.setCanvasGradientStyle(value=value, redraw=True, target='plot')
    self.parent.plotArea.setCanvasGradientStyle(value=value, redraw=True, target='resid')
    # additionally control visibility of canvas gradient controls
    self.visibilityCanvasGradientControls()

  def changeCanvasGradientWidth(self, minval=0.01, maxval=3.0):
    # changes angle of canvas gradient
    # check paramter boundaries
    try:
      value = float(self.configCanvasGradientWidth.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configCanvasGradientWidth.setText(str(value))
      
    self.parent.plotArea.setCanvasGradientWidth(value=value, redraw=True, target='plot')
    self.parent.plotArea.setCanvasGradientWidth(value=value, redraw=True, target='resid')

  def changeCanvasGradientCenter(self, minval=0.0, maxval=1.0, axis='x'):
    # changes angle of canvas gradient
    if(axis == 'x'):
      item = self.configCanvasGradientCenterX
    else:
      item = self.configCanvasGradientCenterY
    # check paramter boundaries
    try:
      value = float(item.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      item.setText(str(value))
      
    self.parent.plotArea.setCanvasGradientCenter(value=value, redraw=True, target='plot', axis=axis)
    self.parent.plotArea.setCanvasGradientCenter(value=value, redraw=True, target='resid', axis=axis)

  def changeCanvasGradientAngle(self, minval=0.0, maxval=360.0):
    # changes angle of canvas gradient
    # check paramter boundaries
    try:
      value = float(self.configCanvasGradientAngle.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configCanvasGradientAngle.setText(str(value))
      
    self.parent.plotArea.setCanvasGradientAngle(value=value, redraw=True, target='plot')
    self.parent.plotArea.setCanvasGradientAngle(value=value, redraw=True, target='resid')

  def changeCanvasGradientColor(self, color=0):
    # changes color of path stroke
    # get current color
    if(color):
      prevColor = [255*i for i in self.parent.plotArea.canvasGradientColor2]
    else:
      prevColor = [255*i for i in self.parent.plotArea.canvasGradientColor1]
    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i/255.0 for i in value]
      self.parent.plotArea.setCanvasGradientColor(value=value, redraw=True, target='plot', color=color)
      self.parent.plotArea.setCanvasGradientColor(value=value, redraw=True, target='resid', color=color)
      # update color button
      if(color):
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.canvasGradientColor2[0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.configCanvasGradientColor2Button.setStyleSheet(colorstr)
      else:
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.canvasGradientColor1[0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.configCanvasGradientColor1Button.setStyleSheet(colorstr)

  def setLegend(self):
    # toggles visibility of legend
    state = self.configLegendLabel.isChecked()
    self.parent.plotArea.setLegend(value=state, redraw=True, target='plot')

  def setLegendShadow(self):
    # toggles visibility of legend shadow
    state = self.configLegendShadowLabel.isChecked()
    self.parent.plotArea.setLegendShadow(value=state, redraw=True, target='plot')

  def setLegendPlacement(self):
    # toggles visibility of legend
    placement = str(self.configLegendPlacement.currentText())
    self.parent.plotArea.setLegendPlacement(value=placement, redraw=True, target='plot')

  def changeLegendColor(self, prop='face'):
    # sets color of legend box
    if(prop in ['face', 'edge']):
      # get current color
      prevColor = [255*i for i in self.parent.plotArea.legendColor[prop]]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        self.parent.plotArea.setLegendColor(value=value, prop=prop, redraw=True, target='plot')
        # update color button
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.legendColor[prop]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.configLegendColor[prop].setStyleSheet(colorstr)

  def changeLegendLabelColor(self):
    # sets color of legend labels
    # get current color
    prevColor = [255*i for i in self.parent.plotArea.legendLabelColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i/255.0 for i in value]
      self.parent.plotArea.setLegendLabelColor(value=value, redraw=True, target='plot')
      # update color button
      colorvalue = [int(i*255.0) for i in self.parent.plotArea.legendLabelColor]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configLegendLabelColor.setStyleSheet(colorstr)

  def changeLegendEdgeWidth(self, minval=0, maxval=1):
    # changes width of legend edge
    # check paramter boundaries
    try:
      value = float(self.configLegendEdgeWidth.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      self.configLegendEdgeWidth.setText(str(value))
      
    self.parent.plotArea.setLegendEdgeWidth(value=value, redraw=True, target='plot')

  def changeLegendPadBorder(self, entryfield=None, minval=0, maxval=1):
    # changes border padding of legend
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendPadBorder(value=value, redraw=True, target='plot')

  def changeLegendPadRow(self, entryfield=None, minval=0, maxval=1):
    # changes row padding of legend
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendPadRow(value=value, redraw=True, target='plot')

  def changeLegendPadCol(self, entryfield=None, minval=0, maxval=1):
    # changes column padding of legend
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendPadCol(value=value, redraw=True, target='plot')

  def changeLegendLabelSize(self, entryfield=None, minval=0, maxval=1):
    # changes font size of legend label
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendLabelSize(value=value, redraw=True, target='plot')

  def changeLegendLabelBold(self):
    # changes formatting of legend label
    isChecked = self.configLegendLabelBold.isChecked()
    if(isChecked):
      value = 'bold'
    else:
      value = 'normal'
      
    self.parent.plotArea.setLegendLabelBold(value=value, redraw=True, target='plot')

  def changeLegendLabelItalic(self):
    # changes formatting of legend label
    isChecked = self.configLegendLabelItalic.isChecked()
    if(isChecked):
      value = 'italic'
    else:
      value = 'normal'
      
    self.parent.plotArea.setLegendLabelItalic(value=value, redraw=True, target='plot')

  def setLegendLabelFont(self):
    # sets legend label font
    useFont = str(self.configLegendLabelFont.currentText())
      
    if(useFont in self.parent.fontNames):
      self.parent.plotArea.setLegendLabelFont(value=useFont, redraw=True, target='plot')

  def setLegendNCol(self):
    # sets number of columns in legend
    value = self.configLegendNCol.currentIndex() + 1
    self.parent.plotArea.setLegendNCol(value=value, redraw=True, target='plot')

  def setLegendMarkerFirst(self):
    # toggles whether to display marker first in legend
    state = self.configLegendMarkerFirstLabel.isChecked()
    self.parent.plotArea.setLegendMarkerFirst(value=state, redraw=True, target='plot')

  def changeLegendMarkerScale(self, entryfield=None, minval=0, maxval=1):
    # changes relative size of legend marker
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setLegendMarkerScale(value=value, redraw=True, target='plot')

  def setLegendMarkerNumPoints(self):
    # sets number of marker points in legend
    value = self.configLegendMarkerNumPoints.currentIndex() + 1
    self.parent.plotArea.setLegendMarkerNumPoints(value=value, redraw=True, target='plot')

  def toggleLegendFill(self):
    # toggles whether canvas filled or not
    state = self.configLegendColorLabel['face'].isChecked()
    self.parent.plotArea.toggleLegendFill(value=state, redraw=True, target='plot')

  def setGridVisibility(self, axis='x'):
    # toggles grid visibility
    if(axis in ['x', 'x2', 'y', 'y2']):
      state = self.configGridLabel[axis].isChecked()
      self.parent.plotArea.setGridVisibility(value=state, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridVisibility(value=state, axis=axis, redraw=True, target='resid')

  def changeGridColor(self, axis='x'):
    # sets grid color
    if(axis in ['x', 'x2', 'y', 'y2']):
      # get current color
      prevColor = [255*i for i in self.parent.plotArea.gridColor[axis]]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        self.parent.plotArea.setGridColor(value=value, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'x2', 'y']):
          self.parent.plotArea.setGridColor(value=value, axis=axis, redraw=True, target='resid')
        # update color button
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.gridColor[axis]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.configGridColor[axis].setStyleSheet(colorstr)

  def changeGridWidth(self, axis='x', minval=0, maxval=1):
    # changes grid line width
    if(axis in ['x', 'x2', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(self.configGridWidth[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configGridWidth[axis].setText(str(value))
        
      self.parent.plotArea.setGridWidth(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridWidth(value=value, axis=axis, redraw=True, target='resid')

  def setGridOrder(self, axis = 'x'):
    # sets grid style
    if(axis in ['x', 'x2', 'y', 'y2']):
      order = str(self.configGridOrder[axis].currentText())
      index = self.configGridOrder[axis].currentIndex()
     
      self.parent.plotArea.setGridOrder(value=order, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridOrder(value=order, axis=axis, redraw=True, target='resid')

  def setGridStyle(self, axis = 'x'):
    # sets grid style
    if(axis in ['x', 'x2', 'y', 'y2']):
      style = str(self.configGridStyle[axis].currentText())
      self.parent.plotArea.setGridStyle(value=style, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridStyle(value=style, axis=axis, redraw=True, target='resid')

  def setGridDashStyle(self, axis = 'x'):
    # sets grid style
    if(axis in ['x', 'x2', 'y', 'y2']):
      style = str(self.configGridDashStyle[axis].currentText())
      self.parent.plotArea.setGridDashStyle(value=style, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'x2', 'y']):
        self.parent.plotArea.setGridDashStyle(value=style, axis=axis, redraw=True, target='resid')

  def changeAxisColor(self, axis='left'):
    # sets axis color
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # get current color
      prevColor = [255*i for i in self.parent.plotArea.axisColor[axis]]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        self.parent.plotArea.setAxisColor(value=value, axis=axis, redraw=True, target='plot')
        if(not (axis in ['left2', 'right2'])):
          self.parent.plotArea.setAxisColor(value=value, axis=axis, redraw=True, target='resid')
        # update color button
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.axisColor[axis]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        self.configAxisColor[axis].setStyleSheet(colorstr)

  def setTickFont(self, axis='x'):
    # sets tick font
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        useFont = str(self.configTickXFont.currentText())
      else:
        useFont = str(self.configTickYFont.currentText())
      
      if(useFont in self.parent.fontNames):
        self.parent.plotArea.setTickFont(value=useFont, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setTickFont(value=useFont, axis=axis, redraw=True, target='resid')

  def setMinorTick(self, axis='x'):
    # sets tick font
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis == 'x'):
        value = self.configMinorTickX.currentIndex() + 1
      elif(axis == 'x2'):
        value = self.configInnerMinorTickX.currentIndex() + 1
      elif(axis in ['y', 'y2']):
        value = self.configMinorTickY.currentIndex() + 1
      else:
        value = self.configMinorTickResid.currentIndex() + 1

      if(axis in ['x', 'x2']):
        self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='plot')
        self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='resid')
      elif(axis in ['y', 'y2']):
        self.parent.plotArea.setMinorTick(value=value, axis=axis, redraw=True, target='plot')
      else:
        self.parent.plotArea.setMinorTick(value=value, axis='y', redraw=True, target='resid')

  def toggleTicksLabel(self, axis='x'):
    # toggles visibility of tick labels
    if(axis in ['x', 'x2', 'y', 'y2', 'resid']):
      if(axis == 'x'):
        state = self.configTickXLabel.isChecked()
      elif(axis == 'x2'):
        state = self.configInnerLabel.isChecked()
      elif(axis in ['y', 'y2']):
        state = self.configTickYLabel.isChecked()
      else:
        state = self.configTickResidYLabel.isChecked()
        
      if(axis == 'resid'):
        self.parent.plotArea.toggleTicksLabel(value=state, axis='y', redraw=True, target='resid')
      else:
        self.parent.plotArea.toggleTicksLabel(value=state, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'x2']):
          self.parent.plotArea.toggleTicksLabel(value=state, axis=axis, redraw=True, target='resid')

  def toggleAxisLabel(self, axis='x'):
    # toggles visibility of axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        state = self.configXLabel.isChecked()
      else:
        state = self.configYLabel.isChecked()
      self.parent.plotArea.toggleAxisLabel(value=state, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.toggleAxisLabel(value=state, axis=axis, redraw=True, target='resid')

  def setAxisLabelAlignment(self, axis='x'):
    # sets alignment of axis label
    if(axis in ['x', 'y', 'y2']):
      flag = False
      if(axis == 'x'):
        useAlignment = str(self.configXAlignment.currentText())
        if(useAlignment in self.alignHorizontal):
          flag = True
      else:
        useAlignment = str(self.configYAlignment.currentText())
        if(useAlignment in self.alignHorizontal):
          flag = True
      
      if(flag):
        self.parent.plotArea.setAxisLabelAlignment(value=useAlignment, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setAxisLabelAlignment(value=useAlignment, axis=axis, redraw=True, target='resid')

  def setAxisLabelAlignmentVertical(self, axis='x'):
    # sets vertical alignment of axis label
    if(axis in ['x', 'y', 'y2']):
      flag = False
      if(axis == 'x'):
        useAlignment = str(self.configXAlignmentVertical.currentText())
        if(useAlignment in self.alignVertical):
          flag = True
      else:
        useAlignment = str(self.configYAlignmentVertical.currentText())
        if(useAlignment in self.alignVertical):
          flag = True
      
      if(flag):
        self.parent.plotArea.setAxisLabelAlignmentVertical(value=useAlignment, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setAxisLabelAlignmentVertical(value=useAlignment, axis=axis, redraw=True, target='resid')

  def changeAxisLabelBold(self, axis='x'):
    # changes formatting of axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configXBold.isChecked()
      else:
        isChecked = self.configYBold.isChecked()
        
      if(isChecked):
        value = 'bold'
      else:
        value = 'normal'
        
      self.parent.plotArea.setAxisLabelBold(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelBold(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelItalic(self, axis='x'):
    # changes formatting of axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configXItalic.isChecked()
      else:
        isChecked = self.configYItalic.isChecked()
        
      if(isChecked):
        value = 'italic'
      else:
        value = 'normal'
        
      self.parent.plotArea.setAxisLabelItalic(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelItalic(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelVariant(self, axis='x'):
    # changes formatting of axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configXVariant.isChecked()
      else:
        isChecked = self.configYVariant.isChecked()
        
      if(isChecked):
        value = 'small-caps'
      else:
        value = 'normal'
        
      self.parent.plotArea.setAxisLabelVariant(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelVariant(value=value, axis=axis, redraw=True, target='resid')

  def setAxisFont(self, axis='x'):
    # sets axis font
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        useFont = str(self.configXFont.currentText())
      else:
        useFont = str(self.configYFont.currentText())
      
      if(useFont in self.parent.fontNames):
        self.parent.plotArea.setAxisFont(value=useFont, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          	self.parent.plotArea.setAxisFont(value=useFont, axis=axis, redraw=True, target='resid')

  def setAxisStyle(self, axis='left'):
    # sets axis style
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      style = str(self.configAxisStyle[axis].currentText())
      self.parent.plotArea.setAxisStyle(value=style, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisStyle(value=style, axis=axis, redraw=True, target='resid')

  def setAxisDashStyle(self, axis='left'):
    # sets axis style
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      style = str(self.configAxisDashStyle[axis].currentText())
      self.parent.plotArea.setAxisDashStyle(value=style, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisDashStyle(value=style, axis=axis, redraw=True, target='resid')

  def setAxisPosition(self, axis='left'):
    # sets axis position
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      style = str(self.configAxisPosition[axis].currentText())
      self.parent.plotArea.setAxisPosition(value=style, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisPosition(value=style, axis=axis, redraw=True, target='resid')

  def changeAxisPositionValue(self, axis='left', minval=-np.inf, maxval=np.inf):
    # changes axis position value
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check paramter boundaries
      try:
        value = float(self.configAxisPositionValue[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configAxisPositionValue[axis].setText(str(value))
        
      self.parent.plotArea.setAxisPositionValue(value=value, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisPositionValue(value=value, axis=axis, redraw=True, target='resid')

  def resetAxisPosition(self, axis='left'):
    # resets axis position to original one
    # first update entry fields
    originalPosition = {'left':('axes', 0), 'right':('axes', 1.0), 'bottom':('axes', 0), 'top':('axes', 1.0), 'left2':('axes', 0), 'right2':('axes', 1.0)}
    if(axis in originalPosition):
      value = str(self.configAxisPosition[axis].currentText())
      if(value != originalPosition[axis][0]):
        if(originalPosition[axis][0] in self.positionstyles):
          self.configAxisPosition[axis].blockSignals(True)
          currindex = self.positionstyles.index(originalPosition[axis][0])
          self.configAxisPosition[axis].setCurrentIndex(currindex)
          self.configAxisPosition[axis].blockSignals(False)
      try:
        value = float(self.configAxisPositionValue[axis].text())
      except:
        value = -9
      if(value != originalPosition[axis][1]):
        self.configAxisPositionValue[axis].blockSignals(True)
        self.configAxisPositionValue[axis].setText(str(originalPosition[axis][1]))
        self.configAxisPositionValue[axis].blockSignals(False)
      
    # reset the axis
    self.parent.plotArea.resetAxisPosition(axis=axis)

  def changeAxisWidth(self, axis='left', minval=0, maxval=1):
    # changes axis width
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check paramter boundaries
      try:
        value = float(self.configAxisWidth[axis].text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        self.configAxisWidth[axis].setText(str(value))
        
      self.parent.plotArea.setAxisWidth(value=value, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisWidth(value=value, axis=axis, redraw=True, target='resid')

  def setAxisVisibility(self, axis='left'):
    # toggles axis visibility
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      state = self.configAxisLabel[axis].isChecked()
      self.parent.plotArea.setAxisVisibility(value=state, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setAxisVisibility(value=state, axis=axis, redraw=True, target='resid')

  def setTickMarkDirection(self, axis='left'):
    # sets tick mark direction
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      style = str(self.configTickMarkDirection[axis].currentText())
      index = self.configTickMarkDirection[axis].currentIndex()
      # update parameters
      if(axis in ['left', 'right']):
        for entry in ['left', 'right']:
          # have to temporarily disable event logging
          self.configTickMarkDirection[entry].blockSignals(True)
          self.configTickMarkDirection[entry].setCurrentIndex(index)
          self.configTickMarkDirection[entry].blockSignals(False)
      elif(axis in ['top', 'bottom']):
        for entry in ['top', 'bottom']:
          # have to temporarily disable event logging
          self.configTickMarkDirection[entry].blockSignals(True)
          self.configTickMarkDirection[entry].setCurrentIndex(index)
          self.configTickMarkDirection[entry].blockSignals(False)
      else:
        for entry in ['left2', 'right2']:
          # have to temporarily disable event logging
          self.configTickMarkDirection[entry].blockSignals(True)
          self.configTickMarkDirection[entry].setCurrentIndex(index)
          self.configTickMarkDirection[entry].blockSignals(False)

      self.parent.plotArea.setTickMarkDirection(value=style, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkDirection(value=style, axis=axis, redraw=True, target='resid')

  def setTicksVisibility(self, axis='left'):
    # toggles ticks visibility
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      state = self.configTickMarkLabel[axis].isChecked()
      self.parent.plotArea.setTickMarkVisibility(value=state, axis=axis, redraw=False, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkVisibility(value=state, axis=axis, redraw=False, target='resid')

      # need to reapply tick formatting as there is the possiblity we switched from left to right of from top to bottom or vice versa
      if(axis in ['top', 'bottom']):
        axis = 'x'
        tickLabelColor = self.parent.plotArea.ticksXColor
        tickLabelSize = self.parent.plotArea.ticksXSize
        tickLabelWeight = self.parent.plotArea.ticksXWeight
        tickLabelStyle = self.parent.plotArea.ticksXStyle
        tickLabelAngle = self.parent.plotArea.ticksXAngle
        tickLabelAlignment = self.parent.plotArea.ticksXAlignment
        tickLabelAlignmentVertical = self.parent.plotArea.ticksXAlignmentVertical
        tickLabelFont = self.parent.plotArea.tickFont[axis]
      elif(axis in ['left', 'right']):
        axis = 'y'
        tickLabelColor = self.parent.plotArea.ticksYColor
        tickLabelSize = self.parent.plotArea.ticksYSize
        tickLabelWeight = self.parent.plotArea.ticksYWeight
        tickLabelStyle = self.parent.plotArea.ticksYStyle
        tickLabelAngle = self.parent.plotArea.ticksYAngle
        tickLabelAlignment = self.parent.plotArea.ticksYAlignment
        tickLabelAlignmentVertical = self.parent.plotArea.ticksYAlignmentVertical
        tickLabelFont = self.parent.plotArea.tickFont[axis]
      else:
        axis = 'y2'
        tickLabelColor = self.parent.plotArea.ticksY2Color
        tickLabelSize = self.parent.plotArea.ticksY2Size
        tickLabelWeight = self.parent.plotArea.ticksY2Weight
        tickLabelStyle = self.parent.plotArea.ticksY2Style
        tickLabelAngle = self.parent.plotArea.ticksY2Angle
        tickLabelAlignment = self.parent.plotArea.ticksY2Alignment
        tickLabelAlignmentVertical = self.parent.plotArea.ticksY2AlignmentVertical
        tickLabelFont = self.parent.plotArea.tickFont[axis]
      
      if(axis == 'y2'):
        usePlots = ['plot']
      else:
        usePlots = ['plot', 'resid']
      for target in usePlots:
        self.parent.plotArea.setTickLabelColor(value=tickLabelColor, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelSize(value=tickLabelSize, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelBold(value=tickLabelWeight, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelItalic(value=tickLabelStyle, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelAngle(value=tickLabelAngle, axis=axis, redraw=False, target=target)
        self.parent.plotArea.setTickLabelAlignment(value=tickLabelAlignment, axis=axis, redraw = False, target=target)
        self.parent.plotArea.setTickLabelAlignmentVertical(value=tickLabelAlignmentVertical, axis=axis, redraw = False, target=target)
        self.parent.plotArea.setTickFont(value=tickLabelFont, axis=axis, redraw=False, target=target)
        
      # redraw
      self.parent.plotArea.dataplotwidget.myRefresh()
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.residplotwidget.myRefresh()
      
  def changeTickMarkLength(self, axis='left', minval=0, maxval=1):
    # changes tick mark width
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check paramter boundaries
      try:
        value = float(self.configTickMarkLength[axis].text())
      except:
        value = 0.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if(axis in ['left', 'right']):
        self.configTickMarkLength['left'].setText(str(value))
        self.configTickMarkLength['right'].setText(str(value))
      elif(axis in ['left2', 'right2']):
        self.configTickMarkLength['left2'].setText(str(value))
        self.configTickMarkLength['right2'].setText(str(value))
      else:
        self.configTickMarkLength['top'].setText(str(value))
        self.configTickMarkLength['bottom'].setText(str(value))
        
      self.parent.plotArea.setTickMarkLength(value=value, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkLength(value=value, axis=axis, redraw=True, target='resid')

  def changeTickMarkWidth(self, axis='left', minval=0, maxval=1):
    # changes tick mark width
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # check paramter boundaries
      try:
        value = float(self.configTickMarkWidth[axis].text())
      except:
        value = 0.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if(axis in ['left', 'right']):
        self.configTickMarkWidth['left'].setText(str(value))
        self.configTickMarkWidth['right'].setText(str(value))
      elif(axis in ['left2', 'right2']):
        self.configTickMarkWidth['left2'].setText(str(value))
        self.configTickMarkWidth['right2'].setText(str(value))
      else:
        self.configTickMarkWidth['top'].setText(str(value))
        self.configTickMarkWidth['bottom'].setText(str(value))
        
      self.parent.plotArea.setTickMarkWidth(value=value, axis=axis, redraw=True, target='plot')
      if(not (axis in ['left2', 'right2'])):
        self.parent.plotArea.setTickMarkWidth(value=value, axis=axis, redraw=True, target='resid')

  def changeTickMarkColor(self, axis='x'):
    # changes color of tick marks
    if(axis in ['left', 'right', 'top', 'bottom', 'left2', 'right2']):
      # get current color
      prevColor = [255*i for i in self.parent.plotArea.ticksColor[axis]]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i/255.0 for i in value]
        self.parent.plotArea.setTickMarkColor(value=value, axis=axis, redraw=True, target='plot')
        if(not (axis in ['left2', 'right2'])):
          self.parent.plotArea.setTickMarkColor(value=value, axis=axis, redraw=True, target='resid')
        # update color button
        colorvalue = [int(i*255.0) for i in self.parent.plotArea.ticksColor[axis][0:3]]
        colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
        if(axis in ['left', 'right']):
          self.configTickMarkColor['left'].setStyleSheet(colorstr)
          self.configTickMarkColor['right'].setStyleSheet(colorstr)
        elif(axis in ['left2', 'right2']):
          self.configTickMarkColor['left2'].setStyleSheet(colorstr)
          self.configTickMarkColor['right2'].setStyleSheet(colorstr)
        else:
          self.configTickMarkColor['top'].setStyleSheet(colorstr)
          self.configTickMarkColor['bottom'].setStyleSheet(colorstr)

  def automaticAxisTicks(self, axis='x'):
    # automatically sets axis limits
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis in ['x', 'x2']):
        nuTicks = self.parent.plotArea.setAutoTicks(axis=axis, redraw=True, target='resid')
        nuTicks = self.parent.plotArea.setAutoTicks(axis=axis, redraw=True, target='plot')
        # update entryfield
        tickstr = ', '.join([str(i) for i in nuTicks])
        if(axis == 'x'):
          self.configTickXEntry.setText(tickstr)
        else:
          self.configInnerTickXEntry.setText(tickstr)
      elif(axis in ['y', 'y2']):
        nuTicks = self.parent.plotArea.setAutoTicks(axis=axis, redraw=True, target='plot')
        # update entryfield
        tickstr = ', '.join([str(i) for i in nuTicks])
        self.configTickYEntry.setText(tickstr)
      else:
        nuTicks = self.parent.plotArea.setAutoTicks(axis=axis, redraw=True, target='resid')
        # update entryfield
        tickstr = ', '.join([str(i) for i in nuTicks])
        self.configTickResidYEntry.setText(tickstr)

  def dataAxisTicks(self, splitX=False):
    # set x ticks to label values
    currDataSet = self.parent.activeData
    self.parent.plotArea.setDataAxisTicks(currDataSet, redraw=True, target='plot', splitX=splitX)
    self.parent.plotArea.setDataAxisTicks(currDataSet, redraw=True, target='resid', splitX=splitX)

  def useCurrentDim(self):
    # sets export dimensions to current dimensions on screen
    # obtain current dimensions
    currwidth, currheight = self.parent.plotArea.matplot.get_size_inches()
    self.exportSizeX.setText('{:4.2f}'.format(currwidth))
    self.exportSizeY.setText('{:4.2f}'.format(currheight))
    self.parent.plotArea.exportWidth = currwidth
    self.parent.plotArea.exportHeight = currheight

  def checkXkcdSetting(self, entryfield=None, item='scale', minval=0, maxval=1):
    # restrains dimensions for figure export
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setXkcdSetting(value=value, item=item, redraw=True)
    
  def checkExportSize(self, entryfield=None, axis='x', minval=0, maxval=1):
    # restrains dimensions for figure export
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    if(axis=='x'):
      self.parent.plotArea.exportWidth = value
    elif(axis=='y'):
      self.parent.plotArea.exportHeight = value
        
  def changeAxisTicks(self, axis='x'):
    if(axis in ['x', 'y', 'y2', 'resid', 'x2']):
      if(axis == 'x'):
        entryfield = self.configTickXEntry
      elif(axis in ['y', 'y2']):
        entryfield = self.configTickYEntry
      elif(axis == 'resid'):
        entryfield = self.configTickResidYEntry
      else:
        entryfield = self.configInnerTickXEntry
      
      tickstr = str(entryfield.text())
      # process new tick string
      nuTicks = tickstr.split(',')
      nuTicks = [i.strip() for i in nuTicks]
      
      # convert to floats
      nuTicks_num = []
      for entry in nuTicks:
        if(self.parent.isNumber(entry)):
          nuTicks_num.append(float(entry))
      nuTicks_num = np.array(sorted(nuTicks_num))

      # update entryfield
      tickstr = ', '.join([str(i) for i in nuTicks_num])
      entryfield.setText(tickstr)
      
      # set ticks in plot
      if(axis == 'x'):
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='plot')
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='resid')
      elif(axis in ['y', 'y2']):
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='plot')
      elif(axis == 'resid'):
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='resid')
      else:
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='plot')
        self.parent.plotArea.setAxisTicks(value=nuTicks_num, axis=axis, redraw=True, target='resid')

  def changeMinorTickRelativeLength(self, entryfield=None, minval=0.1, maxval=10.0):
    # check paramter boundaries
    try:
      value = float(entryfield.text())
      originalvalue = value
    except:
      value = 0.0
      originalvalue = 1.0
    value = np.min((value, maxval))
    value = np.max((value, minval))
    # update parameters
    if (value != originalvalue):
      entryfield.setText(str(value))
      
    self.parent.plotArea.setMinorTickRelativeLength(value=value, redraw=True, target='plot')
    self.parent.plotArea.setMinorTickRelativeLength(value=value, redraw=True, target='resid')

  def changeTickLabelPad(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setTickLabelPad(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelPad(value=value, axis=axis, redraw=True, target='resid')
      
  def changeTickLabelPad2(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setTickLabelPad2(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelPad2(value=value, axis=axis, redraw=True, target='resid')
      
  def changeTickLabelBold(self, axis='x'):
    # changes formatting of tick label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configTickXBold.isChecked()
      else:
        isChecked = self.configTickYBold.isChecked()
        
      if(isChecked):
        value = 'bold'
      else:
        value = 'normal'
        
      self.parent.plotArea.setTickLabelBold(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelBold(value=value, axis=axis, redraw=True, target='resid')

  def changeTickLabelItalic(self, axis='x'):
    # changes formatting of tick label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        isChecked = self.configTickXItalic.isChecked()
      else:
        isChecked = self.configTickYItalic.isChecked()
        
      if(isChecked):
        value = 'italic'
      else:
        value = 'normal'
        
      self.parent.plotArea.setTickLabelItalic(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelItalic(value=value, axis=axis, redraw=True, target='resid')

  def setTickLabelAlignment(self, axis='x'):
    # sets alignment of axis label
    if(axis in ['x', 'y', 'y2']):
      flag = False
      if(axis == 'x'):
        useAlignment = str(self.configTickXAlignment.currentText())
        if(useAlignment in self.alignHorizontal):
          flag = True
      else:
        useAlignment = str(self.configTickYAlignment.currentText())
        if(useAlignment in self.alignHorizontal):
          flag = True
      
      if(flag):
        self.parent.plotArea.setTickLabelAlignment(value=useAlignment, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setTickLabelAlignment(value=useAlignment, axis=axis, redraw=True, target='resid')

  def setTickLabelAlignmentVertical(self, axis='x'):
    # sets vertical alignment of axis label
    if(axis in ['x', 'y', 'y2']):
      flag = False
      if(axis == 'x'):
        useAlignment = str(self.configTickXAlignmentVertical.currentText())
        if(useAlignment in self.alignVertical):
          flag = True
      else:
        useAlignment = str(self.configTickYAlignmentVertical.currentText())
        if(useAlignment in self.alignVertical):
          flag = True
      
      if(flag):
        self.parent.plotArea.setTickLabelAlignmentVertical(value=useAlignment, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setTickLabelAlignmentVertical(value=useAlignment, axis=axis, redraw=True, target='resid')

  def changeTickLabelAngle(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setTickLabelAngle(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelAngle(value=value, axis=axis, redraw=True, target='resid')

  def changeTickLabelSize(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setTickLabelSize(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setTickLabelSize(value=value, axis=axis, redraw=True, target='resid')

  def setTickFormat(self, entryfield=None, axis='x'):
    # sets format of tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        flag = False
        useOption = str(entryfield.currentText())
        if(useOption in self.formatOptions):
          flag = True
          self.updateTickFormatFields(axis=axis, tickFormat=useOption)
        
        if(flag):
          self.parent.plotArea.setTickFormat(axis=axis, value=useOption, redraw=True)
          if(axis == 'y'):
            self.parent.plotArea.setTickFormat(axis='resid', value=useOption, redraw=True)
          if(axis == 'x'):
            self.parent.plotArea.setTickFormat(axis='residx', value=useOption, redraw=True)
          if(axis == 'x2'):
            self.parent.plotArea.setTickFormat(axis='residx2', value=useOption, redraw=True)

  def updateTickFormatFields(self, axis='x', tickFormat='default'):
    # changes activity of entry fields for tick label formatting
    if(axis == 'x'):
      items = ('configTickXFormatPrecision', 'configTickXFormatTrailZero', 'configTickXFormatSeparator', 'configTickXPrefix', 'configTickXPostfix')
    elif(axis == 'x2'):
      items = ('configInnerTickXFormatPrecision', 'configInnerTickXFormatTrailZero', 'configInnerTickXFormatSeparator', 'configInnerTickXPrefix', 'configInnerTickXPostfix')
    elif(axis in ['y', 'y2']):
      items = ('configTickYFormatPrecision', 'configTickYFormatTrailZero', 'configTickYFormatSeparator', 'configTickYPrefix', 'configTickYPostfix')
    else:
      items = ()
    
    for itemName in items:
      if(hasattr(self, itemName)):
        item = self.__dict__[itemName]
        if(hasattr(item, 'setEnabled')):
          item.setEnabled(tickFormat != 'default')

  def setFormatTrailZero(self, entryfield=None, axis='x'):
    # sets trailing zeros of tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        value = entryfield.isChecked()
        self.parent.plotArea.setFormatTrailZero(axis=axis, value=value, redraw=True)
        if(axis == 'y'):
          self.parent.plotArea.setFormatTrailZero(axis='resid', value=value, redraw=True)
        if(axis == 'x'):
          self.parent.plotArea.setFormatTrailZero(axis='residx', value=value, redraw=True)
        if(axis == 'x2'):
          self.parent.plotArea.setFormatTrailZero(axis='residx2', value=value, redraw=True)

  def setFormatSeparator(self, entryfield=None, axis='x'):
    # sets separating 1000s of tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        value = entryfield.isChecked()
        self.parent.plotArea.setFormatSeparator(axis=axis, value=value, redraw=True)
        if(axis == 'y'):
          self.parent.plotArea.setFormatSeparator(axis='resid', value=value, redraw=True)
        if(axis == 'x'):
          self.parent.plotArea.setFormatSeparator(axis='residx', value=value, redraw=True)
        if(axis == 'x2'):
          self.parent.plotArea.setFormatSeparator(axis='residx2', value=value, redraw=True)

  def setFormatFix(self, entryfield=None, axis='x', prefix=True):
    # sets pre/postfix of axis labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        value = entryfield.text()
        self.parent.plotArea.setFormatFix(axis=axis, value=value, redraw=True, prefix=prefix)
        if(axis == 'y'):
          self.parent.plotArea.setFormatFix(axis='resid', value=value, redraw=True, prefix=prefix)
        if(axis == 'x'):
          self.parent.plotArea.setFormatFix(axis='residx', value=value, redraw=True, prefix=prefix)
        if(axis == 'x2'):
          self.parent.plotArea.setFormatFix(axis='residx2', value=value, redraw=True, prefix=prefix)

  def changeTickFormatPrecision(self, entryfield=None, axis='x', minval=0, maxval=20):
    # sets precision in format of tick labels
    if(entryfield != None):
      if(axis in ['x', 'y', 'y2', 'x2']):
        # check paramter boundaries
        try:
          value = int(entryfield.text())
          originalvalue = value
        except:
          value = 0
          originalvalue = 1
        value = np.min((value, maxval))
        value = np.max((value, minval))
        # update parameters
        if (value != originalvalue):
          entryfield.setText(str(value))

        self.parent.plotArea.setTickFormatPrecision(axis=axis, value=value, redraw=True)
        if(axis == 'y'):
          self.parent.plotArea.setTickFormatPrecision(axis='resid', value=value, redraw=True)
        if(axis == 'x'):
          self.parent.plotArea.setTickFormatPrecision(axis='residx', value=value, redraw=True)
        if(axis == 'x2'):
          self.parent.plotArea.setTickFormatPrecision(axis='residx2', value=value, redraw=True)

  def changeAxisLabelAngle(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setAxisLabelAngle(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelAngle(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelPad(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setAxisLabelPad(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelPad(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelPos(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setAxisLabelPos(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelPos(value=value, axis=axis, redraw=True, target='resid')

  def changeAxisLabelSize(self, entryfield=None, axis='x', minval=0, maxval=1):
    if(axis in ['x', 'y', 'y2']):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
        
      self.parent.plotArea.setAxisLabelSize(value=value, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabelSize(value=value, axis=axis, redraw=True, target='resid')

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

  def VLine(self):
    # draws a horizontal line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

  def changeFigureColor(self):
    # changes color of canvas
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.figureColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setFigureColor(value=value, redraw=True, target='plot', silent=False)
      self.parent.plotArea.setFigureColor(value=value, redraw=True, target='resid', silent=True)
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.figureColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configFigureColorButton.setStyleSheet(colorstr)

  def toggleFigureFill(self):
    # toggles whether figure filled or not
    state = self.configFigureLabel.isChecked()
    self.parent.plotArea.toggleFigureFill(value=state, redraw=True, target='plot', silent=False)
    self.parent.plotArea.toggleFigureFill(value=state, redraw=True, target='resid', silent=True)
    
  def toggleFrameDraw(self):
    # toggles whether figure frame is drawn or not
    state = self.configFrameLabel.isChecked()
    self.parent.plotArea.toggleFrameDraw(value=state, redraw=True, target='plot')
    self.parent.plotArea.toggleFrameDraw(value=state, redraw=True, target='resid')

  def toggleCanvasFill(self):
    # toggles whether canvas filled or not
    state = self.configCanvasLabel.isChecked()
    self.parent.plotArea.toggleCanvasFill(value=state, redraw=True, target='plot')
    self.parent.plotArea.toggleCanvasFill(value=state, redraw=True, target='resid')
    
  def changeCanvasColor(self):
    # changes color of canvas
    # get current color
    prevColor = [255 * i for i in self.parent.plotArea.canvasColor]

    prevColor = QtGui.QColor(*prevColor)
    # call QColor dialog
    nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
    if (nuColor.isValid()):
      value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
      value = [i / 255.0 for i in value]
      self.parent.plotArea.setCanvasColor(value=value, redraw=True, target='plot')
      self.parent.plotArea.setCanvasColor(value=value, redraw=True, target='resid')
      # update color button
      colorvalue = [int(i * 255.0) for i in self.parent.plotArea.canvasColor[0:3]]
      colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
      self.configCanvasColorButton.setStyleSheet(colorstr)
    
  def changeTickLabelColor(self, axis='x'):
    # changes color of axis ticks
    if(axis in ['x', 'y', 'y2']):
      # get current color
      if(axis == 'x'):
        prevColor = [255 * i for i in self.parent.plotArea.ticksXColor]
      else:
        prevColor = [255 * i for i in self.parent.plotArea.ticksYColor]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]
        self.parent.plotArea.setTickLabelColor(value=value, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setTickLabelColor(value=value, axis=axis, redraw=True, target='resid')
        # update color button
        if (axis == 'x'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksXColor[0:3]]
          colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
          self.configTickXColorButton.setStyleSheet(colorstr)
        elif(axis == 'y'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksYColor[0:3]]
          colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
          self.configTickYColorButton.setStyleSheet(colorstr)
        elif(axis == 'y2'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.ticksY2Color[0:3]]
          colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
          self.configTickYColorButton.setStyleSheet(colorstr)

  def changeAxisLabelColor(self, axis='x'):
    # changes color of axis label
    if(axis in ['x', 'y', 'y2']):
      # get current color
      if(axis == 'x'):
        prevColor = [255 * i for i in self.parent.plotArea.labelXColor]
      elif(axis == 'y'):
        prevColor = [255 * i for i in self.parent.plotArea.labelYColor]
      else:
        prevColor = [255 * i for i in self.parent.plotArea.labelY2Color]
  
      prevColor = QtGui.QColor(*prevColor)
      # call QColor dialog
      nuColor = QtWidgets.QColorDialog.getColor(prevColor, self, 'Set Color', QtWidgets.QColorDialog.ShowAlphaChannel)
      if (nuColor.isValid()):
        value = [nuColor.red(), nuColor.green(), nuColor.blue(), nuColor.alpha()]
        value = [i / 255.0 for i in value]
        self.parent.plotArea.setAxisLabelColor(value=value, axis=axis, redraw=True, target='plot')
        if(axis in ['x', 'y']):
          self.parent.plotArea.setAxisLabelColor(value=value, axis=axis, redraw=True, target='resid')
        # update color button
        if (axis == 'x'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelXColor[0:3]]
          colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
          self.configXColorButton.setStyleSheet(colorstr)
        elif(axis == 'y'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelYColor[0:3]]
          colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
          self.configYColorButton.setStyleSheet(colorstr)
        elif(axis == 'y2'):
          colorvalue = [int(i * 255.0) for i in self.parent.plotArea.labelY2Color[0:3]]
          colorstr = 'background-color: rgb(%d, %d, %d);'%(colorvalue[0], colorvalue[1], colorvalue[2])
          self.configYColorButton.setStyleSheet(colorstr)

  def changeAxisLabel(self, axis='x'):
    # updates axis label
    if(axis in ['x', 'y', 'y2']):
      if(axis == 'x'):
        labeltext = str(self.configXName.text())
        # encode/recode to process newlines correctly
        #labeltext = labeltext.encode('utf-8').decode('unicode-escape')
        labeltext2 = labeltext
      else:
        labeltext = str(self.configYName.text())
        #labeltext = labeltext.encode('utf-8').decode('unicode-escape')
        labeltext2 = labeltext
 
      self.parent.plotArea.setAxisLabel(labeltext=labeltext, axis=axis, redraw=True, target='plot')
      if(axis in ['x', 'y']):
        self.parent.plotArea.setAxisLabel(labeltext=labeltext2, axis=axis, redraw=True, target='resid')

  def previewThis(self):
    # generates and displays a figure preview
    filename = WORKINGDIR + PATH_SEPARATOR + TEMP_PREVIEWFILE
    
    # save main graphics
    # obtain target dimensions
    targetwidth = float(self.exportSizeX.text())
    targetheight = float(self.exportSizeY.text())
    # obtain current dimensions
    currwidth, currheight = self.parent.plotArea.matplot.get_size_inches()
    
    # set new dimensions and save
    self.parent.plotArea.matplot.set_size_inches(targetwidth, targetheight)
    success = False
    if(self.parent.plotArea.figureFill):
      useFaceColor = self.parent.plotArea.figureColor
    else:
      useFaceColor = 'none'
    if(self.parent.plotArea.frameDraw):
      useFrameColor = self.parent.plotArea.frameColor
    else:
      useFrameColor = 'none'
    try:
      self.parent.plotArea.matplot.savefig(filename, format='png', dpi=150, facecolor=useFaceColor, edgecolor=useFrameColor)
      success = True
    except:
      # some kind of error occurred
      self.parent.statusbar.showMessage('Cannot generate temporary file ' + filename, self.parent.STATUS_TIME)
      
    # revert to old dimensions
    self.parent.plotArea.matplot.set_size_inches(currwidth, currheight)
      
    # issue plot redraws b/c for some reason display vanishes
    self.parent.plotArea.dataplotwidget.myRefresh()
    
    # now open a new window to display the preview image
    if(success):
      if(not (hasattr(self.parent, 'previewWindow'))):
        self.parent.previewWindow = PreviewWindow()
        self.parent.previewWindow.setWindowTitle('Preview')
    
        self.centralwidget = QWidgetMac(self.parent.previewWindow)
        self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(320), scaledDPI(240)))
        self.parent.previewWindow.setCentralWidget(self.centralwidget)
        
        self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.vLayout.setContentsMargins(*[scaledDPI(2)]*4)
        
        # export button
        self.clipboardButton = QPushButtonMac()
        self.clipboardButton.setText('Copy to Clipboard')
        self.clipboardButton.setMaximumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.clipboardButton.setMinimumSize(QtCore.QSize(scaledDPI(150), scaledDPI(BASE_SIZE)))
        self.clipboardButton.clicked.connect(self.copyImageClipboard)
        self.vLayout.addWidget(self.clipboardButton)
  
        # generate QLabel for display
        self.displayPreview = QtWidgets.QLabel()
        self.vLayout.addWidget(self.displayPreview)
        self.parent.previewWindow.setDisplayPreview(self.displayPreview)
        
      # update picture
      self.displayPicture = QtGui.QPixmap(filename)
      currSize = self.displayPicture.size()
      # scale to compensate DPI ratio 150/100
      self.scaledPicture = self.displayPicture.scaled(currSize.width() / 1.5, currSize.height() / 1.5, QtCore.Qt.KeepAspectRatio)
      self.displayPreview.resize(self.scaledPicture.width(), self.scaledPicture.height())
      self.displayPreview.setPixmap(self.scaledPicture)
      # explicitly update windows size
      self.parent.previewWindow.setFixedSize(self.vLayout.sizeHint())
      
      # apply styles and show
      if(QSTYLE != None):
        self.parent.previewWindow.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.parent.previewWindow.setStyleSheet(QSTYLESHEET)
      self.parent.previewWindow.show()
      self.parent.previewWindow.activateWindow()
      self.parent.previewWindow.focusNextChild()

  def copyImageClipboard(self):
    # copies preview image to clipboard
    data = QtCore.QMimeData()
    # first check whether we still find the temp image file generated for the preview
    filename = WORKINGDIR + PATH_SEPARATOR + TEMP_PREVIEWFILE
    if(isfile(filename)):
      url = QtCore.QUrl.fromLocalFile(filename)
      data.setUrls([url])

    # for good measure also add a regular bitmap image and let downstream applications chose which to use
    if(hasattr(self, 'displayPicture')):
      image = self.displayPicture.toImage()
      data.setImageData(image)
      
    # check whether we managed to retrieve any image
    if(len(data.formats())):
      QtWidgets.QApplication.clipboard().setMimeData(data)
      
  def setAdvancedExport(self, key=None, value=None):
    # updates advanced export settings
    if(key in self.advancedExport):
      self.advancedExport[key] = value

  def setAdvancedGraphics(self, value=True):
    # toggles advanced graphics options
    self.advancedExport['advancedGraphics'] = value
    for entry in self.advancedGraphicsSettings:
      if(value):
        if(hasattr(entry, 'show')):
          entry.show()
      elif(hasattr(entry, 'hide')):
        entry.hide()
    # special treatment for splitAxes control
    value =  value and self.parent.plotArea.splitShow
    for item in ['configInnerBox2', 'configInnerBox3', 'configInnerMinorTickBox']:
      if(hasattr(self, item)):
        entry = self.__dict__[item]
        if(value):
          if(hasattr(entry, 'show')):
            entry.show()
        elif(hasattr(entry, 'hide')):
          entry.hide()

  def reportThis(self):
    # generates an HTML report
    self.parent.resultsarea.exportWrapper(modeHTMLOnly=True)

  def exportThis(self):
    global REMEMBERDIR
    # exports current figure and residuals
    filter_options = ['PDF files (*.pdf)', 'Scalable vector graphic (*.svg)', 'Postscript (*.ps)', 'Encapsulated postscript (*.eps)', 'PNG image (*.png)', 'Python script (*.py)', 'All files (*.*)']
    format_options = ['pdf', 'svg', 'ps', 'eps', 'png', 'py', 'pdf']
    filterstring = ';;'.join(filter_options)
    # get save file name
    usedir = REMEMBERDIR
    if(self.currExportFile != None):
      usedir = self.currExportFile
    filename, filter_ = QtWidgets.QFileDialog.getSaveFileName(self, filter = filterstring, directory=usedir, caption='Export Graphics', initialFilter=self.exportFilter)
    self.exportFilter = filter_
    filename = str(filename)
    if(PATH_SEPARATOR in filename):
      REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    elif('/' in filename):
      REMEMBERDIR = filename.split('/')[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    
    # evaluate file format
    if(filter_ in filter_options):
      index = filter_options.index(filter_)
      format_ = format_options[index]
    else:
      # use PDF as default
      format_ = 'pdf'
    
    # check whether save as Python script selected
    if(format_ != 'py'):
      # enable text export to SVG
      if (format_ == 'svg'):
        if(self.advancedExport['SVGtxt2path']):
          matplotlib.rcParams.update({'svg.fonttype': 'path'})
        else:
          matplotlib.rcParams.update({'svg.fonttype': 'none'})
      # save main graphics
      # obtain target dimensions
      targetwidth = float(self.exportSizeX.text())
      targetheight = float(self.exportSizeY.text())
      # obtain current dimensions
      currwidth, currheight = self.parent.plotArea.matplot.get_size_inches()
      
      if(self.parent.plotArea.figureFill):
        useFaceColor = self.parent.plotArea.figureColor
      else:
        useFaceColor = 'none'
      if(self.parent.plotArea.frameDraw):
        useFrameColor = self.parent.plotArea.frameColor
      else:
        useFrameColor = 'none'
      # set new dimensions and save
      self.parent.plotArea.matplot.set_size_inches(targetwidth, targetheight)
      try:
        self.parent.plotArea.matplot.savefig(filename, format=format_, dpi=self.advancedExport['plotDPI'], facecolor=useFaceColor, edgecolor=useFrameColor)
        # save filename for future reference
        self.currExportFile = filename
      except:
        # some kind of error occurred
        self.parent.statusbar.showMessage('Cannot save graphics file ' + filename, self.parent.STATUS_TIME)
      
      # revert to old dimensions
      self.parent.plotArea.matplot.set_size_inches(currwidth, currheight)
      
      # save resid graphics?
      if(self.advancedExport['plotResid']):
        if('.' in filename):
          filename_split = filename.split('.')
          filename = '.'.join(filename_split[:-1])
          filename += '_resid.' + filename_split[-1]
        else:
          filename += '_resid'
        # obtain target dimensions
        targetwidth = float(self.exportSizeX.text())
        targetheight = float(self.exportSizeY.text())/4.0
        # obtain current dimensions
        currwidth, currheight = self.parent.plotArea.residplot.get_size_inches()
        
        # set new dimensions and save
        self.parent.plotArea.residplot.set_size_inches(targetwidth, targetheight)
        try:
          self.parent.plotArea.residplot.savefig(filename, format=format_, dpi=self.advancedExport['plotDPI'], facecolor=useFaceColor, edgecolor=useFrameColor)
        except:
          # some kind of error occurred
          self.parent.statusbar.showMessage('Cannot save graphics file ' + filename, self.parent.STATUS_TIME)
        
        # revert to old dimensions
        self.parent.plotArea.residplot.set_size_inches(currwidth, currheight)
        
      # issue plot redraws b/c for some reason display vanishes
      self.parent.plotArea.dataplotwidget.myRefresh()
      self.parent.plotArea.residplotwidget.myRefresh()
    else:
      # save graphics as Python script
      pythonOutput = '##############################################\n# plot script generated by Fit-o-mat         #\n'
      pythonOutput += '# version ' + VERSION + '                              #\n'
      pythonOutput += '''# by A.M. (andreas.moeglich@uni-bayreuth.de) #
##############################################

# initialization
import matplotlib      
import matplotlib.pyplot as plt
from matplotlib import patheffects as PathEffects
import numpy as np
from numpy import abs, arccos, arcsin, arctan, exp, cos, cosh, log, log2, log10, power, sin, sinh, sqrt, tan, tanh

# create figures for data/curves and residuals
plt.ioff()
matplot = plt.figure()
residplot = plt.figure()

'''
      # apply xkcd and pathEffects up front
      settings = self.parent.plotArea.rememberSetting
      for entry in ['xkcd', 'pathEffects']:
       if entry in settings:
         pythonOutput += settings[entry]
         
      # check whether we should display second axis
      if(self.parent.plotArea.isSecondAxesActive()):
        pythonOutput += '''
# define 2nd axes system      
ax2 = matplot.add_subplot(111)
ax2.xaxis.set_label_text('x')
ax2.yaxis.set_label_text('y')
ax2.yaxis.set_label_position('right')
ax2.yaxis.set_ticks_position('right')
gridlines = ax2.get_xgridlines()
gridlines.extend(ax2.get_ygridlines())
for entry in gridlines:
  entry.set_visible(False)
ax2.patch.set_facecolor('none')
'''
        pythonOutput += 'ax2.set_xscale(' + repr(self.parent.plotArea.modeX) + ')\n'
        pythonOutput += 'ax2.set_yscale(' + repr(self.parent.plotArea.modeY2) + ')\n'
        pythonOutput += '''# define 1st axes system
ax = ax2.twinx()
ax.xaxis.set_visible(False)
ax.yaxis.set_label_position('left')
ax.yaxis.set_ticks_position('left')
# for good measure, reset label position for ax2
ax2.yaxis.set_ticks_position('right')'''
      else:
        pythonOutput += '''\n
# define axes system      
ax = matplot.add_subplot(111)'''

      pythonOutput += '''
ax_resid = residplot.add_subplot(111)

curves = []
dataset = []
extras = []

# set axes scale
'''
      # set linear/log on axes
      pythonOutput += 'ax.set_xscale(' + repr(self.parent.plotArea.modeX) + ')\n'
      pythonOutput += 'ax.set_yscale(' + repr(self.parent.plotArea.modeY) + ')\n'
      pythonOutput += 'ax_resid.set_xscale(' + repr(self.parent.plotArea.modeX) + ')\n'
      pythonOutput += 'ax_resid.set_yscale(\'linear\')'

      # cycle over all extras
      for index in range(len(self.parent.extras)):
        # generate curve
        pythonOutput += '\n\n###############\n'
        pythonOutput += '# extra no. ' + str(index) + ' #\n'
        pythonOutput += '###############\n'
        
        # obtain settings
        settings = self.parent.extras[index].rememberSetting
        
        # plot and format extra
        if(('origin_before' in settings) and (settings['origin_before'] != '')):
          pythonOutput += settings['origin_before'] + '\n'
          
        if('origin' in settings):
          pythonOutput += 'extras.append({})\n'
          if(settings['origin'].startswith('plot')):
            pythonOutput += 'extras[-1][\'handle\'], = ax.' + settings['origin'] + '\n'
          else:
            pythonOutput += 'extras[-1][\'handle\'] = ax.' + settings['origin'] + '\n'
            
          # apply styles to extra
          for entry in settings:
            if(not (entry in ['origin', 'origin_before'])):
              pythonOutput += 'extras[-1][\'handle\'].' + settings[entry] + '\n'

      # cycle over all curves
      for index in range(len(self.parent.fit)):
        # generate curve
        pythonOutput += '\n\n###############\n'
        pythonOutput += '# curve no. ' + str(index) + ' #\n'
        pythonOutput += '###############\n'
        data = self.parent.fit[index].reportState()
        if(self.parent.fit[index].onSecondAxes):
          currAxis = 'ax2'
        else:
          currAxis = 'ax'

        # write function
        param = data['paramAll']
        pythonOutput += '# define function\n'
        pythonOutput += 'def ffunc_' + str(index) + '(x, ' + ', '.join(data['paramNames']) + '):\n'
        pythonOutput += '\t' + '\n\t'.join(data['ffuncstr_base'].split('\n'))
        pythonOutput += '\n\treturn y\n\n'

        # write curve data
        pythonOutput += '# curve data\n'
        pythonOutput += 'curves.append({})\n'
        pythonOutput += 'curves[-1][\'x\'] = np.array(' + self.wrapString(repr(data['x'])) + ')\n\n'
        
        # plot and format function
        pythonOutput += '# plot and format curve\n'
        param = data['paramAll']
        pythonOutput += 'param_' + str(index) + ' = ' + repr(param) + '\n'
        
        # plot curve
        pythonOutput += 'curves[-1][\'handle\'], = ' + currAxis + '.plot(curves[-1][\'x\'], ffunc_' + str(index)
        if(len(param)):
          pythonOutput += '(curves[-1][\'x\'], *param_' + str(index) + '))\n'
        else:
          pythonOutput += '(curves[-1][\'x\']))\n'
          
        # apply styles to curve
        settings = self.parent.fit[index].rememberSetting
        for entry in settings:
          pythonOutput += 'curves[-1][\'handle\'].' + settings[entry] + '\n'
          
      # cycle over all data sets
      for index in range(len(self.parent.data)):
        # generate data set
        pythonOutput += '\n\n##############\n'
        pythonOutput += '# data no. ' + str(index) + ' #\n'
        pythonOutput += '##############\n'
        data = self.parent.data[index].reportState()
        if(self.parent.data[index].onSecondAxes):
          currAxis = 'ax2'
        else:
          currAxis = 'ax'

        # write plot data
        pythonOutput += 'dataset.append({})\n'
        for entry in ['x', 'y', 'yerr', 'resid']:
          if(entry in data):
            pythonOutput += 'dataset[-1][' + repr(entry) + '] = np.array(' + self.wrapString(repr(data[entry])) + ')\n\n'
        
        # plot and format function
        if(('x' in data) and ('y' in data)):
          pythonOutput += '# plot and format line/scatter graphics\n'
          pythonOutput += 'dataset[-1][\'handle\'], = ' + currAxis + '.plot(dataset[-1][\'x\'], dataset[-1][\'y\'])\n'
          # apply styles to data set
          settings = self.parent.data[index].rememberSetting
          for entry in settings:
            pythonOutput += 'dataset[-1][\'handle\'].' + settings[entry] + '\n'
          
          # check for presence of stack plot
          if(self.parent.data[index].handleStack != None):
            pythonOutput += '\n# plot and format stackplot graphics\n'
            pythonOutput += 'dataset[-1][\'handleStack\'], = ' + currAxis + '.stackplot(dataset[-1][\'x\'], dataset[-1][\'y\'], where=(dataset[-1][\'y\'] >= 0), interpolate=True)\n'
            # apply styles to bar graphics
            settings = self.parent.data[index].rememberSettingStack
            for entry in settings:
              pythonOutput += 'dataset[-1][\'handleStack\'].' + settings[entry] + '\n'
          
          # check for presence of negative stack plot
          if(self.parent.data[index].handleStackNeg != None):
            pythonOutput += '\n# plot and format stackplot graphics\n'
            pythonOutput += 'dataset[-1][\'handleStackNeg\'], = ' + currAxis + '.stackplot(dataset[-1][\'x\'], dataset[-1][\'y\'], where=(dataset[-1][\'y\'] < 0), interpolate=True)\n'
            # apply styles to bar graphics
            settings = self.parent.data[index].rememberSettingStackNeg
            for entry in settings:
              if(entry != 'facecolor'):
                pythonOutput += 'dataset[-1][\'handleStackNeg\'].' + settings[entry] + '\n'
          
          # check for presence of bar plot
          if(self.parent.data[index].handleBar != None):
            pythonOutput += '\n# plot and format bar graphics\n'
            offset = self.parent.data[index].Barstyle['offset']
            pythonOutput += 'offset = ' + repr(offset) + '\n'
            useWidth = self.parent.data[index].Barstyle['width']
            pythonOutput += 'dataset[-1][\'handleBar\'] = ' + currAxis + '.bar(dataset[-1][\'x\'] + offset, dataset[-1][\'y\'], width=' + repr(useWidth) +')\n'
            # apply styles to bar graphics
            settings = self.parent.data[index].rememberSettingBar
            if(len(settings.keys())):
              pythonOutput += 'for entry in dataset[-1][\'handleBar\']:\n'
              for entry in settings:
                if(not (entry.startswith('facecolor'))):
                  pythonOutput += '\tentry.' + settings[entry] + '\n'
            for item in ['facecolor', 'facecolorAlt']:
              if(item in settings):
                pythonOutput += 'for entry in dataset[-1][\'handleBar\'].patches:\n'
                if(item == 'facecolor'):
                  pythonOutput += '\tif(entry.get_height() >= 0):\n'
                  pythonOutput += '\t\tentry.' + settings['facecolor'] + '\n'
                else:
                  pythonOutput += '\tif(entry.get_height() < 0):\n'
                  pythonOutput += '\t\tentry.' + settings['facecolorAlt'] + '\n'
          else:
            pythonOutput += 'offset = 0.0\n'
          
          # check for presence of error
          if(('yerr' in data) and (self.parent.data[index].handleErr != None)):
            pythonOutput += '\n# plot and format error bars\n'
            pythonOutput += 'dataset[-1][\'handleErr\'] = ' + currAxis + '.errorbar(dataset[-1][\'x\'] + offset, dataset[-1][\'y\'], yerr=dataset[-1][\'yerr\'], capsize=1)\n'
            # apply styles to error bars
            pythonOutput += 'dataset[-1][\'handleErr\'][0].set_linewidth(0)\n'
            pythonOutput += 'dataset[-1][\'handleErr\'][0].set_markersize(0)\n'
            settings = self.parent.data[index].rememberSettingError
            if(len(self.parent.data[index].handleErr[1])):
              pythonOutput += 'for entry in dataset[-1][\'handleErr\'][1]:\n'
              for entry in settings:
                if(hasattr(self.parent.data[index].handleErr[1][0], 'set_' + entry)):
                  # prevent turning on off connecting lines
                  if(entry == 'linewidth'):
                    pythonOutput += '\tentry.set_linewidth(0)\n'
                  else:
                    pythonOutput += '\tentry.' + settings[entry] + '\n'
            if(len(self.parent.data[index].handleErr[2])):
              pythonOutput += 'for entry in dataset[-1][\'handleErr\'][2]:\n'
              for entry in settings:
                if(hasattr(self.parent.data[index].handleErr[2][0], 'set_' + entry)):
                  pythonOutput += '\tentry.' + settings[entry] + '\n'

          # check for presence of error shading
          if(('yerr' in data) and (self.parent.data[index].handleErrShady != None)):
            pythonOutput += '\n# plot and format error shading\n'
            pythonOutput += 'dataset[-1][\'handleErrShady\'] = ' + currAxis + '.fill_between(dataset[-1][\'x\'] + offset, dataset[-1][\'y\'] - dataset[-1][\'yerr\'], dataset[-1][\'y\'] + dataset[-1][\'yerr\'])\n'
            # apply styles to error bars
            settings = self.parent.data[index].rememberSettingErrorShady
            for entry in settings:
              if(hasattr(self.parent.data[index].handleErrShady, 'set_' + entry)):
                pythonOutput += 'dataset[-1][\'handleErrShady\'].' + settings[entry] + '\n'

          # check for presence of residuals
          if(('resid' in data) and (len(data['resid']) == len(data['x']))):
            pythonOutput += '\n# plot and format line/scatter graphics of residuals\n'
            pythonOutput += 'dataset[-1][\'handleResid\'], = ax_resid.plot(dataset[-1][\'x\'], dataset[-1][\'resid\'])\n'
            # apply styles to bar graphics
            settings = self.parent.data[index].rememberSettingResid
            for entry in settings:
              pythonOutput += 'dataset[-1][\'handleResid\'].' + settings[entry] + '\n'

            # check for presence of resid stack plot
            if(self.parent.data[index].handleResidStack != None):
              pythonOutput += '\n# plot and format stackplot graphics of residuals\n'
              pythonOutput += 'dataset[-1][\'handleResidStack\'], = ax_resid.stackplot(dataset[-1][\'x\'], dataset[-1][\'resid\'], where=(dataset[-1][\'resid\'] >= 0), interpolate=True)\n'
              # apply styles to bar graphics
              settings = self.parent.data[index].rememberSettingResidStack
              for entry in settings:
                pythonOutput += 'dataset[-1][\'handleResidStack\'].' + settings[entry] + '\n'
            
            # check for presence of negative resid stack plot
            if(self.parent.data[index].handleResidStackNeg != None):
              pythonOutput += '\n# plot and format stackplot graphics of residuals\n'
              pythonOutput += 'dataset[-1][\'handleResidStackNeg\'], = ax_resid.stackplot(dataset[-1][\'x\'], dataset[-1][\'resid\'], where=(dataset[-1][\'resid\'] < 0), interpolate=True)\n'
              # apply styles to bar graphics
              settings = self.parent.data[index].rememberSettingResidStackNeg
              for entry in settings:
                if(entry != 'facecolor'):
                  pythonOutput += 'dataset[-1][\'handleResidStackNeg\'].' + settings[entry] + '\n'
          
            # check for presence of resid bar plot
            if(self.parent.data[index].handleResidBar != None):
              pythonOutput += '\n# plot and format bar graphics of residuals\n'
              offset = self.parent.data[index].ResidBarstyle['offset']
              pythonOutput += 'offset = ' + repr(offset) + '\n'
              useWidth = self.parent.data[index].ResidBarstyle['width']
              pythonOutput += 'dataset[-1][\'handleResidBar\'] = ax_resid.bar(dataset[-1][\'x\'] + offset, dataset[-1][\'resid\'], width=' + repr(useWidth) +')\n'
              # apply styles to bar graphics
              settings = self.parent.data[index].rememberSettingResidBar
              if(len(settings.keys())):
                pythonOutput += 'for entry in dataset[-1][\'handleResidBar\']:\n'
                for entry in settings:
                  if(not (entry.startswith('facecolor'))):
                    pythonOutput += '\tentry.' + settings[entry] + '\n'
              for item in ['facecolor', 'facecolorAlt']:
                if(item in settings):
                  pythonOutput += 'for entry in dataset[-1][\'handleResidBar\'].patches:\n'
                  if(item == 'facecolor'):
                    pythonOutput += '\tif(entry.get_height() >= 0):\n'
                    pythonOutput += '\t\tentry.' + settings['facecolor'] + '\n'
                  else:
                    pythonOutput += '\tif(entry.get_height() < 0):\n'
                    pythonOutput += '\t\tentry.' + settings['facecolorAlt'] + '\n'
            else:
              pythonOutput += 'offset = 0.0\n'
 
      # draw residline zero
      settings = self.parent.plotArea.rememberSettingResidLine
      if('init' in settings):
        pythonOutput += '\n# plot and format zero line of residuals\n'
        pythonOutput += 'handleResidLine, = ' + settings['init'] + '\n'
        for entry in settings:
          if(entry != 'init'):
            pythonOutput += 'handleResidLine.' + settings[entry] + '\n'

      # apply plot settings
      pythonOutput += '\n\n###########################\n'
      pythonOutput += '# general plot formatting #\n'
      pythonOutput += '###########################\n'
      pythonOutput += 'ax.grid(b=True)\nax_resid.grid(b=True)\n'
      settings = self.parent.plotArea.rememberSetting
      if(not self.parent.plotArea.isSecondAxesActive()):
        toKill = []
        # replace ax2 by ax in this case
        for entry in settings:
          ###if(settings[entry].startswith('ax2.')):
          ###  settings[entry] = settings[entry].replace('ax2.', 'ax.', 1)
          if(('set_ticks_position' in settings[entry]) and ('ax2' in settings[entry])):
            # kill this item to prevent erroneous axis display
            toKill.append(entry)
          else:
            settings[entry] = settings[entry].replace('ax2.', 'ax.')
        for entry in toKill:
            del settings[entry]
      for entry in sorted(settings.keys()):
        if(not entry in ['xkcd', 'PathEffects']):
          pythonOutput += settings[entry]# + '\n'

      # set axes limits
      pythonOutput += 'ax.set_xlim([' + repr(self.parent.plotArea.minX) + ', ' + repr(self.parent.plotArea.maxX) + '])\n'
      pythonOutput += 'ax.set_ylim([' + repr(self.parent.plotArea.minY) + ', ' + repr(self.parent.plotArea.maxY) + '])\n'
      pythonOutput += 'ax_resid.set_xlim([' + repr(self.parent.plotArea.minX) + ', ' + repr(self.parent.plotArea.maxX) + '])\n'
      pythonOutput += 'ax_resid.set_ylim([' + repr(self.parent.plotArea.minResidY) + ', ' + repr(self.parent.plotArea.maxResidY) + '])\n'
      if(self.parent.plotArea.isSecondAxesActive()):
        pythonOutput += 'ax2.set_xlim([' + repr(self.parent.plotArea.minX) + ', ' + repr(self.parent.plotArea.maxX) + '])\n'
        pythonOutput += 'ax2.set_ylim([' + repr(self.parent.plotArea.minY2) + ', ' + repr(self.parent.plotArea.maxY2) + '])\n'

      # set window size
      targetwidth = float(self.exportSizeX.text())
      targetheight = float(self.exportSizeY.text())
      pythonOutput += 'matplot.set_size_inches('+ repr(targetwidth) + ', ' + repr(targetheight) +')\n'
      pythonOutput += 'residplot.set_size_inches('+ repr(targetwidth) + ', ' + repr(targetheight / 4.0) +')\n'

      # plot the data and show
      pythonOutput += '\n\n##########################\n'
      pythonOutput += '# draw and display plots #\n'
      pythonOutput += '##########################\n'
      pythonOutput += 'plt.draw()\nplt.show()\n'
      
      # save output to file
      try:
        writehandle = open(filename, 'w', encoding='utf-8')
        writehandle.write(pythonOutput)
        writehandle.close()
        # save filename for future reference
        self.currExportFile = filename
      except:
        self.parent.statusbar.showMessage('Error writing Python output file ' + filename, self.parent.STATUS_TIME)
  
  def wrapString(self, string, limit=80, breakat=',', delimiter='\n\t'):
    # wraps long string into several lines
    outstring = ''
    while(len(string)):
      if((len(string) <= limit) or (string[limit:].find(breakat) == -1)):
        outstring += string
        string = ''
      else:
        breakposition = limit + string[limit:].find(breakat)
        outstring += string[:breakposition + 1] + delimiter
        string = string[breakposition + 1:]
    return outstring

class myCentralWidget(QWidgetMac):
  def __init__(self, argument=None, parent=None):
    super(myCentralWidget, self).__init__(argument)
    self.parent = parent

  def resizeEvent(self, event):
    # custom resize event
    self.parent.plotArea.destructAboutLogo()
    QWidgetMac.resizeEvent(self, event)
    
class myQMessageBox(QtWidgets.QMessageBox):
  def __init__(self, argument=None, parent=None):
    super(myQMessageBox, self).__init__(argument)
    self.parent = parent
    # add checkbox
    self.discardCheckBox = QtWidgets.QCheckBox()
    self.discardCheckBox.setText('Do not ask again')
    self.setCheckBox(self.discardCheckBox)

  def exec_(self, *args, **kwargs):
    # override exec_ to return additional argument
    return QtWidgets.QMessageBox.exec_(self, *args, **kwargs), not self.discardCheckBox.isChecked()

class OptionMenu(KuhMenu):
  def __init__(self, parent = None):
    super(OptionMenu, self).__init__()
    self.parent = parent
      
    # float validator
    self.validFloat = MyValidFloat()
    self.validInt = MyValidInt()

    # set up GUI
    self.buildRessource()

  def mousePressEvent(self, event):
    # check whether click event is within widget
    if(not self.underMouse()):
      # pass through event (and thereby close the QMenu)
      KuhMenu.mousePressEvent(self, event)

  def buildRessource(self):
    # build gui for setting options
    self.hLayout0 = QtWidgets.QHBoxLayout(self)
    self.hLayout0.setContentsMargins(*[0]*4)
    self.hLayout0.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    
    self.exportOptionsGroup = QWidgetMac()
    self.hLayout0.addWidget(self.exportOptionsGroup)    
    self.vLayout = QtWidgets.QVBoxLayout(self.exportOptionsGroup)
    self.vLayout.setContentsMargins(*[0]*4)
    self.vLayout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout.setSpacing(scaledDPI(2))
    
    # heading
    self.exportSettingLabel = QtWidgets.QLabel()
    useFont = self.exportSettingLabel.font()
    useFont.setBold(True)
    self.exportSettingLabel.setFont(useFont)
    self.exportSettingLabel.setText('Export options')
    self.vLayout.addWidget(self.exportSettingLabel)    
    
    # export options
    # plot resid?
    self.exportResidGroup = QWidgetMac()
    self.vLayout.addWidget(self.exportResidGroup)
    self.hLayout = QtWidgets.QHBoxLayout(self.exportResidGroup)
    self.hLayout.setContentsMargins(0, 0, 0, 0)
    self.hLayout.setAlignment(QtCore.Qt.AlignLeft)
    self.exportResidLabel = QtWidgets.QLabel('export resid')
    self.exportResidLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.exportResidLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout.addWidget(self.exportResidLabel)
    self.exportResidCheck = QPushButtonCheckable()
    self.exportResidCheck.setCheckMe(True)
    self.exportResidCheck.setChecked(self.parent.graphicsarea.advancedExport['plotResid'])
    self.exportResidCheck.clicked.connect(partial(self.toggleOption, self.exportResidCheck, 'plotResid'))
    self.exportResidCheck.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.exportResidCheck.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.hLayout.addWidget(self.exportResidCheck)

    # plot DPI
    self.exportDPIGroup = QWidgetMac()
    self.vLayout.addWidget(self.exportDPIGroup)
    self.hLayout2 = QtWidgets.QHBoxLayout(self.exportDPIGroup)
    self.hLayout2.setContentsMargins(0, 0, 0, 0)
    self.hLayout2.setAlignment(QtCore.Qt.AlignLeft)
    self.exportDPILabel = QtWidgets.QLabel('export DPI')
    self.exportDPILabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.exportDPILabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout2.addWidget(self.exportDPILabel)

    self.exportDPIEntry = QLineEditClick()
    self.exportDPIEntry.setText(str(self.parent.graphicsarea.advancedExport['plotDPI']))
    self.exportDPIEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.exportDPIEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.exportDPIEntry.editingFinished.connect(partial(self.changeOption, self.exportDPIEntry, 'plotDPI', 60, 1200))
    self.exportDPIEntry.setValidator(self.validFloat)
    self.hLayout2.addWidget(self.exportDPIEntry)

    # SVG txt2path
    self.svgPathGroup = QWidgetMac()
    self.vLayout.addWidget(self.svgPathGroup)
    self.hLayout3 = QtWidgets.QHBoxLayout(self.svgPathGroup)
    self.hLayout3.setContentsMargins(0, 0, 0, 0)
    self.hLayout3.setAlignment(QtCore.Qt.AlignLeft)
    self.svgPathLabel = QtWidgets.QLabel('SVG txt2path')
    self.svgPathLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.svgPathLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout3.addWidget(self.svgPathLabel)

    self.svgPathCheck = QPushButtonCheckable(self.svgPathGroup)
    self.svgPathCheck.setCheckMe(True)
    self.svgPathCheck.setChecked(self.parent.graphicsarea.advancedExport['SVGtxt2path'])
    self.svgPathCheck.clicked.connect(partial(self.toggleOption, self.exportResidCheck, 'SVGtxt2path'))
    self.svgPathCheck.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.svgPathCheck.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.hLayout3.addWidget(self.svgPathCheck)
    
    # heading
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.graphicsSettingLabel = QtWidgets.QLabel()
    useFont = self.graphicsSettingLabel.font()
    useFont.setBold(True)
    self.graphicsSettingLabel.setFont(useFont)
    self.graphicsSettingLabel.setText('Graphics options')
    self.vLayout.addWidget(self.graphicsSettingLabel)    

    # plot resid?
    self.advancedGraphicsGroup = QWidgetMac()
    self.vLayout.addWidget(self.advancedGraphicsGroup)
    self.hLayout35 = QtWidgets.QHBoxLayout(self.advancedGraphicsGroup)
    self.hLayout35.setContentsMargins(0, 0, 0, 0)
    self.hLayout35.setAlignment(QtCore.Qt.AlignLeft)
    self.advancedGraphicsLabel = QtWidgets.QLabel('advanced')
    self.advancedGraphicsLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.advancedGraphicsLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout35.addWidget(self.advancedGraphicsLabel)

    self.advancedGraphicsCheck = QPushButtonCheckable(self.advancedGraphicsGroup)
    self.advancedGraphicsCheck.setCheckMe(True)
    self.advancedGraphicsCheck.setChecked(self.parent.graphicsarea.advancedExport['plotResid'])
    self.advancedGraphicsCheck.setChecked(self.parent.graphicsarea.advancedExport['advancedGraphics'])
    self.advancedGraphicsCheck.clicked.connect(self.toggleGraphicsOption)
    self.advancedGraphicsCheck.setMaximumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.advancedGraphicsCheck.setMinimumSize(QtCore.QSize(scaledDPI(BASE_SIZE - 2), scaledDPI(BASE_SIZE - 2)))
    self.hLayout35.addWidget(self.advancedGraphicsCheck)

    # heading
    blah = self.HLine()
    self.vLayout.addWidget(blah)
    self.stateFileSettingLabel = QtWidgets.QLabel()
    useFont = self.stateFileSettingLabel.font()
    useFont.setBold(True)
    self.stateFileSettingLabel.setFont(useFont)
    self.stateFileSettingLabel.setText('Save state files')
    self.vLayout.addWidget(self.stateFileSettingLabel)    

    self.stateFileFormatGroup = QWidgetMac()
    self.vLayout.addWidget(self.stateFileFormatGroup)
    self.hLayout31 = QtWidgets.QHBoxLayout(self.stateFileFormatGroup)
    self.hLayout31.setContentsMargins(0, 0, 0, 0)
    self.hLayout31.setAlignment(QtCore.Qt.AlignLeft)
    self.stateFileFormatLabel = QtWidgets.QLabel('format')
    self.stateFileFormatLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.stateFileFormatLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout31.addWidget(self.stateFileFormatLabel)

    self.stateFileFormat = QComboBoxMac()
    self.availableStateFileFormats = ['state', 'statez', 'both']
    self.stateFileFormat.addItems(self.availableStateFileFormats)
    self.stateFileFormat.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.stateFileFormat.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.hLayout31.addWidget(self.stateFileFormat)
    if(self.parent.graphicsarea.advancedExport['stateFileFormat'] in self.availableStateFileFormats):
      currindex = self.availableStateFileFormats.index(self.parent.graphicsarea.advancedExport['stateFileFormat'])
      self.stateFileFormat.setCurrentIndex(currindex)
    else:
      self.stateFileFormat.setCurrentIndex(0)
    self.stateFileFormat.activated.connect(self.changeStateFileFormat)
    
    # minimization options
    blah = self.VLine()
    self.hLayout0.addWidget(blah)

    self.minOptionsGroup = QWidgetMac()
    self.hLayout0.addWidget(self.minOptionsGroup)    
    self.vLayout2 = QtWidgets.QVBoxLayout(self.minOptionsGroup)
    self.vLayout2.setContentsMargins(*[0]*4)
    self.vLayout2.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout2.setSpacing(scaledDPI(2))
    
    # heading
    self.minSettingLabel = QtWidgets.QLabel()
    useFont = self.minSettingLabel.font()
    useFont.setBold(True)
    self.minSettingLabel.setFont(useFont)
    self.minSettingLabel.setText('Minimization options')
    self.vLayout2.addWidget(self.minSettingLabel)    
    
    # which algorithm?
    self.minAlgorithmGroup = QWidgetMac()
    self.vLayout2.addWidget(self.minAlgorithmGroup)
    self.hLayout4 = QtWidgets.QHBoxLayout(self.minAlgorithmGroup)
    self.hLayout4.setContentsMargins(0, 0, 0, 0)
    self.hLayout4.setAlignment(QtCore.Qt.AlignLeft)
    self.minAlgorithmLabel = QtWidgets.QLabel('algorithm')
    self.minAlgorithmLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.minAlgorithmLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.minAlgorithmLabel)

    self.minAlgorithm = QComboBoxMac()
    self.availableMinAlgorithms = ['Nelder-Mead', 'Powell', 'CG', 'BFGS']
    self.minAlgorithm.addItems(self.availableMinAlgorithms)
    self.minAlgorithm.setMaximumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.minAlgorithm.setMinimumSize(QtCore.QSize(scaledDPI(80), scaledDPI(BASE_SIZE)))
    self.hLayout4.addWidget(self.minAlgorithm)
    if(self.parent.fitarea.advancedMinimization['algorithm'] in self.availableMinAlgorithms):
      currindex = self.availableMinAlgorithms.index(self.parent.fitarea.advancedMinimization['algorithm'])
      self.minAlgorithm.setCurrentIndex(currindex)
    else:
      self.minAlgorithm.setCurrentIndex(0)
    self.minAlgorithm.activated.connect(self.changeMinAlgorithm)
  
    # which tolerance
    self.minToleranceGroup = QWidgetMac()
    self.vLayout2.addWidget(self.minToleranceGroup)
    self.hLayout5 = QtWidgets.QHBoxLayout(self.minToleranceGroup)
    self.hLayout5.setContentsMargins(0, 0, 0, 0)
    self.hLayout5.setAlignment(QtCore.Qt.AlignLeft)
    self.minToleranceLabel = QtWidgets.QLabel('tolerance')
    self.minToleranceLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.minToleranceLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout5.addWidget(self.minToleranceLabel)

    self.minToleranceEntry = QLineEditClick()
    self.minToleranceEntry.setText(str(self.parent.fitarea.advancedMinimization['xtol']))
    self.minToleranceEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.minToleranceEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.minToleranceEntry.editingFinished.connect(partial(self.changeOptionMin, self.minToleranceEntry, 'xtol', 0, 1000))
    self.minToleranceEntry.setValidator(self.validFloat)
    self.hLayout5.addWidget(self.minToleranceEntry)

    # max fev
    self.minFevGroup = QWidgetMac()
    self.vLayout2.addWidget(self.minFevGroup)
    self.hLayout6 = QtWidgets.QHBoxLayout(self.minFevGroup)
    self.hLayout6.setContentsMargins(0, 0, 0, 0)
    self.hLayout6.setAlignment(QtCore.Qt.AlignLeft)
    self.minFevLabel = QtWidgets.QLabel('max. fev')
    self.minFevLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.minFevLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout6.addWidget(self.minFevLabel)

    self.minFevEntry = QLineEditClick()
    self.minFevEntry.setText(str(int(self.parent.fitarea.advancedMinimization['maxfev'])))
    self.minFevEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.minFevEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.minFevEntry.editingFinished.connect(partial(self.changeOptionMinInt, self.minFevEntry, 'maxfev', 1, 1e6))
    self.minFevEntry.setValidator(self.validInt)
    self.hLayout6.addWidget(self.minFevEntry)

    # heading
    blah = self.HLine()
    self.vLayout2.addWidget(blah)
    self.randomSettingLabel = QtWidgets.QLabel()
    useFont = self.randomSettingLabel.font()
    useFont.setBold(True)
    self.randomSettingLabel.setFont(useFont)
    self.randomSettingLabel.setText('Random search options')
    self.vLayout2.addWidget(self.randomSettingLabel)    
    
    # number cycles
    self.randomCyclesGroup = QWidgetMac()
    self.vLayout2.addWidget(self.randomCyclesGroup)
    self.hLayout7 = QtWidgets.QHBoxLayout(self.randomCyclesGroup)
    self.hLayout7.setContentsMargins(0, 0, 0, 0)
    self.hLayout7.setAlignment(QtCore.Qt.AlignLeft)
    self.randomCyclesLabel = QtWidgets.QLabel('#cycles')
    self.randomCyclesLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.randomCyclesLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout7.addWidget(self.randomCyclesLabel)

    self.randomCyclesEntry = QLineEditClick()
    self.randomCyclesEntry.setText(str(int(self.parent.fitarea.advancedRandomSearch['cycles'])))
    self.randomCyclesEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomCyclesEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomCyclesEntry.editingFinished.connect(partial(self.changeOptionRandomInt, self.randomCyclesEntry, 'cycles', 1, 20))
    self.randomCyclesEntry.setValidator(self.validInt)
    self.hLayout7.addWidget(self.randomCyclesEntry)

    # escalate
    self.randomEscalateGroup = QWidgetMac()
    self.vLayout2.addWidget(self.randomEscalateGroup)
    self.hLayout8 = QtWidgets.QHBoxLayout(self.randomEscalateGroup)
    self.hLayout8.setContentsMargins(0, 0, 0, 0)
    self.hLayout8.setAlignment(QtCore.Qt.AlignLeft)
    self.randomEscalateLabel = QtWidgets.QLabel('escalate')
    self.randomEscalateLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.randomEscalateLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout8.addWidget(self.randomEscalateLabel)

    self.randomEscalateEntry = QLineEditClick()
    self.randomEscalateEntry.setText(str(self.parent.fitarea.advancedRandomSearch['escalate']))
    self.randomEscalateEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomEscalateEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomEscalateEntry.editingFinished.connect(partial(self.changeOptionRandom, self.randomEscalateEntry, 'escalate', 0, 10))
    self.randomEscalateEntry.setValidator(self.validFloat)
    self.hLayout8.addWidget(self.randomEscalateEntry)

    # max fev
    self.randomFevGroup = QWidgetMac()
    self.vLayout2.addWidget(self.randomFevGroup)
    self.hLayout9 = QtWidgets.QHBoxLayout(self.randomFevGroup)
    self.hLayout9.setContentsMargins(0, 0, 0, 0)
    self.hLayout9.setAlignment(QtCore.Qt.AlignLeft)
    self.randomFevLabel = QtWidgets.QLabel('max. fev')
    self.randomFevLabel.setMaximumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.randomFevLabel.setMinimumSize(QtCore.QSize(scaledDPI(64), scaledDPI(BASE_SIZE)))
    self.hLayout9.addWidget(self.randomFevLabel)

    self.randomFevEntry = QLineEditClick()
    self.randomFevEntry.setText(str(int(self.parent.fitarea.advancedRandomSearch['maxfev'])))
    self.randomFevEntry.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomFevEntry.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.randomFevEntry.editingFinished.connect(partial(self.changeOptionRandomInt, self.randomFevEntry, 'maxfev', 1, 1e6))
    self.randomFevEntry.setValidator(self.validInt)
    self.hLayout9.addWidget(self.randomFevEntry)

    self.setFocus()    
    self.focusNextChild()
    
  def toggleGraphicsOption(self):
    # toggles display of advanced graphics
    value = self.advancedGraphicsCheck.isChecked()
    self.parent.graphicsarea.setAdvancedGraphics(value=value)
    self.parent.graphicsarea2.setAdvancedGraphics(value=value)

  def toggleOption(self, entryfield=None, key=None):
    # toggles option of target
    if((entryfield != None) and (key != None)):
      value = entryfield.isChecked()
      self.parent.graphicsarea.setAdvancedExport(key=key, value=value)

  def changeOption(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.graphicsarea.setAdvancedExport(key=key, value=value)

  def changeOptionMin(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.fitarea.setAdvancedMinimization(key=key, value=value)
      self.parent.globalarea.setAdvancedMinimization(key=key, value=value)

  def changeOptionMinInt(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = int(entryfield.text())
        originalvalue = value
      except:
        value = 0
        originalvalue = 1
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.fitarea.setAdvancedMinimization(key=key, value=value)
      self.parent.globalarea.setAdvancedMinimization(key=key, value=value)
      
  def changeOptionRandom(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = float(entryfield.text())
        originalvalue = value
      except:
        value = 0.0
        originalvalue = 1.0
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.fitarea.setAdvancedRandomSearch(key=key, value=value)
      self.parent.globalarea.setAdvancedRandomSearch(key=key, value=value)

  def changeOptionRandomInt(self, entryfield=None, key=None, minval=0, maxval=1):
    if((entryfield != None) and (key != None)):
      # check paramter boundaries
      try:
        value = int(entryfield.text())
        originalvalue = value
      except:
        value = 0
        originalvalue = 1
      value = np.min((value, maxval))
      value = np.max((value, minval))
      # update parameters
      if (value != originalvalue):
        entryfield.setText(str(value))
      self.parent.fitarea.setAdvancedRandomSearch(key=key, value=value)
      self.parent.globalarea.setAdvancedRandomSearch(key=key, value=value)
      
  def changeMinAlgorithm(self):
    useAlgorithm = str(self.minAlgorithm.currentText())
    self.parent.fitarea.setAdvancedMinimization(key='algorithm', value=useAlgorithm)
    self.parent.globalarea.setAdvancedMinimization(key='algorithm', value=useAlgorithm)

  def changeStateFileFormat(self):
    useStateFile = str(self.stateFileFormat.currentText())
    self.parent.graphicsarea.setAdvancedExport(key='stateFileFormat', value=useStateFile)

  def VLine(self):
    # draws a vertical line
    vline = QtWidgets.QFrame()
    vline.setFrameShape(QtWidgets.QFrame.VLine)
    vline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return vline

  def HLine(self):
    # draws a horizontal line
    hline = QtWidgets.QFrame()
    hline.setFrameShape(QtWidgets.QFrame.HLine)
    hline.setFrameShadow(QtWidgets.QFrame.Sunken)
    return hline

class Ui_MainWindow(object):
  def setupUi(self, MainWindow):
    # save MainWindow
    self.MainWindow = MainWindow
    # set up z-order counter
    self.zcount = 0
    # upshift all draw items in zo to ensure display in front of axes and gridlines
    self.zOffset = 3
    # default duration for status messages
    self.STATUS_TIME = 10000
    # set up data and fit objects
    self.fit = []
    self.fit.append(FitObject(self))
    self.data = []
    self.data.append(DataObject(self))
    self.extras = []
    self.activeData = 0
    self.activeFit = 0
    self.discardCheck = True
    self.discard = False
    self.zoomLevels = [25, 33, 50, 75, 100, 150, 200, 300, 400, 600]
    self.currStateFile = None
    self.lastFitType = 'none'
    
    # get font list
    self.fontList = matplotlib.font_manager.fontManager.ttflist
    self.fontNames = [i.name for i in self.fontList]
    self.fontNames= sorted(list(set(self.fontNames)))
    
    # set up GUI
    self.buildRessource()
    
    # print Fit-o-mat information (set counter to 2 to counteract initial widget resize)
    self.plotArea.drawAboutLogo(aspect=0.95, destructCounter=2)

    # set central widget and splitter sizes
    self.MainWindow.setCentralWidget(self.centralwidget)
    self.masterwidget.setSizes([scaledDPI(410), self.masterwidget.size().width() - scaledDPI(410)])

  def buildRessource(self):
    # build the gui
    self.MainWindow.setObjectName("MainWindow")
    self.MainWindow.resize(scaledDPI(1024), scaledDPI(768))
    self.MainWindow.setMinimumWidth(scaledDPI(800))
    self.MainWindow.setMinimumHeight(scaledDPI(600))
    self.MainWindow.setWindowTitle('Fit-o-mat v' + VERSION)
    self.centralwidget = myCentralWidget(argument=self.MainWindow, parent=self)
    self.centralwidget.setObjectName("centralwidget")
    self.vLayout0 = QtWidgets.QVBoxLayout(self.centralwidget)
    self.vLayout0.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.vLayout0.setContentsMargins(0, 0, 0, 0)
    self.masterwidget = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
    self.vLayout0.addWidget(self.masterwidget)
    self.masterwidget.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
    self.masterwidget.setChildrenCollapsible(False)

    self.tabWidget = QtWidgets.QTabWidget()
    self.masterwidget.addWidget(self.tabWidget)
    self.tabWidget.setEnabled(True)
    self.tabWidget.setGeometry(QtCore.QRect(0, 0, scaledDPI(410), scaledDPI(500)))
    #self.tabWidget.setMaximumSize(QtCore.QSize(scaledDPI(410), 16777215))
    self.tabWidget.setMinimumSize(QtCore.QSize(scaledDPI(410), scaledDPI(500)))
    self.tabWidget.setObjectName("tabWidget")

    # the matplotlib canvas
    self.plotArea = MatplotlibCanvas(self)
    self.plotArea.setMinimumSize(QtCore.QSize(scaledDPI(400), scaledDPI(500)))
    self.masterwidget.addWidget(self.plotArea)
    self.masterwidget.setSizes([scaledDPI(410), self.masterwidget.size().height() - scaledDPI(410)])

    # the data tab
    self.tab = QWidgetMac()
    self.tab.setObjectName("tab")
    self.vLayout = QtWidgets.QVBoxLayout(self.tab)
    self.vLayout.setContentsMargins(2, 2, 2, 2)
    self.dataarea = DataArea(self)
    self.vLayout.addWidget(self.dataarea)
    self.tabWidget.addTab(self.tab, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), "Data")

    # the fit tab
    self.tab_2 = QWidgetMac()
    self.tab_2.setObjectName("tab_2")
    self.hLayout2 = QtWidgets.QHBoxLayout(self.tab_2)
    self.hLayout2.setContentsMargins(2, 2, 2, 2)
    self.fitarea = FitArea(self)
    self.hLayout2.addWidget(self.fitarea)
    self.tabWidget.addTab(self.tab_2, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), "Fit")

    # the global fit tab
    self.tab_3 = QWidgetMac()
    self.tab_3.setObjectName("tab_3")
    self.hLayout25 = QtWidgets.QHBoxLayout(self.tab_3)
    self.hLayout25.setContentsMargins(2, 2, 2, 2)
    self.globalarea = GlobalArea(self)
    self.hLayout25.addWidget(self.globalarea)
    self.tabWidget.addTab(self.tab_3, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), "Global")

    # the results tab
    self.tab_4 = QWidgetMac()
    self.tab_4.setObjectName("tab_4")
    self.hLayout3 = QtWidgets.QHBoxLayout(self.tab_4)
    self.hLayout3.setContentsMargins(2, 2, 2, 2)
    self.resultsarea = ResultsArea(self)
    self.hLayout3.addWidget(self.resultsarea)
    self.tabWidget.addTab(self.tab_4, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_4), "Results")

    # the objects tab
    self.tab_5 = QWidgetMac()
    self.tab_5.setObjectName("tab_5")
    self.hLayout4 = QtWidgets.QHBoxLayout(self.tab_5)
    self.hLayout4.setContentsMargins(2, 2, 2, 2)
    self.objectsarea = ObjectsArea(self)
    self.hLayout4.addWidget(self.objectsarea)
    self.tabWidget.addTab(self.tab_5, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_5), "Objects")
    
    # the graphics export tab
    self.tab_6 = QWidgetMac()
    self.hLayout5 = QtWidgets.QHBoxLayout(self.tab_6)
    self.hLayout5.setContentsMargins(2, 2, 2, 2)
    self.graphicsarea = GraphicsArea(self)
    self.hLayout5.addWidget(self.graphicsarea)
    self.tabWidget.addTab(self.tab_6, "")
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_6), "Graphics")
    
    # the 2nd axes tab
    self.tab_7 = QWidgetMac()
    self.hLayout6 = QtWidgets.QHBoxLayout(self.tab_7)
    self.hLayout6.setContentsMargins(2, 2, 2, 2)
    self.graphicsarea2 = GraphicsArea(parent=self, secondAxes=True)
    self.hLayout6.addWidget(self.graphicsarea2)

    # check whether default style exists
    defaultStyle = 'default.style'
    try:
      loadhandle = open(WORKINGDIR + PATH_SEPARATOR + 'styles' + PATH_SEPARATOR + defaultStyle, 'r')
      red = loadhandle.readlines()
      red = ''.join(red)
      loadhandle.close()

      # apply style sheet
      self.graphicsarea.processStyleSet(operation='load', modus=red, zoffsetData=0, zoffsetCurve=0, redraw=False)
    except:
      pass
    
    self.plotArea.initLegend()
    
    # status bad and buttons
    self.statusbar = KuhStatusBar(self.MainWindow)
    self.MainWindow.setStatusBar(self.statusbar)
    
    blah = QtWidgets.QLabel()
    blah.setText('Status OK')
    self.statusbar.addWidget(blah)

    self.zoomLabel = QtWidgets.QLabel()
    self.zoomLabel.setText('Zoom')
    self.zoomLabel.setMaximumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.zoomLabel.setMinimumSize(QtCore.QSize(scaledDPI(35), scaledDPI(BASE_SIZE)))
    self.statusbar.addPermanentWidget(self.zoomLabel)

    self.zoomSelector = QComboBoxMac()
    self.zoomSelector.setMaximumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    self.zoomSelector.setMinimumSize(QtCore.QSize(scaledDPI(50), scaledDPI(BASE_SIZE)))
    for item in self.zoomLevels[::-1]:
      self.zoomSelector.addItem(str(item) + '%')
    currZoomLevel = self.plotArea.matplot.get_dpi()
    if(currZoomLevel in self.zoomLevels):
      self.zoomSelector.setCurrentText(str(currZoomLevel) + '%')
    else:
      self.zoomSelector.setCurrentText('100%')
    self.zoomSelector.currentIndexChanged.connect(self.setZoomLevel)
    self.statusbar.addPermanentWidget(self.zoomSelector)

    self.loadStateButton = QPushButtonMac()
    self.loadStateButton.setText('Open State')
    self.loadStateButton.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.loadStateButton.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.loadStateButton.clicked.connect(partial(self.loadState, None))
    self.statusbar.addPermanentWidget(self.loadStateButton)

    self.saveStateButton = QPushButtonMac()
    self.saveStateButton.setText('Save State')
    self.saveStateButton.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.saveStateButton.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.saveStateButton.clicked.connect(self.saveState)
    self.statusbar.addPermanentWidget(self.saveStateButton)

    self.advancedButton = QPushButtonMac()
    self.advancedButton.setText('Advanced \u25b4')
    self.advancedButton.setMaximumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.advancedButton.setMinimumSize(QtCore.QSize(scaledDPI(60), scaledDPI(BASE_SIZE)))
    self.advancedButton.clicked.connect(partial(self.advancedOption, self.advancedButton))
    self.statusbar.addPermanentWidget(self.advancedButton)

    self.aboutButton = QPushButtonMac()
    self.aboutButton.setText('About')
    self.aboutButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.aboutButton.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.aboutButton.clicked.connect(self.aboutInfo)
    self.statusbar.addPermanentWidget(self.aboutButton)
  
    self.helpButton = QPushButtonMac()
    self.helpButton.setText('Help')
    self.helpButton.setMaximumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.helpButton.setMinimumSize(QtCore.QSize(scaledDPI(40), scaledDPI(BASE_SIZE)))
    self.helpButton.clicked.connect(self.showHelp)
    self.statusbar.addPermanentWidget(self.helpButton)
    
    # give focus to empty data table
    self.dataarea.tableWidget.setFocus()

  def setZoomLevel(self):
    # sets DPI level in data and resid plots
    zoomLevel = str(self.zoomSelector.currentText())
    zoomLevel = zoomLevel.split('%')[0]
    zoomLevel = int(zoomLevel)
    self.plotArea.setZoomLevel(zoomLevel)

  def handleDropEvent(self, mimeData):
    # callback function that handles drag and drop events
    success = False
    if(mimeData.hasUrls()):
      urls = mimeData.urls()
      if(len(urls)):
        filename = urls[0].path()
        if((platform == 'win32') and (filename.startswith('/'))):
          # delete leading slash as this causes problems with the subsequent opening of file
          filename = filename[1:]
        if((filename.endswith('.state')) or (filename.endswith('.statez'))):
          self.loadState(filename, dropEvent=True)
          success = True
      
    if(not success):
      self.statusbar.showMessage('Cannot deal with this input/file type.', self.STATUS_TIME)
  
  def loadState(self, stateFile=None, dropEvent=False):
    # store how many objects we have before the state load
    numberData, numberFit, numberExtras = len(self.data), len(self.fit), len(self.extras)
    # open specific file or select one via file dialog
    if(stateFile != None):
      filename = stateFile
      if(not dropEvent):
        self.discardCheck = False
        self.discard = True
    else:
      global REMEMBERDIR
      # parse state file
      filename, filter_ = QtWidgets.QFileDialog.getOpenFileName(self.centralwidget, filter = 'State file (*.state *.statez)', directory = REMEMBERDIR, caption='Open State')
      filename = str(filename)
      if(PATH_SEPARATOR in filename):
        REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
        REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
      elif('/' in filename):
        REMEMBERDIR = filename.split('/')[:-1]
        REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
        
    # read file contents
    settings = {}; activeCategory = ''
    # check whether this state file is a zip archive
    if(zipfile.is_zipfile(filename)):
      try:
        ziphandle = zipfile.ZipFile(filename)
        fileList = ziphandle.filelist
        if(len(fileList)):
          loadhandle = ziphandle.open(fileList[0].filename, 'r')
          # use wrapper to convert bytes into str
          loadhandle = io.TextIOWrapper(loadhandle, encoding='utf-8')
          success = True
        else:
          success = False
      except:
        success = False
    else:
      try:
        loadhandle = open(filename,'r', encoding='utf-8')
        success = True
      except:
        success = False
    
    if(not success):
      self.statusbar.showMessage('Cannot load state file ' + filename, self.STATUS_TIME)
    else:
      # save filename for future reference
      if(filename.endswith('.statez')):
        self.currStateFile = ''.join(filename.split('.')[:-1]) + '.statez'
      else:
        self.currStateFile = filename
      # display filename in windows title
      self.MainWindow.setWindowTitle('Fit-o-mat v' + VERSION + ' -- ' + self.currStateFile)
      # check whether to discard old items
      if(self.discardCheck):
        msgBox = myQMessageBox()
        msgBox.setWindowTitle('Fit-o-mat')
        msgBox.setText('Discard current objects?')
        msgBox.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        msgBox.setDefaultButton(QtWidgets.QMessageBox.No)
        msgBox.setIcon(QtWidgets.QMessageBox.Question)
        # apply styles and show
        if(QSTYLE != None):
          msgBox.setStyle(QSTYLE)
        if(QSTYLESHEET != None):
          msgBox.setStyleSheet(QSTYLESHEET)
        reply, self.discardCheck = msgBox.exec_()
        if (reply == QtWidgets.QMessageBox.Yes):
          self.discard = True
        else:
          self.discard = False
      # display busy pointer
      QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
      QtCore.QCoreApplication.processEvents()
      # parse file contents
      red = loadhandle.readline()
      while (red):
        if(activeCategory == 'MESSAGE'):
          if(red.find('</MESSAGE>') == 0):
            activeCategory = ''
          else:
            red = red.strip()
            if(activeCategory in settings):
              settings[activeCategory].append(red)
        else:
          if(red.find('<') == 0):
            if(red.find('/') == 1):
              activeCategory = ''
            else:
              activeCategory = red[1:].split('>')[0]
              if(activeCategory in ['GRAPHICS', 'CANVAS', 'OBJECTS', 'ADVANCED', 'ADVANCED_MIN', 'ADVANCED_RANDOM']):
                settings[activeCategory] = {}
              else:
                settings[activeCategory] = []
          elif(red.find('>>>') == 0):
            if(activeCategory != ''):
              entry = red[3:].strip()
              red = loadhandle.readline()
              red = red.strip()
              # convert string input to original data
              try:
                red = literal_eval(red)
                settings[activeCategory][entry] = red
              except:
                self.statusbar.showMessage('Failed to restore setting ' + repr(entry) + repr(red), self.STATUS_TIME)
                print('Failed to restore setting', entry, red)
          else:
            red = red.strip()
            if(activeCategory in settings):
              settings[activeCategory].append(red)
        red = loadhandle.readline()
        
      loadhandle.close()

      # close zip file if handle had been opened
      if(zipfile.is_zipfile(filename)):
        ziphandle.close()

      # apply settings
      # apply axes mode to avoid problems with log axes
      temp_settings = {}
      for entry in ['modeX', 'modeY', 'modeX_div']:
        if(('CANVAS' in settings) and (entry in settings['CANVAS'])):
          temp_settings[entry] = settings['CANVAS'][entry]
        else:
          temp_settings[entry] = 'linear'
      # also update x limits to have curves drawn over entire interval
      for entry in ['minX', 'maxX', 'minX_div', 'maxX_div']:
        if(('CANVAS' in settings) and (entry in settings['CANVAS'])):
          temp_settings[entry] = settings['CANVAS'][entry]
      self.plotArea.restoreState(temp_settings, updateTicks=False)

      # count data sets and curves already present
      zoffsetData = len(self.data)
      zoffsetCurve = len(self.fit)
      zoffsetResid = zoffsetData
      zoffsetExtras = len(self.extras)
      zoffset = zoffsetData + zoffsetCurve
  
      # data sets
      # helper function for sort routine
      def itemSort(a, b):
        # first try converting to integer
        try:
          ia, ib = a.split('_')[-1], b.split('_')[-1]
          ia = int(ia)
          ib = int(ib)
          return (ia > ib) - (ia < ib)
        except:
          return (a > b) - (a < b)

      datasets = [i for i in settings if i.startswith('DATA')]
      datasets = sorted(datasets, key=cmp_to_key(itemSort))
      if(len(datasets)):
        for entry in datasets:
          data = ''.join(settings[entry])
          try:
            data = literal_eval(data)
            # need to restore 'inf' as they did not correctly propagate through ast.literal_eval
            for key in data:
              if(type(data[key]) == list):
                data[key] = [np.inf if (i == 'np.inf') else i for i in data[key]]
                data[key] = [-np.inf if (i == '-np.inf') else i for i in data[key]]
            # generate new data set
            self.data.append(DataObject(self))
            # and restore values
            self.data[-1].restoreState(data, zoffset, zoffsetResid)
            # cause data to be drawn
            self.data[-1].drawMe(redraw=False, rescale=False)
            # also create a new resid object
            self.data[-1].drawMeResid(redraw=False, rescale=False)
          except:
            self.statusbar.showMessage('Failed to restore data set!', self.STATUS_TIME)
            print('Failed to restore data set', data)
          
      # curve sets
      curvesets = [i for i in settings if i.startswith('CURVE')]
      curvesets = sorted(curvesets, key=cmp_to_key(itemSort))
      if(len(curvesets)):
        for entry in curvesets:
          data = ''.join(settings[entry])
          try:
            data = literal_eval(data)
            # need to restore 'inf' as they did not correctly propagate through ast.literal_eval
            for key in data:
              if(type(data[key]) == list):
                data[key] = [np.inf if (i == 'np.inf') else i for i in data[key]]
                data[key] = [-np.inf if (i == '-np.inf') else i for i in data[key]]
            # generate new data set
            self.fit.append(FitObject(self))
            # and restore values
            self.fit[-1].restoreState(data, zoffset)
            # cause data to be drawn
            self.fit[-1].drawMe(redraw=False, rescale=False)
          except:
            self.statusbar.showMessage('Failed to restore curve!', self.STATUS_TIME)
            print('Failed to restore curve', data)
      
      # extras!
      failedImportExtras = []
      extras = [i for i in settings if i.startswith('EXTRAS')]
      extras = sorted(extras, key=lambda k: k.split('_')[-1])
      if(len(extras)):
        for entry in extras:
          data = ''.join(settings[entry])
          try:
            data = literal_eval(data)
            # generate new data set
            self.extras.append(ExtrasObject(self))
            # and restore values
            self.extras[-1].restoreState(data, zoffset)
            # cause data to be drawn
            self.extras[-1].drawMe(redraw=False)
          except:
            self.statusbar.showMessage('Failed to restore extra object!', self.STATUS_TIME)
            print('Failed to restore extra object', data)
            failedImportExtras.append(len(self.extras) - 1)
      
      if((len(datasets)) or (len(curvesets))):
        # update legend
        self.objectsarea.updateLegend(redraw=False)
        
      # objects tab
      if('OBJECTS' in settings):
        self.objectsarea.restoreState(settings['OBJECTS'], zoffsetData, zoffsetCurve, zoffsetExtras, zoffsetResid)
      
      # data area tab
      if('IMPORTTABLE' in settings):
        self.dataarea.restoreState(settings['IMPORTTABLE'])
      
      # call canvas comes last to update certain settings
      if('CANVAS' in settings):
        self.plotArea.restoreState(settings['CANVAS'])
        
      # apply canvas and graphics last to counteract autozoom when generating data and fits
      if('GRAPHICS' in settings):
        red = ''
        for key in settings['GRAPHICS']:
          red += '>>>' + key + '\n'
          red += repr(settings['GRAPHICS'][key]) + '\n'
        self.graphicsarea.processStyleSet(operation='load', modus=red, zoffsetData=zoffsetData,\
                                          zoffsetCurve=zoffsetCurve, redraw=False, rescale=False)

      # very finally check whether state file contained a message to display
      if('MESSAGE' in settings):
        self.displayMessage(settings['MESSAGE'])
        
      # delete extras that failed to import
      for entry in failedImportExtras:
        self.objectsarea.deleteExtra(entry, redraw=False)
      
      # delete initial data and curve objects
      if(self.discard):
        # delete surplus fit objects
        numberFit = min(numberFit, len(self.fit) - 1)
        for entry in range(numberFit)[::-1]:
          self.objectsarea.deleteCurve(entry, redraw=False)
        # delete surplus data objects
        numberData = min(numberData, len(self.data) - 1)
        for entry in range(numberData)[::-1]:
          self.objectsarea.deleteDataSet(entry, redraw=False)
        # delete surplus extra objects
        for entry in range(numberExtras)[::-1]:
          self.objectsarea.deleteExtra(entry, redraw=False)

      # and again call canvas comes last to preserve axis settings
      if('CANVAS' in settings):
        self.plotArea.restoreState(settings['CANVAS'])
        
      # set advanced settings
      if('ADVANCED' in settings):
        self.graphicsarea.advancedExport.update(settings['ADVANCED'])
        if('advancedGraphics' in settings['ADVANCED']):
          value = settings['ADVANCED']['advancedGraphics']
          self.graphicsarea.setAdvancedGraphics(value)
          self.graphicsarea2.setAdvancedGraphics(value)
        
      # set advanced settings
      if('ADVANCED_MIN' in settings):
        self.fitarea.advancedMinimization.update(settings['ADVANCED_MIN'])
        self.globalarea.advancedMinimization.update(settings['ADVANCED_MIN'])
        
      # set advanced settings
      if('ADVANCED_RANDOM' in settings):
        self.fitarea.advancedRandomSearch.update(settings['ADVANCED_RANDOM'])
        self.globalarea.advancedRandomSearch.update(settings['ADVANCED_RANDOM'])
        
      # check whether we have items on the second axes
      self.objectsarea.checkSecondAxes()
        
      # restore discardCheck when loading state on startup
      if((stateFile != None) and (not dropEvent)):
        self.discardCheck = True
        self.discard = False
        
      # finally refresh plots
      try:
        self.plotArea.dataplotwidget.myRefresh()
      except:
        # implement extra check for bad fonts in state file
        safeFont = 'DejaVu Sans'
        # x and y axes
        tempLayout = self.plotArea.ax.xaxis.label._get_layout(self.plotArea.matplot.canvas.renderer)
        if(not tempLayout[-1]):
          self.plotArea.setAxisFont(value=safeFont, axis='x', redraw=True, target='plot')
        tempLayout = self.plotArea.ax.yaxis.label._get_layout(self.plotArea.matplot.canvas.renderer)
        if(not tempLayout[-1]):
          self.plotArea.setAxisFont(value=safeFont, axis='y', redraw=True, target='plot')
          
        # x ticks
        flag = False
        tickLabels = self.plotArea.ax.get_xticklabels()
        for entry in tickLabels:
          tempLayout = entry._get_layout(self.plotArea.matplot.canvas.renderer)
          if(not tempLayout[-1]):
            flag = True
        if(flag):
          self.plotArea.setTickFont(value=safeFont, axis='x', redraw=True, target='plot')
          
        # y ticks
        flag = False
        tickLabels = self.plotArea.ax.get_yticklabels()
        for entry in tickLabels:
          tempLayout = entry._get_layout(self.plotArea.matplot.canvas.renderer)
          if(not tempLayout[-1]):
            flag = True
        if(flag):
          self.plotArea.setTickFont(value=safeFont, axis='y', redraw=True, target='plot')
          
        # legend (get_layout trick won't work here ... would need to draw extra text ... too complicated)
        # this is easier if clumsy
        probeFont = self.plotArea.legendLabelFont; self.plotArea.legendLabelFont = safeFont
        self.plotArea.setLegendLabelFont(value=probeFont, redraw=True, target='plot')
        
        # now also need to check extras
        for entry in self.extras:
          if(entry.handle != None):
            tempLayout = entry.handle._get_layout(self.plotArea.matplot.canvas.renderer)
            if(not tempLayout[-1]):
              entry.handle.set_fontname(safeFont)
              try:
                self.plotArea.dataplotwidget.myRefresh()
              except:
                pass
        
      try:        
        self.plotArea.residplotwidget.myRefresh()
      except:
        # implement extra check for bad fonts in state file
        safeFont = 'DejaVu Sans'
        # x and y axes
        tempLayout = self.plotArea.ax_resid.xaxis.label._get_layout(self.plotArea.residplot.canvas.renderer)
        if(not tempLayout[-1]):
          self.plotArea.setAxisFont(value=safeFont, axis='x', redraw=True, target='resid')
        tempLayout = self.plotArea.ax_resid.yaxis.label._get_layout(self.plotArea.residplot.canvas.renderer)
        if(not tempLayout[-1]):
          self.plotArea.setAxisFont(value=safeFont, axis='y', redraw=True, target='resid')
          
        # x ticks
        flag = False
        tickLabels = self.plotArea.ax_resid.get_xticklabels()
        for entry in tickLabels:
          tempLayout = entry._get_layout(self.plotArea.residplot.canvas.renderer)
          if(not tempLayout[-1]):
            flag = True
        if(flag):
          self.plotArea.setTickFont(value=safeFont, axis='x', redraw=True, target='resid')
          
        # y ticks
        flag = False
        tickLabels = self.plotArea.ax_resid.get_yticklabels()
        for entry in tickLabels:
          tempLayout = entry._get_layout(self.plotArea.residplot.canvas.renderer)
          if(not tempLayout[-1]):
            flag = True
        if(flag):
          self.plotArea.setTickFont(value=safeFont, axis='y', redraw=True, target='resid')
      # restore original pointer
      QtWidgets.QApplication.restoreOverrideCursor()

  def saveState(self):
    global REMEMBERDIR
    # exports current settings and data
    filter_options = ['State file (*.state; *.statez)', 'All files (*.*)']
    filterstring = ';;'.join(filter_options)
    # get save file name
    usedir = REMEMBERDIR
    if(self.currStateFile != None):
      usedir = self.currStateFile
    filename, filter_ = QtWidgets.QFileDialog.getSaveFileName(self.centralwidget, filter = filterstring, directory=usedir, caption='Save State')
    filename = str(filename)
    if(PATH_SEPARATOR in filename):
      REMEMBERDIR = filename.split(PATH_SEPARATOR)[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)
    elif('/' in filename):
      REMEMBERDIR = filename.split('/')[:-1]
      REMEMBERDIR = PATH_SEPARATOR.join(REMEMBERDIR)

    if(filename != ''):
      # use StringIO to write memory file
      memoryFile = io.StringIO()
      # process canvas
      memoryFile.write('<CANVAS>\n')
      settings = self.plotArea.reportState()
      for key in settings:
        red = '>>>' + key + '\n' + repr(settings[key]) + '\n'
        memoryFile.write(red)
      memoryFile.write('</CANVAS>\n')
      
      # process objects tab
      memoryFile.write('\n<OBJECTS>\n')
      objects = self.objectsarea.reportState()
      memoryFile.write(objects)
      memoryFile.write('</OBJECTS>\n')
      
      # process graphics tab
      memoryFile.write('\n<GRAPHICS>\n')
      settings = self.graphicsarea.processStyleSet(operation='save', modus='string')
      memoryFile.write(settings)
      memoryFile.write('</GRAPHICS>\n')
      
      # process data area
      memoryFile.write('\n<IMPORTTABLE>\n')
      dataTable = self.dataarea.reportState()
      memoryFile.write(repr(dataTable) + '\n')
      memoryFile.write('</IMPORTTABLE>\n')
      
      # write all data and fit objects
      for index, entry in enumerate(self.data):
        memoryFile.write('\n<DATA_' + str(index) + '>\n')
        data = entry.reportState()
        data = self.replaceInf(repr(data))
        memoryFile.write(data + '\n')
        memoryFile.write('</DATA_' + str(index) + '>\n')
  
      for index, entry in enumerate(self.fit):
        memoryFile.write('\n<CURVE_' + str(index) + '>\n')
        curve = entry.reportState()
        curve = self.replaceInf(repr(curve))
        memoryFile.write(curve + '\n')
        memoryFile.write('</CURVE_' + str(index) + '>\n')
  
      # write all extra objects
      for index, entry in enumerate(self.extras):
        memoryFile.write('\n<EXTRAS_' + str(index) + '>\n')
        extras = repr(entry.reportState())
        memoryFile.write(extras + '\n')
        memoryFile.write('</EXTRAS_' + str(index) + '>\n')
    
      # write advanced settings
      memoryFile.write('\n<ADVANCED>\n')
      for entry in self.graphicsarea.advancedExport:
        memoryFile.write('>>>' + entry + '\n')
        memoryFile.write(repr(self.graphicsarea.advancedExport[entry]) + '\n')
      memoryFile.write('</ADVANCED>\n')
    
      # write advanced settings
      memoryFile.write('\n<ADVANCED_MIN>\n')
      for entry in self.fitarea.advancedMinimization:
        memoryFile.write('>>>' + entry + '\n')
        memoryFile.write(repr(self.fitarea.advancedMinimization[entry]) + '\n')
      memoryFile.write('</ADVANCED_MIN>\n')
    
      # write advanced settings
      memoryFile.write('\n<ADVANCED_RANDOM>\n')
      for entry in self.fitarea.advancedRandomSearch:
        memoryFile.write('>>>' + entry + '\n')
        memoryFile.write(repr(self.fitarea.advancedRandomSearch[entry]) + '\n')
      memoryFile.write('</ADVANCED_RANDOM>\n')
  
      # prepare file output
      success = False
      if(self.graphicsarea.advancedExport['stateFileFormat'] in ['both', 'state']):
        # save regular state file
        try:
          if(filename.endswith('.state')):
            writehandle = open(filename, 'w', encoding='utf-8')
          else:
            writehandle = open(filename + '.state', 'w', encoding='utf-8')
          writehandle.write(memoryFile.getvalue())
        except:
          self.statusbar.showMessage('Cannot save state file ' + filename, self.STATUS_TIME)
        else:
          writehandle.close()
          success = True
        
      if(self.graphicsarea.advancedExport['stateFileFormat'] in ['both', 'statez']):
        # now zip this file
        try:
          if(filename.endswith('.state')):
            ziphandle = zipfile.ZipFile(filename + 'z', 'w', zipfile.ZIP_DEFLATED)
          elif(filename.endswith('.statez')):
            ziphandle = zipfile.ZipFile(filename, 'w', zipfile.ZIP_DEFLATED)
          else:
            ziphandle = zipfile.ZipFile(filename + '.statez', 'w', zipfile.ZIP_DEFLATED)
          if(PATH_SEPARATOR in filename):
            storeName = filename.split(PATH_SEPARATOR)[-1]
          else:
            storeName = filename.split('/')[-1]
          storeName = storeName.replace('.statez', '.state')
          ziphandle.writestr(storeName, memoryFile.getvalue())
        except:
          self.statusbar.showMessage('Cannot save state file ' + filename, self.STATUS_TIME)
        else:
          ziphandle.close()
          success = True
        
      if(success):
        # save filename for future reference
        self.currStateFile = filename
        # update window title if successful
        self.MainWindow.setWindowTitle('Fit-o-mat v' + VERSION + ' -- ' + filename)

  def replaceInf(self, literal):
    # function to replace any 'inf' by 'np.inf' (otherwise data cannot be loaded again)
    literal = literal.replace('-inf]', '\'-np.inf\']')
    literal = literal.replace('-inf,', '\'-np.inf\',')
    literal = literal.replace('inf]', '\'np.inf\']')
    literal = literal.replace('inf,', '\'np.inf\',')
    # and replace nan
    literal = literal.replace('nan]', '\'np.nan\']')
    literal = literal.replace('nan,', '\'np.nan\',')
    return literal
    
  def showHelp(self):
    # display help file in browser
    helpFile = WORKINGDIR + PATH_SEPARATOR + 'manual' + PATH_SEPARATOR + 'Fit-o-mat.html'
    try:
      readhandle = open(helpFile, 'r')
      readhandle.close()
    except:
      self.statusbar.showMessage('Cannot locate local copy of help files, redirecting to homepage!', self.STATUS_TIME)
      helpFile = 'http://www.moeglich.uni-bayreuth.de/en/fit-o-mat'
    webbrowser.open(helpFile)

  def aboutInfo(self):
    # display information on canvas
    self.plotArea.drawAboutLogo()
    
  def advancedOption(self, callButton=None):
    # opens menu to access advanced configuration options
    self.menu = OptionMenu(self)
    # apply styles to popup window
    if(QSTYLE != None):
      self.menu.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      self.menu.setStyleSheet(QSTYLESHEET)

    # bottom align position of QMenu
    # first need to display QMenu to get reliable size (even sizeHint fails)
    self.menu.popup(QtGui.QCursor.pos())
    # now move window to new position
    if(callButton != None):
      qPoint = callButton.mapToGlobal(QtCore.QPoint(0, 0))
      menuX, menuY = qPoint.x(), qPoint.y()
      menuX += callButton.geometry().width()
    else:
      menuX, menuY = QtGui.QCursor.pos().x(), QtGui.QCursor.pos().y()

    menuX -= self.menu.width() / 2
    menuY -= self.menu.height()
    menuX, menuY = max(menuX, 0), max(menuY, 0)
    menuPos = QtCore.QPoint(menuX, menuY)
    self.menu.move(menuPos)

  def displayMessage(self, message=''):
    # displays message contained in state file
    if(len(message)):
      messageText = '\n'.join(message)
      # open window that displays message
      self.daughterWindow = QtWidgets.QMainWindow()
      self.daughterWindow.setWindowTitle('Message Window')
      
      self.centralwidget = QWidgetMac(self.daughterWindow)
      self.centralwidget.setMinimumSize(QtCore.QSize(scaledDPI(320), scaledDPI(240)))
      self.daughterWindow.setCentralWidget(self.centralwidget)
      
      self.vLayout = QtWidgets.QVBoxLayout(self.centralwidget)
      self.vLayout.setAlignment(QtCore.Qt.AlignCenter|QtCore.Qt.AlignTop)
      self.vLayout.setContentsMargins(0, 0, 0, 0)

      self.messageField = QtWidgets.QTextBrowser()
      self.messageField.setOpenExternalLinks(True)
      self.messageField.setGeometry(QtCore.QRect(0, 0, scaledDPI(500), scaledDPI(600)))
      self.vLayout.addWidget(self.messageField)
      self.messageField.setReadOnly(True)
      self.messageField.setHtml(messageText)
      
      # apply styles and show
      if(QSTYLE != None):
        self.daughterWindow.setStyle(QSTYLE)
      if(QSTYLESHEET != None):
        self.daughterWindow.setStyleSheet(QSTYLESHEET)
      self.daughterWindow.show()
      
      # adjust window position and size
      winWidth, winHeight = self.daughterWindow.geometry().width(), self.MainWindow.geometry().height()
      self.daughterWindow.resize(winWidth, winHeight)
      winX, winY = self.daughterWindow.geometry().x(), self.MainWindow.geometry().y()
      self.daughterWindow.move(winX, winY)
    
  def formatNumber(self, number):
    # formats number for output
    NUMBER_SWITCH = 1e3
    FORMAT_DECIMAL = '{:.4f}'
    FORMAT_SCIENTIFIC = '{:.4e}'
    # determine return string
    if((self.isNumber(number)) and (np.isfinite(float(number)))):
      if((np.abs(number)>NUMBER_SWITCH) or (np.abs(number)<1.0/NUMBER_SWITCH)):
        numberstr = FORMAT_SCIENTIFIC.format(number)
      else:
        numberstr = FORMAT_DECIMAL.format(number)
    else:
      numberstr = str(number)
    
    return numberstr

  def isNumber(self, s):
    # checks whether string is a number
    try:
      float(s)
      return True
    except ValueError:
      pass
   
    try:
      import unicodedata
      unicodedata.numeric(s)
      return True
    except (TypeError, ValueError):
      pass
    
    return False

class MyForm(QtWidgets.QMainWindow):
  def __init__(self, parent=None):
    QtWidgets.QWidget.__init__(self, parent)
    # adjust DPI scaling
    global DPI_SCALING
    self.targetDPI = 96
    actualDPI = QtGui.QPaintDevice.logicalDpiX(self)
    DPI_SCALING = 1.0 * actualDPI / self.targetDPI
    self.ui = Ui_MainWindow()
    self.ui.setupUi(MainWindow=self)

    # enable drop event
    self.setAcceptDrops(True)
    
  def dropEvent(self, event):
    self.ui.handleDropEvent(event.mimeData())
    ####event.setDropAction(QtCore.Qt.MoveAction)
    event.accept()

  # we must handle dragEnter and dragMove lest we cannot detect the dropEvent
  def dragEnterEvent(self, event):
    event.accept()

  def dragMoveEvent(self, event):
    event.accept()

  def closeEvent(self, event):
    msgBox = QtWidgets.QMessageBox()
    msgBox.setWindowTitle('Fit-o-mat')
    msgBox.setText('Close program?')
    msgBox.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
    msgBox.setDefaultButton(QtWidgets.QMessageBox.Yes)
    msgBox.setIcon(QtWidgets.QMessageBox.Question)
    # apply styles and show
    if(QSTYLE != None):
      msgBox.setStyle(QSTYLE)
    if(QSTYLESHEET != None):
      msgBox.setStyleSheet(QSTYLESHEET)
    reply = msgBox.exec_()
    if (reply == QtWidgets.QMessageBox.Yes):
      # check whether message window exists and close it
      if(hasattr(self.ui, 'daughterWindow')):
        self.ui.daughterWindow.close()
      # check whether preview window exists and close it
      if(hasattr(self.ui, 'previewWindow')):
        self.ui.previewWindow.close()
      event.accept()
    else:
      event.ignore()

  def keyPressEvent(self, event):
    if event.matches(QtGui.QKeySequence.Save):
      # trigger save state on CTRL-S
      self.ui.saveState()
    elif event.matches(QtGui.QKeySequence.Open):
      # trigger load state on CTRL-O
      self.ui.loadState()
    elif event.matches(QtGui.QKeySequence.HelpContents):
      # trigger help
      self.ui.showHelp()
    elif event.matches(QtGui.QKeySequence.Print):
      # export graphics on CTRL-P
      self.ui.graphicsarea.exportThis()
    elif event.matches(QtGui.QKeySequence.Quit):
      # close program on CTRL-Q
      self.close()
    elif event.matches(QtGui.QKeySequence.Italic):
      # hijack control-I to load new data file and switch to data tab
      retv = self.ui.dataarea.loadData()
      if(retv):
        self.ui.tabWidget.setCurrentIndex(0)
    elif event.matches(QtGui.QKeySequence.ZoomIn):
      # zoom canvas
      self.ui.plotArea.incZoomLevel(increment=-1)
    elif event.matches(QtGui.QKeySequence.ZoomOut):
      # zoom canvas
      self.ui.plotArea.incZoomLevel(increment=1)
    elif event.matches(QtGui.QKeySequence.Find):
      # fit data and switch to fit tab
      retv = self.ui.fitarea.doFit()
      if(retv):
        self.ui.tabWidget.setCurrentIndex(1)
    elif event.matches(QtGui.QKeySequence.New):
      # fit data and switch to fit tab
      retv = self.ui.fitarea.doMin()
      if(retv):
        self.ui.tabWidget.setCurrentIndex(1)
    elif event.matches(QtGui.QKeySequence.Refresh):
      # display preview window
      self.ui.graphicsarea.previewThis()
    elif event.matches(QtGui.QKeySequence.FindNext):
      # generate report
      self.ui.graphicsarea.reportThis()

def scaledDPI(size):
  # adjusts GUI dimensions to correct for DPI
  # implement check for array
  return int(size * DPI_SCALING)

def switchTab(index=0):
  # switches to target tab (handler for keyboard shortcut)
  if(0 <= index < myapp.ui.tabWidget.count()):
    myapp.ui.tabWidget.setCurrentIndex(index)

if __name__ ==  "__main__":
  # are we on win or linux platform?
  if((platform == 'linux') or (platform == 'darwin')):
    PATH_SEPARATOR = '/'
  else:
    PATH_SEPARATOR = '\\'
    
  # determine working directories
  if((len(path)) and (len(path[0]))):
    WORKINGDIR = path[0]
  else:
    WORKINGDIR = '.'
  HOMEDIR = expanduser('~')
  REMEMBERDIR = HOMEDIR
  
  # set name of temp. preview file
  TEMP_PREVIEWFILE = 'temp_fit-o-mat_preview.png'
  
  # check for command line arguments
  STATEFILE = ''; grabNext = False; grabReal = False; WIDGET_FONTSIZE = '8'
  if(len(argv) > 1):
    for argument in argv[1:]:
      if(argument.startswith('-')):
        grabNext = True
        if(argument.startswith('-font')):
          grabReal = True
      elif(grabNext):
        grabNext = False
        # enable dynamic font sizing under Linux
        if(grabReal):
          try:
            float(argument)
            WIDGET_FONTSIZE = str(argument)
          except:
            pass
          grabReal = False
      elif(STATEFILE == ''):
        STATEFILE = argument
    
  # start app
  DPI_SCALING = 1.0
  PICK_TOLERANCE = 10
  QSTYLE, QSTYLESHEET = None, None
  if(platform == 'darwin'):
    # special treatment for OS X (native style is just killing me)
    BASE_SIZE = 22
    QSTYLE = QtWidgets.QStyleFactory.create('Fusion')
    # set style sheet to approx. retain correct look
    QSTYLESHEET  = "QComboBox {font-size: " + WIDGET_FONTSIZE + "pt; margin: 0px; padding-left: 3px;}\n\
                    QWidget {font-size: " + WIDGET_FONTSIZE + "pt; margin: 0px; padding: 0px;}\n\
                    QRadioButton {font-size: " + WIDGET_FONTSIZE + "pt; margin: 0px; padding: 0px; spacing: 3px;}\n\
                    QRadioButton::indicator {width: 12px; height: 12px;}\n\
                    QTableView::item:focus {background-color: white; color: black;}\n\
                    QTableView {alternate-background-color: #f1f1f1;}\n\
                    QTableView#data QTableCornerButton {background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #bbaafc, stop: 0.3 #9988fc, stop: 0.8 #9988fc, stop: 1.0 #8877fc);}\n\
                    QPushButton:checked {background-color: #5544fc; color: black;}\n\
                    QPushButton:checked:hover {background-color: #bbaaff; color: black;}\n\
                    QTabBar::tab:selected {background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #bbaafc, stop: 0.3 #9988fc, stop: 0.8 #9988fc, stop: 1.0 #8877fc);}\n\
                    QPushButton:checked:!enabled {background-color: #ccbbff; color: #787878;}\n\
                    QGroupBox {font-size: " + WIDGET_FONTSIZE + "pt; margin: 0px; border-style: inset; border-width: 1px; border-radius: 3px; border-color: #777777;}\n"
  else:
    BASE_SIZE = 22
    QSTYLE = QtWidgets.QStyleFactory.create('Fusion')
    QSTYLESHEET  = "QTableView::item:focus {background-color: white; color: black;}\n\
                    QTableView {alternate-background-color: #f1f1f1;}\n\
                    QTableView#data QTableCornerButton {background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #bbaafc, stop: 0.3 #9988fc, stop: 0.8 #9988fc, stop: 1.0 #8877fc);}\n\
                    QPushButton:checked {background-color: #5544fc; color: black;}\n\
                    QPushButton:checked:hover {background-color: #bbaaff; color: black;}\n\
                    QPushButton:checked:!enabled {background-color: #ccbbff; color: #787878;}\n\
                    QTabBar::tab:selected {background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #bbaafc, stop: 0.3 #9988fc, stop: 0.8 #9988fc, stop: 1.0 #8877fc);}\n\
                    QGroupBox {border-style: inset; border-width: 1px; border-radius: 3px; border-color: #777777;}\n"
    if('linux' in platform):
      QSTYLESHEET += "QWidget {font-size: " + WIDGET_FONTSIZE + "pt;}\n"

  app = QtWidgets.QApplication(argv)
  myapp = MyForm()
  if(QSTYLE != None):
    myapp.setStyle(QSTYLE)
  if(QSTYLESHEET != None):
    myapp.setStyleSheet(QSTYLESHEET)
  myapp.show()
  
  # now we have to again adjust splitter sizes
  myapp.ui.masterwidget.setSizes([scaledDPI(410), myapp.ui.masterwidget.size().width() - scaledDPI(410)])
  
  # and update ruler to current canvas size
  QtCore.QCoreApplication.processEvents()
  myapp.ui.plotArea.horizontalRuler.updateRuler()
  myapp.ui.plotArea.verticalRuler.updateRuler()
  myapp.ui.plotArea.verticalRulerResid.updateRuler()
  
  # define custom key bindings
  myapp.bindings = []
  for index in range(myapp.ui.tabWidget.count() + 1):
    # count up one more to account for non-visible 2nd Axes tab
    myapp.bindings.append(QtWidgets.QShortcut(QtGui.QKeySequence('Ctrl+' + str(index + 1)), myapp))
    myapp.bindings[index].activated.connect(partial(switchTab, index))
  
  # now check whether state should be loaded
  if(STATEFILE != ''):
    QtCore.QCoreApplication.processEvents()
    myapp.ui.loadState(stateFile=STATEFILE)
  
  exit(app.exec_())